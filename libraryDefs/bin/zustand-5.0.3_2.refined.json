{
  "0": {
    "name": "SkipTwo",
    "type": "T extends {\n    length: 0;\n} ? [] : T extends {\n    length: 1;\n} ? [] : T extends {\n    length: 0 | 1;\n} ? [] : T extends [unknown, unknown, ...infer A] ? A : T extends [unknown, unknown?, ...infer A] ? A : T extends [unknown?, unknown?, ...infer A] ? A : never",
    "properties": [
      {
        "name": "length",
        "type": "number",
        "optional": false
      },
      {
        "name": "toString",
        "type": "(() => string) | (() => string)",
        "optional": false
      },
      {
        "name": "toLocaleString",
        "type": "{ (): string; (locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string; } | { (): string; (locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string; }",
        "optional": false
      },
      {
        "name": "pop",
        "type": "(() => never) | (() => unknown)",
        "optional": false
      },
      {
        "name": "push",
        "type": "((...items: never[]) => number) | ((...items: unknown[]) => number)",
        "optional": false
      },
      {
        "name": "concat",
        "type": "{ (...items: ConcatArray<never>[]): never[]; (...items: ConcatArray<never>[]): never[]; } | { (...items: ConcatArray<unknown>[]): unknown[]; (...items: unknown[]): unknown[]; }",
        "optional": false
      },
      {
        "name": "join",
        "type": "((separator?: string) => string) | ((separator?: string) => string)",
        "optional": false
      },
      {
        "name": "reverse",
        "type": "(() => never[]) | (() => unknown[])",
        "optional": false
      },
      {
        "name": "shift",
        "type": "(() => never) | (() => unknown)",
        "optional": false
      },
      {
        "name": "slice",
        "type": "((start?: number, end?: number) => never[]) | ((start?: number, end?: number) => unknown[])",
        "optional": false
      },
      {
        "name": "sort",
        "type": "((compareFn?: (a: never, b: never) => number) => []) | ((compareFn?: (a: unknown, b: unknown) => number) => unknown[])",
        "optional": false
      },
      {
        "name": "splice",
        "type": "{ (start: number, deleteCount?: number): never[]; (start: number, deleteCount: number, ...items: never[]): never[]; } | { (start: number, deleteCount?: number): unknown[]; (start: number, deleteCount: number, ...items: unknown[]): unknown[]; }",
        "optional": false
      },
      {
        "name": "unshift",
        "type": "((...items: never[]) => number) | ((...items: unknown[]) => number)",
        "optional": false
      },
      {
        "name": "indexOf",
        "type": "((searchElement: never, fromIndex?: number) => number) | ((searchElement: unknown, fromIndex?: number) => number)",
        "optional": false
      },
      {
        "name": "lastIndexOf",
        "type": "((searchElement: never, fromIndex?: number) => number) | ((searchElement: unknown, fromIndex?: number) => number)",
        "optional": false
      },
      {
        "name": "every",
        "type": "{ <S>(predicate: (value: never, index: number, array: never[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: never, index: number, array: never[]) => unknown, thisArg?: any): boolean; } | { <S>(predicate: (value: unknown, index: number, array: unknown[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any): boolean; }",
        "optional": false
      },
      {
        "name": "some",
        "type": "((predicate: (value: never, index: number, array: never[]) => unknown, thisArg?: any) => boolean) | ((predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any) => boolean)",
        "optional": false
      },
      {
        "name": "forEach",
        "type": "((callbackfn: (value: never, index: number, array: never[]) => void, thisArg?: any) => void) | ((callbackfn: (value: unknown, index: number, array: unknown[]) => void, thisArg?: any) => void)",
        "optional": false
      },
      {
        "name": "map",
        "type": "(<U>(callbackfn: (value: never, index: number, array: never[]) => U, thisArg?: any) => U[]) | (<U>(callbackfn: (value: unknown, index: number, array: unknown[]) => U, thisArg?: any) => U[])",
        "optional": false
      },
      {
        "name": "filter",
        "type": "{ <S>(predicate: (value: never, index: number, array: never[]) => value is S, thisArg?: any): S[]; (predicate: (value: never, index: number, array: never[]) => unknown, thisArg?: any): never[]; } | { <S>(predicate: (value: unknown, index: number, array: unknown[]) => value is S, thisArg?: any): S[]; (predicate: (value: unknown, index: number, array: unknown[]) => unknown, thisArg?: any): unknown[]; }",
        "optional": false
      },
      {
        "name": "reduce",
        "type": "{ (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never): never; (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never, initialValue: never): never; <U>(callbackfn: (previousValue: U, currentValue: never, currentIndex: number, array: never[]) => U, initialValue: U): U; } | { (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown): unknown; (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown, initialValue: unknown): unknown; <U>(callbackfn: (previousValue: U, currentValue: unknown, currentIndex: number, array: unknown[]) => U, initialValue: U): U; }",
        "optional": false
      },
      {
        "name": "reduceRight",
        "type": "{ (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never): never; (callbackfn: (previousValue: never, currentValue: never, currentIndex: number, array: never[]) => never, initialValue: never): never; <U>(callbackfn: (previousValue: U, currentValue: never, currentIndex: number, array: never[]) => U, initialValue: U): U; } | { (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown): unknown; (callbackfn: (previousValue: unknown, currentValue: unknown, currentIndex: number, array: unknown[]) => unknown, initialValue: unknown): unknown; <U>(callbackfn: (previousValue: U, currentValue: unknown, currentIndex: number, array: unknown[]) => U, initialValue: U): U; }",
        "optional": false
      },
      {
        "name": "find",
        "type": "{ <S>(predicate: (value: never, index: number, obj: never[]) => value is S, thisArg?: any): S; (predicate: (value: never, index: number, obj: never[]) => unknown, thisArg?: any): never; } | { <S>(predicate: (value: unknown, index: number, obj: unknown[]) => value is S, thisArg?: any): S; (predicate: (value: unknown, index: number, obj: unknown[]) => unknown, thisArg?: any): unknown; }",
        "optional": false
      },
      {
        "name": "findIndex",
        "type": "((predicate: (value: never, index: number, obj: never[]) => unknown, thisArg?: any) => number) | ((predicate: (value: unknown, index: number, obj: unknown[]) => unknown, thisArg?: any) => number)",
        "optional": false
      },
      {
        "name": "fill",
        "type": "((value: never, start?: number, end?: number) => []) | ((value: unknown, start?: number, end?: number) => unknown[])",
        "optional": false
      },
      {
        "name": "copyWithin",
        "type": "((target: number, start: number, end?: number) => []) | ((target: number, start: number, end?: number) => unknown[])",
        "optional": false
      },
      {
        "name": "entries",
        "type": "(() => ArrayIterator<[number, never]>) | (() => ArrayIterator<[number, unknown]>)",
        "optional": false
      },
      {
        "name": "keys",
        "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>)",
        "optional": false
      },
      {
        "name": "values",
        "type": "(() => ArrayIterator<never>) | (() => ArrayIterator<unknown>)",
        "optional": false
      },
      {
        "name": "includes",
        "type": "((searchElement: never, fromIndex?: number) => boolean) | ((searchElement: unknown, fromIndex?: number) => boolean)",
        "optional": false
      },
      {
        "name": "flatMap",
        "type": "(<U, This>(callback: (this: This, value: never, index: number, array: never[]) => U | readonly U[], thisArg?: This) => U[]) | (<U, This>(callback: (this: This, value: unknown, index: number, array: unknown[]) => U | readonly U[], thisArg?: This) => U[])",
        "optional": false
      },
      {
        "name": "flat",
        "type": "(<A, D>(this: A, depth?: D) => FlatArray<A, D>[]) | (<A, D>(this: A, depth?: D) => FlatArray<A, D>[])",
        "optional": false
      },
      {
        "name": "__@iterator@3299",
        "type": "(() => ArrayIterator<never>) | (() => ArrayIterator<unknown>)",
        "optional": false
      },
      {
        "name": "__@unscopables@3301",
        "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; splice?: boolean; unshift?: boolean; indexOf?: boolean; lastIndexOf?: boolean; every?: boolean; some?: boolean; forEach?: boolean; map?: boolean; filter?: boolean; reduce?: boolean; reduceRight?: boolean; find?: boolean; findIndex?: boolean; fill?: boolean; copyWithin?: boolean; entries?: boolean; keys?: boolean; values?: boolean; includes?: boolean; flatMap?: boolean; flat?: boolean; [Symbol.iterator]?: boolean; readonly [Symbol.unscopables]?: boolean; at?: boolean; } | { [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; splice?: boolean; unshift?: boolean; indexOf?: boolean; lastIndexOf?: boolean; every?: boolean; some?: boolean; forEach?: boolean; map?: boolean; filter?: boolean; reduce?: boolean; reduceRight?: boolean; find?: boolean; findIndex?: boolean; fill?: boolean; copyWithin?: boolean; entries?: boolean; keys?: boolean; values?: boolean; includes?: boolean; flatMap?: boolean; flat?: boolean; [Symbol.iterator]?: boolean; readonly [Symbol.unscopables]?: boolean; at?: boolean; }",
        "optional": false
      },
      {
        "name": "at",
        "type": "((index: number) => never) | ((index: number) => unknown)",
        "optional": false
      }
    ],
    "xaiDescription": "Utility type to extract array elements after first two. Uses array patterns.",
    "isExported": false
  },
  "1": {
    "name": "StoreImmer",
    "type": "S extends {\n    setState: infer SetState;\n} ? SetState extends {\n    (...a: infer A1): infer Sr1;\n    (...a: infer A2): infer Sr2;\n} ? {\n    setState(nextStateOrUpdater: SetStateType<A2> | Partial<SetStateType<A2>> | ((state: Draft<SetStateType<A2>>) => void), shouldReplace?: false, ...a: SkipTwo<A1>): Sr1;\n    setState(nextStateOrUpdater: SetStateType<A2> | ((state: Draft<SetStateType<A2>>) => void), shouldReplace: true, ...a: SkipTwo<A2>): Sr2;\n} : never : never",
    "properties": [],
    "xaiDescription": "Enhances setState with Immer for immutable state updates.",
    "isExported": false
  },
  "2": {
    "name": "WithImmer",
    "type": "Write<S, StoreImmer<S>>",
    "properties": [],
    "xaiDescription": "Applies Immer to store for draft-based state management.",
    "isExported": false
  },
  "3": {
    "name": "Write",
    "type": "Omit<T, keyof U> & U",
    "properties": [],
    "xaiDescription": "Merges U into T, omitting overlapping keys from T.",
    "isExported": false
  },
  "4": {
    "name": "JsonStorageOptions",
    "type": "{\n    reviver?: (key: string, value: unknown) => unknown;\n    replacer?: (key: string, value: unknown) => unknown;\n}",
    "properties": [
      {
        "name": "reviver",
        "type": "(key: string, value: unknown) => unknown",
        "optional": true
      },
      {
        "name": "replacer",
        "type": "(key: string, value: unknown) => unknown",
        "optional": true
      }
    ],
    "xaiDescription": "Options for customizing JSON serialization and deserialization.",
    "isExported": false
  },
  "5": {
    "name": "Persist",
    "type": "<T, Mps extends [StoreMutatorIdentifier, unknown][] = [], Mcs extends [StoreMutatorIdentifier, unknown][] = [], U = T>(initializer: StateCreator<T, [...Mps, ['zustand/persist', unknown]], Mcs>, options: PersistOptions<T, U>) => StateCreator<T, Mps, [['zustand/persist', U], ...Mcs]>",
    "properties": [],
    "xaiDescription": "Adds persistence middleware to Zustand state creator.",
    "isExported": false
  },
  "6": {
    "name": "PersistListener",
    "type": "(state: S) => void",
    "properties": [],
    "xaiDescription": "Callback function to handle state changes on persist.",
    "isExported": false
  },
  "7": {
    "name": "PersistOptions",
    "type": "export interface PersistOptions<S, PersistedState = S> {\n    /** Name of the storage (must be unique) */\n    name: string;\n    /**\n     * Use a custom persist storage.\n     *\n     * Combining `createJSONStorage` helps creating a persist storage\n     * with JSON.parse and JSON.stringify.\n     *\n     * @default createJSONStorage(() => localStorage)\n     */\n    storage?: PersistStorage<PersistedState> | undefined;\n    /**\n     * Filter the persisted value.\n     *\n     * @params state The state's value\n     */\n    partialize?: (state: S) => PersistedState;\n    /**\n     * A function returning another (optional) function.\n     * The main function will be called before the state rehydration.\n     * The returned function will be called after the state rehydration or when an error occurred.\n     */\n    onRehydrateStorage?: (state: S) => ((state?: S, error?: unknown) => void) | void;\n    /**\n     * If the stored state's version mismatch the one specified here, the storage will not be used.\n     * This is useful when adding a breaking change to your store.\n     */\n    version?: number;\n    /**\n     * A function to perform persisted state migration.\n     * This function will be called when persisted state versions mismatch with the one specified here.\n     */\n    migrate?: (persistedState: unknown, version: number) => PersistedState | Promise<PersistedState>;\n    /**\n     * A function to perform custom hydration merges when combining the stored state with the current one.\n     * By default, this function does a shallow merge.\n     */\n    merge?: (persistedState: unknown, currentState: S) => S;\n    /**\n     * An optional boolean that will prevent the persist middleware from triggering hydration on initialization,\n     * This allows you to call `rehydrate()` at a specific point in your apps rendering life-cycle.\n     *\n     * This is useful in SSR application.\n     *\n     * @default false\n     */\n    skipHydration?: boolean;\n}",
    "properties": [
      {
        "name": "name",
        "type": "string",
        "optional": false
      },
      {
        "name": "storage",
        "type": "import(\"/Users/Thy/TypeDefLib/node_modules/zustand/middleware/persist\").PersistStorage<PersistedState>",
        "optional": true
      },
      {
        "name": "partialize",
        "type": "(state: S) => PersistedState",
        "optional": true
      },
      {
        "name": "onRehydrateStorage",
        "type": "(state: S) => void | ((state?: S, error?: unknown) => void)",
        "optional": true
      },
      {
        "name": "version",
        "type": "number",
        "optional": true
      },
      {
        "name": "migrate",
        "type": "(persistedState: unknown, version: number) => PersistedState | Promise<PersistedState>",
        "optional": true
      },
      {
        "name": "merge",
        "type": "(persistedState: unknown, currentState: S) => S",
        "optional": true
      },
      {
        "name": "skipHydration",
        "type": "boolean",
        "optional": true
      }
    ],
    "extends": [],
    "xaiDescription": "Configuration for persisting Zustand state, including storage and migration options.",
    "isExported": true
  }
}