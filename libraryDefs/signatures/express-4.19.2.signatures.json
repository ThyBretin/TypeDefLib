{
  "functions": [
    {
      "name": "Router",
      "parameters": [
        {
          "name": "options",
          "type": "RouterOptions",
          "optional": true
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "json",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsJson",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "raw",
      "parameters": [
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "text",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsText",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "application",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null
    },
    {
      "name": "use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "__@captureRejectionSymbol@40899",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null
    },
    {
      "name": "application.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "application.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "application.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "application.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "application.get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "application.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "application.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "application.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "application.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "application.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "application.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "application.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "application.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "application.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null
    },
    {
      "name": "application.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "application.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "application.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null
    },
    {
      "name": "application.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "application.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": null
    },
    {
      "name": "application.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string | string[]",
      "jsdoc": null
    },
    {
      "name": "application.indexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": null
    },
    {
      "name": "application.lastIndexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": null
    },
    {
      "name": "application.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string | string[]",
      "jsdoc": null
    },
    {
      "name": "application.valueOf",
      "parameters": [],
      "returnType": "string | Object",
      "jsdoc": null
    },
    {
      "name": "application.includes",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": null
    },
    {
      "name": "application.__@iterator@41049",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": null
    },
    {
      "name": "application.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": null
    },
    {
      "name": "application.toLocaleString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": null
    },
    {
      "name": "application.__@captureRejectionSymbol@40899",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "application.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.pop",
      "parameters": [],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "application.push",
      "parameters": [
        {
          "name": "items",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Appends new elements to the end of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "New elements to add to the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.join",
      "parameters": [
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
        "params": [
          {
            "name": "separator",
            "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reverse",
      "parameters": [],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "deprecated": false
      }
    },
    {
      "name": "application.shift",
      "parameters": [],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "application.sort",
      "parameters": [
        {
          "name": "compareFn",
          "type": "(a: ILayer, b: ILayer) => number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "params": [
          {
            "name": "compareFn",
            "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n```ts\n[11,2,22,1].sort((a, b) => a - b)\n```"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.splice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "deleteCount",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based location in the array from which to start removing elements."
          },
          {
            "name": "deleteCount",
            "description": "The number of elements to remove."
          }
        ],
        "returns": "An array containing the elements that were deleted.",
        "deprecated": false
      }
    },
    {
      "name": "application.unshift",
      "parameters": [
        {
          "name": "items",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "Elements to insert at the start of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.every",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether all the members of an array satisfy the specified test.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.some",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether the specified callback function returns true for any element of an array.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.forEach",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: ILayer, index: number, array: ILayer[]) => void",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Performs the specified action for each element in an array.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.map",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: ILayer, index: number, array: ILayer[]) => U",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.filter",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S[]",
      "jsdoc": {
        "description": "Returns the elements of an array that meet the condition specified in a callback function.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reduce",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
          "optional": false
        }
      ],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reduceRight",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
          "optional": false
        }
      ],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.find",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, obj: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.findIndex",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, obj: ILayer[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.fill",
      "parameters": [
        {
          "name": "value",
          "type": "ILayer",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
        "params": [
          {
            "name": "value",
            "description": "value to fill array section with"
          },
          {
            "name": "start",
            "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
          },
          {
            "name": "end",
            "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.copyWithin",
      "parameters": [
        {
          "name": "target",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
        "params": [
          {
            "name": "target",
            "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
          },
          {
            "name": "start",
            "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
          },
          {
            "name": "end",
            "description": "If not specified, length of the this object is used as its default value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.entries",
      "parameters": [],
      "returnType": "ArrayIterator<[number, ILayer]>",
      "jsdoc": {
        "description": "Returns an iterable of key, value pairs for every entry in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.keys",
      "parameters": [],
      "returnType": "ArrayIterator<number>",
      "jsdoc": {
        "description": "Returns an iterable of keys in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.values",
      "parameters": [],
      "returnType": "ArrayIterator<ILayer>",
      "jsdoc": {
        "description": "Returns an iterable of values in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.flatMap",
      "parameters": [
        {
          "name": "callback",
          "type": "(this: This, value: ILayer, index: number, array: ILayer[]) => U | readonly U[]",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "This",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
        "params": [
          {
            "name": "callback",
            "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.flat",
      "parameters": [
        {
          "name": "depth",
          "type": "D",
          "optional": true
        }
      ],
      "returnType": "FlatArray<A, D>[]",
      "jsdoc": {
        "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
        "params": [
          {
            "name": "depth",
            "description": "The maximum recursion depth"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": null
    },
    {
      "name": "accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "_read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n```\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": null
    },
    {
      "name": "iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "_destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "__@asyncIterator@41528",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": null
    },
    {
      "name": "__@asyncDispose@41530",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "compose",
      "parameters": [
        {
          "name": "stream",
          "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "request.get",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Return request header.\n\nThe `Referrer` header field is special-cased,\nboth `Referrer` and `Referer` are interchangeable.\n\nExamples:\n\n    req.get('Content-Type');\n    // => \"text/plain\"\n\n    req.get('content-type');\n    // => \"text/plain\"\n\n    req.get('Something');\n    // => undefined\n\nAliased as `req.header()`.",
        "deprecated": false
      }
    },
    {
      "name": "request.header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": null
    },
    {
      "name": "request.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "request.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of an array.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.",
        "deprecated": false
      }
    },
    {
      "name": "request.pop",
      "parameters": [],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "request.push",
      "parameters": [
        {
          "name": "items",
          "type": "MediaType[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Appends new elements to the end of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "New elements to add to the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.concat",
      "parameters": [
        {
          "name": "items",
          "type": "ConcatArray<MediaType>[]",
          "optional": false
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Combines two or more arrays.\nThis method returns a new array without modifying any existing arrays.",
        "params": [
          {
            "name": "items",
            "description": "Additional arrays and/or items to add to the end of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.join",
      "parameters": [
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
        "params": [
          {
            "name": "separator",
            "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reverse",
      "parameters": [],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "deprecated": false
      }
    },
    {
      "name": "request.shift",
      "parameters": [],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "request.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Returns a copy of a section of an array.\nFor both start and end, a negative index can be used to indicate an offset from the end of the array.\nFor example, -2 refers to the second to last element of the array.",
        "params": [
          {
            "name": "start",
            "description": "The beginning index of the specified portion of the array.\nIf start is undefined, then the slice begins at index 0."
          },
          {
            "name": "end",
            "description": "The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\nIf end is undefined, then the slice extends to the end of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.sort",
      "parameters": [
        {
          "name": "compareFn",
          "type": "(a: MediaType, b: MediaType) => number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "params": [
          {
            "name": "compareFn",
            "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n```ts\n[11,2,22,1].sort((a, b) => a - b)\n```"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.splice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "deleteCount",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based location in the array from which to start removing elements."
          },
          {
            "name": "deleteCount",
            "description": "The number of elements to remove."
          }
        ],
        "returns": "An array containing the elements that were deleted.",
        "deprecated": false
      }
    },
    {
      "name": "request.unshift",
      "parameters": [
        {
          "name": "items",
          "type": "MediaType[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "Elements to insert at the start of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.indexOf",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first occurrence of a value in an array, or -1 if it is not present.",
        "params": [
          {
            "name": "searchElement",
            "description": "The value to locate in the array."
          },
          {
            "name": "fromIndex",
            "description": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.lastIndexOf",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.",
        "params": [
          {
            "name": "searchElement",
            "description": "The value to locate in the array."
          },
          {
            "name": "fromIndex",
            "description": "The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.every",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether all the members of an array satisfy the specified test.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.some",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether the specified callback function returns true for any element of an array.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.forEach",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: MediaType, index: number, array: MediaType[]) => void",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Performs the specified action for each element in an array.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.map",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: MediaType, index: number, array: MediaType[]) => U",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.filter",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S[]",
      "jsdoc": {
        "description": "Returns the elements of an array that meet the condition specified in a callback function.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reduce",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reduceRight",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.find",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, obj: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.findIndex",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, obj: MediaType[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.fill",
      "parameters": [
        {
          "name": "value",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
        "params": [
          {
            "name": "value",
            "description": "value to fill array section with"
          },
          {
            "name": "start",
            "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
          },
          {
            "name": "end",
            "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.copyWithin",
      "parameters": [
        {
          "name": "target",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
        "params": [
          {
            "name": "target",
            "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
          },
          {
            "name": "start",
            "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
          },
          {
            "name": "end",
            "description": "If not specified, length of the this object is used as its default value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.entries",
      "parameters": [],
      "returnType": "ArrayIterator<[number, MediaType]>",
      "jsdoc": {
        "description": "Returns an iterable of key, value pairs for every entry in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.keys",
      "parameters": [],
      "returnType": "ArrayIterator<number>",
      "jsdoc": {
        "description": "Returns an iterable of keys in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.values",
      "parameters": [],
      "returnType": "ArrayIterator<MediaType>",
      "jsdoc": {
        "description": "Returns an iterable of values in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.includes",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether an array includes a certain element, returning true or false as appropriate.",
        "params": [
          {
            "name": "searchElement",
            "description": "The element to search for."
          },
          {
            "name": "fromIndex",
            "description": "The position in this array at which to begin searching for searchElement."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.flatMap",
      "parameters": [
        {
          "name": "callback",
          "type": "(this: This, value: MediaType, index: number, array: MediaType[]) => U | readonly U[]",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "This",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
        "params": [
          {
            "name": "callback",
            "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.flat",
      "parameters": [
        {
          "name": "depth",
          "type": "D",
          "optional": true
        }
      ],
      "returnType": "FlatArray<A, D>[]",
      "jsdoc": {
        "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
        "params": [
          {
            "name": "depth",
            "description": "The maximum recursion depth"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.__@iterator@41049",
      "parameters": [],
      "returnType": "ArrayIterator<MediaType>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "request.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": null
    },
    {
      "name": "request.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "request.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "request.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "request.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "request.valueOf",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false
      }
    },
    {
      "name": "request.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false
      }
    },
    {
      "name": "request.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition  length(this). Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "request.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "request.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "request.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "request.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "request.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "request.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "request.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "request.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "request.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "request.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "request.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "request.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "request.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "request.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "request.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null
    },
    {
      "name": "request.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "request.__@captureRejectionSymbol@40899",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "request.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "request.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null
    },
    {
      "name": "request.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "request.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "request.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "request.json",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "request.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "request.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "request.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "request.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "request.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false
      }
    },
    {
      "name": "request.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      }
    },
    {
      "name": "request.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      }
    },
    {
      "name": "request.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false
      }
    },
    {
      "name": "request.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false
      }
    },
    {
      "name": "request.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false
      }
    },
    {
      "name": "request.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "request.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.",
        "params": [
          {
            "name": "callback",
            "description": "Optional function to be called when a timeout occurs. Same as binding to the `timeout` event."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\n```js\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n```\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding, if `chunk` is a string."
          },
          {
            "name": "callback",
            "description": "Callback for when this chunk of data is flushed."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\n```js\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n```",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the writable\nstream has ended and subsequent calls to `write()` or `end()` will result in\nan `ERR_STREAM_DESTROYED` error.\nThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\nUse `end()` instead of destroy if data should flush before close, or wait for\nthe `'drain'` event before destroying the stream.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method,\nbut instead implement `writable._destroy()`.",
        "params": [
          {
            "name": "error",
            "description": "Optional, an error to emit with `'error'` event."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "request.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "request.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.toFixed",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representing a number in fixed-point notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toExponential",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented in exponential notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toPrecision",
      "parameters": [
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
        "params": [
          {
            "name": "precision",
            "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.destroySoon",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.pause",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Pauses the reading of data. That is, `'data'` events will not be emitted.\nUseful to throttle back an upload.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.resetAndDestroy",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.resume",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Resumes reading after a call to `socket.pause()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setNoDelay",
      "parameters": [
        {
          "name": "noDelay",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
        "params": [
          {
            "name": "noDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setKeepAlive",
      "parameters": [
        {
          "name": "enable",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "initialDelay",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
        "params": [
          {
            "name": "enable"
          },
          {
            "name": "initialDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.address",
      "parameters": [],
      "returnType": "{} | AddressInfo",
      "jsdoc": {
        "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.unref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.ref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "request.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "request.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "request.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "request.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "request.__@asyncIterator@41528",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": null
    },
    {
      "name": "request.__@asyncDispose@41530",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false
      }
    },
    {
      "name": "attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      }
    },
    {
      "name": "clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      }
    },
    {
      "name": "cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false
      }
    },
    {
      "name": "location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false
      }
    },
    {
      "name": "redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false
      }
    },
    {
      "name": "vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "_writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "_final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\n```js\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n```\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding, if `chunk` is a string."
          },
          {
            "name": "callback",
            "description": "Callback for when this chunk of data is flushed."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\n```js\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n```",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "response.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "response.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "response.json",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "response.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "response.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "response.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "response.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "response.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false
      }
    },
    {
      "name": "response.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      }
    },
    {
      "name": "response.set",
      "parameters": [
        {
          "name": "field",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set header `field` to `val`, or pass\nan object of header fields.\n\nExamples:\n\n   res.set('Foo', ['bar', 'baz']);\n   res.set('Accept', 'application/json');\n   res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n\nAliased as `res.header()`.",
        "deprecated": false
      }
    },
    {
      "name": "response.header",
      "parameters": [
        {
          "name": "field",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.valueOf",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false
      }
    },
    {
      "name": "response.get",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Get value for header `field`.",
        "deprecated": false
      }
    },
    {
      "name": "response.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      }
    },
    {
      "name": "response.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false
      }
    },
    {
      "name": "response.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false
      }
    },
    {
      "name": "response.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false
      }
    },
    {
      "name": "response.render",
      "parameters": [
        {
          "name": "view",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render `view` with the given `options` and optional callback `fn`.\nWhen a callback function is given a response will _not_ be made\nautomatically, otherwise a response of _200_ and _text/html_ is given.\n\nOptions:\n\n - `cache`     boolean hinting to the engine it should cache\n - `filename`  filename of the view being rendered",
        "deprecated": false
      }
    },
    {
      "name": "response.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string that contains the concatenation of two or more strings.",
        "params": [
          {
            "name": "strings",
            "description": "The strings to append to the end of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.indexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the position of the first occurrence of a substring.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for in the string"
          },
          {
            "name": "position",
            "description": "The index at which to begin searching the String object. If omitted, search starts at the beginning of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.lastIndexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the last occurrence of a substring in the string.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for."
          },
          {
            "name": "position",
            "description": "The index at which to begin searching. If omitted, the search begins at the end of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a section of a string.",
        "params": [
          {
            "name": "start",
            "description": "The index to the beginning of the specified portion of stringObj."
          },
          {
            "name": "end",
            "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false
      }
    },
    {
      "name": "response.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "response.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false
      }
    },
    {
      "name": "response.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "response.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "response.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false
      }
    },
    {
      "name": "response.includes",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if searchString appears as a substring of the result of converting this\nobject to a String, at one or more positions that are\ngreater than or equal to position; otherwise, returns false.",
        "params": [
          {
            "name": "searchString",
            "description": "search string"
          },
          {
            "name": "position",
            "description": "If position is undefined, 0 is assumed, so as to search all of the String."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition  length(this). Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "response.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.__@iterator@41049",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "response.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": null
    },
    {
      "name": "response.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "response.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "response.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "response.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "response.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "response.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "response.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "response.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "response.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "response.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "response.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "response.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null
    },
    {
      "name": "response.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "response.__@captureRejectionSymbol@40899",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "response.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null
    },
    {
      "name": "response.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null
    },
    {
      "name": "response.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "response.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "response.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "response.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n```\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": null
    },
    {
      "name": "response.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "response.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "response.some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "response.find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "response.every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "response.flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "response.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "response.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "response.reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "response._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.__@asyncIterator@41528",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": null
    },
    {
      "name": "response.__@asyncDispose@41530",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "response.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "response.toFixed",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representing a number in fixed-point notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toExponential",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented in exponential notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toPrecision",
      "parameters": [
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
        "params": [
          {
            "name": "precision",
            "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toLocaleString",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        },
        {
          "name": "options",
          "type": "NumberFormatOptions",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts a number to a string by using the current or specified locale.",
        "params": [
          {
            "name": "locales",
            "description": "A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used."
          },
          {
            "name": "options",
            "description": "An object that contains one or more properties that specify comparison options."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.destroySoon",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.write",
      "parameters": [
        {
          "name": "buffer",
          "type": "string | Uint8Array<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "cb",
          "type": "(err?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string. It defaults to UTF8 encoding.\n\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.\n\nThe optional `callback` parameter will be executed when the data is finally\nwritten out, which may not be immediately.\n\nSee `Writable` stream `write()` method for more\ninformation.",
        "params": [
          {
            "name": "encoding",
            "description": "Only used when data is `string`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.resetAndDestroy",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setNoDelay",
      "parameters": [
        {
          "name": "noDelay",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
        "params": [
          {
            "name": "noDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setKeepAlive",
      "parameters": [
        {
          "name": "enable",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "initialDelay",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
        "params": [
          {
            "name": "enable"
          },
          {
            "name": "initialDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.address",
      "parameters": [],
      "returnType": "{} | AddressInfo",
      "jsdoc": {
        "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.unref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.ref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.end",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n\nSee `writable.end()` for further details.",
        "params": [
          {
            "name": "encoding",
            "description": "Only used when data is `string`."
          },
          {
            "name": "callback",
            "description": "Optional callback for when the socket is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "response.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "static",
      "parameters": [
        {
          "name": "root",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
          "optional": true
        }
      ],
      "returnType": "RequestHandler<Response<any, Record<string, any>>>",
      "jsdoc": null
    },
    {
      "name": "static.lookup",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fallback",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Look up a mime type based on extension.\n\nIf not found, uses the fallback argument if provided, and otherwise\nuses `default_type`.",
        "deprecated": false
      }
    },
    {
      "name": "static.extension",
      "parameters": [
        {
          "name": "mime",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Return a file extensions associated with a mime type.",
        "deprecated": false
      }
    },
    {
      "name": "static.load",
      "parameters": [
        {
          "name": "filepath",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Load an Apache2-style \".types\" file.",
        "deprecated": false
      }
    },
    {
      "name": "static.define",
      "parameters": [
        {
          "name": "mimes",
          "type": "TypeMap",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "urlencoded",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsUrlencoded",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "e.Router",
      "parameters": [
        {
          "name": "options",
          "type": "RouterOptions",
          "optional": true
        }
      ],
      "returnType": "Router",
      "jsdoc": null
    },
    {
      "name": "e",
      "parameters": [],
      "returnType": "Express",
      "jsdoc": {
        "description": "Creates an Express application. The express() function is a top-level function exported by the express module.",
        "deprecated": false
      }
    },
    {
      "name": "e.json",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsJson",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "e.raw",
      "parameters": [
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "e.text",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsText",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    },
    {
      "name": "e.application",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "e.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "e.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "e.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "e.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "e.get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "e.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "e.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "e.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "e.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "e.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "e.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "e.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "e.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null
    },
    {
      "name": "e.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "e.__@captureRejectionSymbol@40899",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "e.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null
    },
    {
      "name": "e.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null
    },
    {
      "name": "e.header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": null
    },
    {
      "name": "e.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "e.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "e.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "e.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "e.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "e.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "e.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null
    },
    {
      "name": "e.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n```\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": null
    },
    {
      "name": "e.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "e.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "e.some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "e.find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "e.every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "e.flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "e.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "e.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "e.reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "e._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.__@asyncIterator@41528",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": null
    },
    {
      "name": "e.__@asyncDispose@41530",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "e.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": null
    },
    {
      "name": "e.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "e.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "e.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "e.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "e.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "e.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "e.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "e.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false
      }
    },
    {
      "name": "e.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      }
    },
    {
      "name": "e.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      }
    },
    {
      "name": "e.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false
      }
    },
    {
      "name": "e.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false
      }
    },
    {
      "name": "e.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false
      }
    },
    {
      "name": "e.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "e.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null
    },
    {
      "name": "e.write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\n```js\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n```\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding, if `chunk` is a string."
          },
          {
            "name": "callback",
            "description": "Callback for when this chunk of data is flushed."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\n```js\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n```",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.static",
      "parameters": [
        {
          "name": "root",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
          "optional": true
        }
      ],
      "returnType": "RequestHandler<Response<any, Record<string, any>>>",
      "jsdoc": null
    },
    {
      "name": "e.urlencoded",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsUrlencoded",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null
    }
  ],
  "enums": [],
  "types": [
    {
      "name": "RouterOptions",
      "type": "RouterOptions",
      "properties": [
        {
          "name": "caseSensitive",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "mergeParams",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "strict",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Application",
      "type": "Application",
      "properties": [
        {
          "name": "init",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "defaultConfiguration",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "engine",
          "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Application",
          "optional": false
        },
        {
          "name": "set",
          "type": "(setting: string, val: any) => Application",
          "optional": false
        },
        {
          "name": "get",
          "type": "((name: string) => any) & IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "param",
          "type": "(name: string | string[], handler: RequestParamHandler) => Application",
          "optional": false
        },
        {
          "name": "path",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "enabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "disabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "enable",
          "type": "(setting: string) => Application",
          "optional": false
        },
        {
          "name": "disable",
          "type": "(setting: string) => Application",
          "optional": false
        },
        {
          "name": "render",
          "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
          "optional": false
        },
        {
          "name": "listen",
          "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
          "optional": false
        },
        {
          "name": "router",
          "type": "Router",
          "optional": false
        },
        {
          "name": "settings",
          "type": "any",
          "optional": false
        },
        {
          "name": "resource",
          "type": "any",
          "optional": false
        },
        {
          "name": "map",
          "type": "any",
          "optional": false
        },
        {
          "name": "locals",
          "type": "Record<string, any> & Locals",
          "optional": false
        },
        {
          "name": "routes",
          "type": "any",
          "optional": false
        },
        {
          "name": "_router",
          "type": "any",
          "optional": false
        },
        {
          "name": "use",
          "type": "ApplicationRequestHandler<Application>",
          "optional": false
        },
        {
          "name": "on",
          "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Application",
          "optional": false
        },
        {
          "name": "mountpath",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@40899",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "addListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "once",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Application",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Application",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "emit",
          "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Application, \"all\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Application, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Application, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Application, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Application, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Application, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Application, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Application"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CookieOptions",
      "type": "CookieOptions",
      "properties": [
        {
          "name": "maxAge",
          "type": "number",
          "optional": true
        },
        {
          "name": "signed",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "expires",
          "type": "Date",
          "optional": true
        },
        {
          "name": "httpOnly",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "path",
          "type": "string",
          "optional": true
        },
        {
          "name": "domain",
          "type": "string",
          "optional": true
        },
        {
          "name": "secure",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "encode",
          "type": "(val: string) => string",
          "optional": true
        },
        {
          "name": "sameSite",
          "type": "boolean | \"lax\" | \"strict\" | \"none\"",
          "optional": true
        },
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\"",
          "optional": true
        },
        {
          "name": "partitioned",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [
        "core.CookieOptions"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Errback",
      "type": "Errback",
      "properties": [],
      "extends": [
        "core.Errback"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ErrorRequestHandler",
      "type": "ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [],
      "extends": [
        "core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Express",
      "type": "Express",
      "properties": [
        {
          "name": "request",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "response",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "init",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "defaultConfiguration",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "engine",
          "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Express",
          "optional": false
        },
        {
          "name": "set",
          "type": "(setting: string, val: any) => Express",
          "optional": false
        },
        {
          "name": "get",
          "type": "((name: string) => any) & IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "param",
          "type": "(name: string | string[], handler: RequestParamHandler) => Express",
          "optional": false
        },
        {
          "name": "path",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "enabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "disabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "enable",
          "type": "(setting: string) => Express",
          "optional": false
        },
        {
          "name": "disable",
          "type": "(setting: string) => Express",
          "optional": false
        },
        {
          "name": "render",
          "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
          "optional": false
        },
        {
          "name": "listen",
          "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
          "optional": false
        },
        {
          "name": "router",
          "type": "Router",
          "optional": false
        },
        {
          "name": "settings",
          "type": "any",
          "optional": false
        },
        {
          "name": "resource",
          "type": "any",
          "optional": false
        },
        {
          "name": "map",
          "type": "any",
          "optional": false
        },
        {
          "name": "locals",
          "type": "Record<string, any> & Locals",
          "optional": false
        },
        {
          "name": "routes",
          "type": "any",
          "optional": false
        },
        {
          "name": "_router",
          "type": "any",
          "optional": false
        },
        {
          "name": "use",
          "type": "ApplicationRequestHandler<Express>",
          "optional": false
        },
        {
          "name": "on",
          "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Express",
          "optional": false
        },
        {
          "name": "mountpath",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@40899",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "addListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "once",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Express",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Express",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "emit",
          "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Express, \"all\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Express, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Express, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Express, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Express, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Express, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Express, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Express"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Handler",
      "type": "Handler",
      "properties": [],
      "extends": [
        "core.Handler"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IRoute",
      "type": "IRoute",
      "properties": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "get",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false
        }
      ],
      "extends": [
        "core.IRoute"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IRouter",
      "type": "IRouter",
      "properties": [
        {
          "name": "param",
          "type": "(name: string, handler: RequestParamHandler) => IRouter",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<IRouter, \"all\">",
          "optional": false
        },
        {
          "name": "get",
          "type": "IRouterMatcher<IRouter, \"get\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<IRouter, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<IRouter, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<IRouter, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<IRouter, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<IRouter, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<IRouter, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "use",
          "type": "IRouterHandler<IRouter, string> & IRouterMatcher<IRouter, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.IRouter"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IRouterHandler",
      "type": "IRouterHandler<T>",
      "properties": [],
      "extends": [
        "core.IRouterHandler<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IRouterMatcher",
      "type": "IRouterMatcher<T>",
      "properties": [],
      "extends": [
        "core.IRouterMatcher<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MediaType",
      "type": "MediaType",
      "properties": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        },
        {
          "name": "quality",
          "type": "number",
          "optional": false
        },
        {
          "name": "type",
          "type": "string",
          "optional": false
        },
        {
          "name": "subtype",
          "type": "string",
          "optional": false
        }
      ],
      "extends": [
        "core.MediaType"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NextFunction",
      "type": "NextFunction",
      "properties": [],
      "extends": [
        "core.NextFunction"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Locals",
      "type": "Locals",
      "properties": [],
      "extends": [
        "core.Locals"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Request",
      "type": "Request<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [
        {
          "name": "get",
          "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
          "optional": false
        },
        {
          "name": "header",
          "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
          "optional": false
        },
        {
          "name": "accepts",
          "type": "{ (): string[]; (type: string): string | false; (type: string[]): string | false; (...type: string[]): string | false; }",
          "optional": false
        },
        {
          "name": "acceptsCharsets",
          "type": "{ (): string[]; (charset: string): string | false; (charset: string[]): string | false; (...charset: string[]): string | false; }",
          "optional": false
        },
        {
          "name": "acceptsEncodings",
          "type": "{ (): string[]; (encoding: string): string | false; (encoding: string[]): string | false; (...encoding: string[]): string | false; }",
          "optional": false
        },
        {
          "name": "acceptsLanguages",
          "type": "{ (): string[]; (lang: string): string | false; (lang: string[]): string | false; (...lang: string[]): string | false; }",
          "optional": false
        },
        {
          "name": "range",
          "type": "(size: number, options?: Options) => Ranges | Result",
          "optional": false
        },
        {
          "name": "accepted",
          "type": "MediaType[]",
          "optional": false
        },
        {
          "name": "is",
          "type": "(type: string | string[]) => string | false",
          "optional": false
        },
        {
          "name": "protocol",
          "type": "string",
          "optional": false
        },
        {
          "name": "secure",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "ip",
          "type": "string",
          "optional": false
        },
        {
          "name": "ips",
          "type": "string[]",
          "optional": false
        },
        {
          "name": "subdomains",
          "type": "string[]",
          "optional": false
        },
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "host",
          "type": "string",
          "optional": false
        },
        {
          "name": "fresh",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "stale",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "xhr",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "body",
          "type": "ReqBody",
          "optional": false
        },
        {
          "name": "cookies",
          "type": "any",
          "optional": false
        },
        {
          "name": "method",
          "type": "string",
          "optional": false
        },
        {
          "name": "params",
          "type": "P",
          "optional": false
        },
        {
          "name": "query",
          "type": "ReqQuery",
          "optional": false
        },
        {
          "name": "route",
          "type": "any",
          "optional": false
        },
        {
          "name": "signedCookies",
          "type": "any",
          "optional": false
        },
        {
          "name": "originalUrl",
          "type": "string",
          "optional": false
        },
        {
          "name": "url",
          "type": "string",
          "optional": false
        },
        {
          "name": "baseUrl",
          "type": "string",
          "optional": false
        },
        {
          "name": "app",
          "type": "Application<Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<ResBody, Locals, number>",
          "optional": true
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": true
        },
        {
          "name": "aborted",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "httpVersion",
          "type": "string",
          "optional": false
        },
        {
          "name": "httpVersionMajor",
          "type": "number",
          "optional": false
        },
        {
          "name": "httpVersionMinor",
          "type": "number",
          "optional": false
        },
        {
          "name": "complete",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "connection",
          "type": "Socket",
          "optional": false
        },
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        },
        {
          "name": "headers",
          "type": "IncomingHttpHeaders",
          "optional": false
        },
        {
          "name": "headersDistinct",
          "type": "Dict<string[]>",
          "optional": false
        },
        {
          "name": "rawHeaders",
          "type": "string[]",
          "optional": false
        },
        {
          "name": "trailers",
          "type": "Dict<string>",
          "optional": false
        },
        {
          "name": "trailersDistinct",
          "type": "Dict<string[]>",
          "optional": false
        },
        {
          "name": "rawTrailers",
          "type": "string[]",
          "optional": false
        },
        {
          "name": "setTimeout",
          "type": "(msecs: number, callback?: () => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "statusCode",
          "type": "number",
          "optional": true
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "destroy",
          "type": "(error?: Error) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "readableAborted",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "readable",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "readableDidRead",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "readableEncoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "readableEnded",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "readableFlowing",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "readableHighWaterMark",
          "type": "number",
          "optional": false
        },
        {
          "name": "readableLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "readableObjectMode",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "destroyed",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "closed",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "errored",
          "type": "Error",
          "optional": false
        },
        {
          "name": "_construct",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": true
        },
        {
          "name": "_read",
          "type": "(size: number) => void",
          "optional": false
        },
        {
          "name": "read",
          "type": "(size?: number) => any",
          "optional": false
        },
        {
          "name": "setEncoding",
          "type": "(encoding: BufferEncoding) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "pause",
          "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "resume",
          "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "isPaused",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "unpipe",
          "type": "(destination?: WritableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(chunk: any, encoding?: BufferEncoding) => void",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "(stream: ReadableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "push",
          "type": "(chunk: any, encoding?: BufferEncoding) => boolean",
          "optional": false
        },
        {
          "name": "iterator",
          "type": "(options?: { destroyOnReturn?: boolean; }) => AsyncIterator<any, any, any>",
          "optional": false
        },
        {
          "name": "map",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Readable",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>, options?: ArrayOptions) => Promise<void>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "(options?: Pick<ArrayOptions, \"signal\">) => Promise<any[]>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <T>(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T, options?: ArrayOptions): Promise<T>; (fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<...>, options?: ArrayOptions): Promise<...>; }",
          "optional": false
        },
        {
          "name": "every",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false
        },
        {
          "name": "take",
          "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false
        },
        {
          "name": "asIndexedPairs",
          "type": "(options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <T = any>(fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T, initial?: undefined, options?: Pick<ArrayOptions, \"signal\">): Promise<...>; <T = any>(fn: (previous: T, data: any, options?: Pick<...>) => T, initial: T, options?: Pick<...>): Promise<...>; }",
          "optional": false
        },
        {
          "name": "_destroy",
          "type": "(error: Error, callback: (error?: Error) => void) => void",
          "optional": false
        },
        {
          "name": "addListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "emit",
          "type": "{ (event: \"close\"): boolean; (event: \"data\", chunk: any): boolean; (event: \"end\"): boolean; (event: \"error\", err: Error): boolean; (event: \"pause\"): boolean; (event: \"readable\"): boolean; (event: \"resume\"): boolean; (event: string | symbol, ...args: any[]): boolean; }",
          "optional": false
        },
        {
          "name": "on",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "once",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false
        },
        {
          "name": "__@asyncIterator@41528",
          "type": "() => AsyncIterator<any, any, any>",
          "optional": false
        },
        {
          "name": "__@asyncDispose@41530",
          "type": "() => Promise<void>",
          "optional": false
        },
        {
          "name": "pipe",
          "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
          "optional": false
        },
        {
          "name": "compose",
          "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@40899",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Request<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RequestHandler",
      "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [],
      "extends": [
        "core.RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RequestParamHandler",
      "type": "RequestParamHandler",
      "properties": [],
      "extends": [
        "core.RequestParamHandler"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Response",
      "type": "Response<ResBody, Locals>",
      "properties": [
        {
          "name": "status",
          "type": "(code: number) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "sendStatus",
          "type": "(code: number) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "links",
          "type": "(links: any) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "send",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false
        },
        {
          "name": "json",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false
        },
        {
          "name": "jsonp",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false
        },
        {
          "name": "sendFile",
          "type": "{ (path: string, fn?: Errback): void; (path: string, options: SendFileOptions, fn?: Errback): void; }",
          "optional": false
        },
        {
          "name": "download",
          "type": "{ (path: string, fn?: Errback): void; (path: string, filename: string, fn?: Errback): void; (path: string, filename: string, options: DownloadOptions, fn?: Errback): void; }",
          "optional": false
        },
        {
          "name": "contentType",
          "type": "(type: string) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "type",
          "type": "(type: string) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "format",
          "type": "(obj: any) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "attachment",
          "type": "(filename?: string) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
          "optional": false
        },
        {
          "name": "header",
          "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
          "optional": false
        },
        {
          "name": "headersSent",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "get",
          "type": "(field: string) => string",
          "optional": false
        },
        {
          "name": "clearCookie",
          "type": "(name: string, options?: CookieOptions) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "cookie",
          "type": "{ (name: string, val: string, options: CookieOptions): Response<ResBody, Locals>; (name: string, val: any, options: CookieOptions): Response<...>; (name: string, val: any): Response<...>; }",
          "optional": false
        },
        {
          "name": "location",
          "type": "(url: string) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "redirect",
          "type": "{ (url: string): void; (status: number, url: string): void; }",
          "optional": false
        },
        {
          "name": "render",
          "type": "{ (view: string, options?: object, callback?: (err: Error, html: string) => void): void; (view: string, callback?: (err: Error, html: string) => void): void; }",
          "optional": false
        },
        {
          "name": "locals",
          "type": "Locals & Locals",
          "optional": false
        },
        {
          "name": "charset",
          "type": "string",
          "optional": false
        },
        {
          "name": "vary",
          "type": "(field: string) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "app",
          "type": "Application<Record<string, any>>",
          "optional": false
        },
        {
          "name": "append",
          "type": "(field: string, value?: string | string[]) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": false
        },
        {
          "name": "strictContentLength",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "assignSocket",
          "type": "(socket: Socket) => void",
          "optional": false
        },
        {
          "name": "detachSocket",
          "type": "(socket: Socket) => void",
          "optional": false
        },
        {
          "name": "writeContinue",
          "type": "(callback?: () => void) => void",
          "optional": false
        },
        {
          "name": "writeEarlyHints",
          "type": "(hints: Record<string, string | string[]>, callback?: () => void) => void",
          "optional": false
        },
        {
          "name": "writeHead",
          "type": "{ (statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<ResBody, Locals>; (statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<...>; }",
          "optional": false
        },
        {
          "name": "writeProcessing",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "chunkedEncoding",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "shouldKeepAlive",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "useChunkedEncodingByDefault",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "sendDate",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "finished",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "connection",
          "type": "Socket",
          "optional": false
        },
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        },
        {
          "name": "setTimeout",
          "type": "(msecs: number, callback?: () => void) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "setHeader",
          "type": "(name: string, value: string | number | readonly string[]) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "setHeaders",
          "type": "(headers: Headers | Map<string, string | number | readonly string[]>) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "appendHeader",
          "type": "(name: string, value: string | readonly string[]) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "getHeader",
          "type": "(name: string) => string | number | string[]",
          "optional": false
        },
        {
          "name": "getHeaders",
          "type": "() => OutgoingHttpHeaders",
          "optional": false
        },
        {
          "name": "getHeaderNames",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "hasHeader",
          "type": "(name: string) => boolean",
          "optional": false
        },
        {
          "name": "removeHeader",
          "type": "(name: string) => void",
          "optional": false
        },
        {
          "name": "addTrailers",
          "type": "(headers: OutgoingHttpHeaders | readonly [string, string][]) => void",
          "optional": false
        },
        {
          "name": "flushHeaders",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "writable",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "writableEnded",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "writableFinished",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "writableHighWaterMark",
          "type": "number",
          "optional": false
        },
        {
          "name": "writableLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "writableObjectMode",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "writableCorked",
          "type": "number",
          "optional": false
        },
        {
          "name": "destroyed",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "closed",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "errored",
          "type": "Error",
          "optional": false
        },
        {
          "name": "writableNeedDrain",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "_write",
          "type": "(chunk: any, encoding: BufferEncoding, callback: (error?: Error) => void) => void",
          "optional": false
        },
        {
          "name": "_writev",
          "type": "(chunks: { chunk: any; encoding: BufferEncoding; }[], callback: (error?: Error) => void) => void",
          "optional": true
        },
        {
          "name": "_construct",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": true
        },
        {
          "name": "_destroy",
          "type": "(error: Error, callback: (error?: Error) => void) => void",
          "optional": false
        },
        {
          "name": "_final",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": false
        },
        {
          "name": "write",
          "type": "{ (chunk: any, callback?: (error: Error) => void): boolean; (chunk: any, encoding: BufferEncoding, callback?: (error: Error) => void): boolean; }",
          "optional": false
        },
        {
          "name": "setDefaultEncoding",
          "type": "(encoding: BufferEncoding) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "end",
          "type": "{ (cb?: () => void): Response<ResBody, Locals>; (chunk: any, cb?: () => void): Response<ResBody, Locals>; (chunk: any, encoding: BufferEncoding, cb?: () => void): Response<...>; }",
          "optional": false
        },
        {
          "name": "cork",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "uncork",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "destroy",
          "type": "(error?: Error) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "addListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "emit",
          "type": "{ (event: \"close\"): boolean; (event: \"drain\"): boolean; (event: \"error\", err: Error): boolean; (event: \"finish\"): boolean; (event: \"pipe\", src: Readable): boolean; (event: \"unpipe\", src: Readable): boolean; (event: string | symbol, ...args: any[]): boolean; }",
          "optional": false
        },
        {
          "name": "on",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "once",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false
        },
        {
          "name": "pipe",
          "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
          "optional": false
        },
        {
          "name": "compose",
          "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@40899",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Response<ResBody, Locals>",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Response<ResBody, Locals>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Router",
      "type": "Router",
      "properties": [
        {
          "name": "param",
          "type": "(name: string, handler: RequestParamHandler) => Router",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Router, \"all\">",
          "optional": false
        },
        {
          "name": "get",
          "type": "IRouterMatcher<Router, \"get\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Router, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Router, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Router, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Router, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Router, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Router, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "use",
          "type": "IRouterHandler<Router, string> & IRouterMatcher<Router, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Router"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Send",
      "type": "Send",
      "properties": [],
      "extends": [
        "core.Send"
      ],
      "jsdoc": null,
      "isExported": false
    }
  ],
  "classes": [],
  "constants": [
    {
      "name": "json",
      "type": "(options?: OptionsJson) => NextHandleFunction",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "raw",
      "type": "(options?: Options) => NextHandleFunction",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "text",
      "type": "(options?: OptionsText) => NextHandleFunction",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "application",
      "type": "Application",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "request",
      "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "response",
      "type": "Response<any, Record<string, any>>",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "static",
      "type": "RequestHandlerConstructor<Response<any, Record<string, any>>>",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "urlencoded",
      "type": "(options?: OptionsUrlencoded) => NextHandleFunction",
      "jsdoc": null,
      "isExported": false
    }
  ],
  "namespaces": [
    {
      "name": "express",
      "contents": {
        "functions": [
          {
            "name": "Router",
            "parameters": [
              {
                "name": "options",
                "type": "RouterOptions",
                "optional": true
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "json",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsJson",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null
          },
          {
            "name": "raw",
            "parameters": [
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null
          },
          {
            "name": "text",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsText",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null
          },
          {
            "name": "application",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "get",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null
          },
          {
            "name": "use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "__@captureRejectionSymbol@40899",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "link",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null
          },
          {
            "name": "application.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "application.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "application.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "application.set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "application.get",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "application.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null
          },
          {
            "name": "application.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "application.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "application.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "application.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "application.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "application.render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "application.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "application.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null
          },
          {
            "name": "application.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "application.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.link",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          },
          {
            "name": "application.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null
          },
          {
            "name": "application.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "application.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": null
          },
          {
            "name": "application.concat",
            "parameters": [
              {
                "name": "strings",
                "type": "string[]",
                "optional": false
              }
            ],
            "returnType": "string | string[]",
            "jsdoc": null
          },
          {
            "name": "application.indexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": null
          },
          {
            "name": "application.lastIndexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": null
          },
          {
            "name": "application.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string | string[]",
            "jsdoc": null
          },
          {
            "name": "application.valueOf",
            "parameters": [],
            "returnType": "string | Object",
            "jsdoc": null
          },
          {
            "name": "application.includes",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": null
          },
          {
            "name": "application.__@iterator@41049",
            "parameters": [],
            "returnType": "StringIterator<string>",
            "jsdoc": null
          },
          {
            "name": "application.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": null
          },
          {
            "name": "application.toLocaleString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": null
          },
          {
            "name": "application.__@captureRejectionSymbol@40899",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "application.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.pop",
            "parameters": [],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "application.push",
            "parameters": [
              {
                "name": "items",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Appends new elements to the end of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "New elements to add to the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.join",
            "parameters": [
              {
                "name": "separator",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reverse",
            "parameters": [],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "deprecated": false
            }
          },
          {
            "name": "application.shift",
            "parameters": [],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "application.sort",
            "parameters": [
              {
                "name": "compareFn",
                "type": "(a: ILayer, b: ILayer) => number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "params": [
                {
                  "name": "compareFn",
                  "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n```ts\n[11,2,22,1].sort((a, b) => a - b)\n```"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.splice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "deleteCount",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based location in the array from which to start removing elements."
                },
                {
                  "name": "deleteCount",
                  "description": "The number of elements to remove."
                }
              ],
              "returns": "An array containing the elements that were deleted.",
              "deprecated": false
            }
          },
          {
            "name": "application.unshift",
            "parameters": [
              {
                "name": "items",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "Elements to insert at the start of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.every",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether all the members of an array satisfy the specified test.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.some",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether the specified callback function returns true for any element of an array.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.forEach",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: ILayer, index: number, array: ILayer[]) => void",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Performs the specified action for each element in an array.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.map",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: ILayer, index: number, array: ILayer[]) => U",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.filter",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S[]",
            "jsdoc": {
              "description": "Returns the elements of an array that meet the condition specified in a callback function.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reduce",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
                "optional": false
              }
            ],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reduceRight",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
                "optional": false
              }
            ],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.find",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, obj: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S",
            "jsdoc": {
              "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.findIndex",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, obj: ILayer[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.fill",
            "parameters": [
              {
                "name": "value",
                "type": "ILayer",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
              "params": [
                {
                  "name": "value",
                  "description": "value to fill array section with"
                },
                {
                  "name": "start",
                  "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
                },
                {
                  "name": "end",
                  "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.copyWithin",
            "parameters": [
              {
                "name": "target",
                "type": "number",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
              "params": [
                {
                  "name": "target",
                  "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
                },
                {
                  "name": "start",
                  "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
                },
                {
                  "name": "end",
                  "description": "If not specified, length of the this object is used as its default value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.entries",
            "parameters": [],
            "returnType": "ArrayIterator<[number, ILayer]>",
            "jsdoc": {
              "description": "Returns an iterable of key, value pairs for every entry in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.keys",
            "parameters": [],
            "returnType": "ArrayIterator<number>",
            "jsdoc": {
              "description": "Returns an iterable of keys in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.values",
            "parameters": [],
            "returnType": "ArrayIterator<ILayer>",
            "jsdoc": {
              "description": "Returns an iterable of values in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.flatMap",
            "parameters": [
              {
                "name": "callback",
                "type": "(this: This, value: ILayer, index: number, array: ILayer[]) => U | readonly U[]",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "This",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
              "params": [
                {
                  "name": "callback",
                  "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.flat",
            "parameters": [
              {
                "name": "depth",
                "type": "D",
                "optional": true
              }
            ],
            "returnType": "FlatArray<A, D>[]",
            "jsdoc": {
              "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
              "params": [
                {
                  "name": "depth",
                  "description": "The maximum recursion depth"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "header",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": null
          },
          {
            "name": "accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
              "deprecated": false
            }
          },
          {
            "name": "acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
              "deprecated": false
            }
          },
          {
            "name": "app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "_construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "_read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
              "params": [
                {
                  "name": "encoding",
                  "description": "The encoding to use."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "pause",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "resume",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "unshift",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n```\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
                },
                {
                  "name": "encoding",
                  "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "push",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": null
          },
          {
            "name": "iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "map",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. Async or not."
                }
              ],
              "returns": "a stream mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "filter",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to filter chunks from the stream. Async or not."
                }
              ],
              "returns": "a stream filtered with the predicate *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "forEach",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise for when the stream has finished.",
              "deprecated": false
            }
          },
          {
            "name": "toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false
            }
          },
          {
            "name": "some",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "find",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
              "deprecated": false
            }
          },
          {
            "name": "every",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "flatMap",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
                }
              ],
              "returns": "a stream flat-mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false
            }
          },
          {
            "name": "take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false
            }
          },
          {
            "name": "asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false
            }
          },
          {
            "name": "reduce",
            "parameters": [
              {
                "name": "fn",
                "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
                "optional": false
              },
              {
                "name": "initial",
                "type": "undefined",
                "optional": true
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
              "params": [
                {
                  "name": "fn",
                  "description": "a reducer function to call over every chunk in the stream. Async or not."
                },
                {
                  "name": "initial",
                  "description": "the initial value to use in the reduction."
                }
              ],
              "returns": "a promise for the final value of the reduction.",
              "deprecated": false
            }
          },
          {
            "name": "_destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "__@asyncIterator@41528",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": null
          },
          {
            "name": "__@asyncDispose@41530",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "compose",
            "parameters": [
              {
                "name": "stream",
                "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "request.get",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Return request header.\n\nThe `Referrer` header field is special-cased,\nboth `Referrer` and `Referer` are interchangeable.\n\nExamples:\n\n    req.get('Content-Type');\n    // => \"text/plain\"\n\n    req.get('content-type');\n    // => \"text/plain\"\n\n    req.get('Something');\n    // => undefined\n\nAliased as `req.header()`.",
              "deprecated": false
            }
          },
          {
            "name": "request.header",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": null
          },
          {
            "name": "request.accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "request.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of an array.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.",
              "deprecated": false
            }
          },
          {
            "name": "request.pop",
            "parameters": [],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "request.push",
            "parameters": [
              {
                "name": "items",
                "type": "MediaType[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Appends new elements to the end of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "New elements to add to the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.concat",
            "parameters": [
              {
                "name": "items",
                "type": "ConcatArray<MediaType>[]",
                "optional": false
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Combines two or more arrays.\nThis method returns a new array without modifying any existing arrays.",
              "params": [
                {
                  "name": "items",
                  "description": "Additional arrays and/or items to add to the end of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.join",
            "parameters": [
              {
                "name": "separator",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reverse",
            "parameters": [],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "deprecated": false
            }
          },
          {
            "name": "request.shift",
            "parameters": [],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "request.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Returns a copy of a section of an array.\nFor both start and end, a negative index can be used to indicate an offset from the end of the array.\nFor example, -2 refers to the second to last element of the array.",
              "params": [
                {
                  "name": "start",
                  "description": "The beginning index of the specified portion of the array.\nIf start is undefined, then the slice begins at index 0."
                },
                {
                  "name": "end",
                  "description": "The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\nIf end is undefined, then the slice extends to the end of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.sort",
            "parameters": [
              {
                "name": "compareFn",
                "type": "(a: MediaType, b: MediaType) => number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "params": [
                {
                  "name": "compareFn",
                  "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\n```ts\n[11,2,22,1].sort((a, b) => a - b)\n```"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.splice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "deleteCount",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based location in the array from which to start removing elements."
                },
                {
                  "name": "deleteCount",
                  "description": "The number of elements to remove."
                }
              ],
              "returns": "An array containing the elements that were deleted.",
              "deprecated": false
            }
          },
          {
            "name": "request.unshift",
            "parameters": [
              {
                "name": "items",
                "type": "MediaType[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "Elements to insert at the start of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.indexOf",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first occurrence of a value in an array, or -1 if it is not present.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The value to locate in the array."
                },
                {
                  "name": "fromIndex",
                  "description": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.lastIndexOf",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The value to locate in the array."
                },
                {
                  "name": "fromIndex",
                  "description": "The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.every",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether all the members of an array satisfy the specified test.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.some",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether the specified callback function returns true for any element of an array.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.forEach",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: MediaType, index: number, array: MediaType[]) => void",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Performs the specified action for each element in an array.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.map",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: MediaType, index: number, array: MediaType[]) => U",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.filter",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S[]",
            "jsdoc": {
              "description": "Returns the elements of an array that meet the condition specified in a callback function.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reduce",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reduceRight",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.find",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, obj: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S",
            "jsdoc": {
              "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.findIndex",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, obj: MediaType[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.fill",
            "parameters": [
              {
                "name": "value",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
              "params": [
                {
                  "name": "value",
                  "description": "value to fill array section with"
                },
                {
                  "name": "start",
                  "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
                },
                {
                  "name": "end",
                  "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.copyWithin",
            "parameters": [
              {
                "name": "target",
                "type": "number",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
              "params": [
                {
                  "name": "target",
                  "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
                },
                {
                  "name": "start",
                  "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
                },
                {
                  "name": "end",
                  "description": "If not specified, length of the this object is used as its default value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.entries",
            "parameters": [],
            "returnType": "ArrayIterator<[number, MediaType]>",
            "jsdoc": {
              "description": "Returns an iterable of key, value pairs for every entry in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.keys",
            "parameters": [],
            "returnType": "ArrayIterator<number>",
            "jsdoc": {
              "description": "Returns an iterable of keys in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.values",
            "parameters": [],
            "returnType": "ArrayIterator<MediaType>",
            "jsdoc": {
              "description": "Returns an iterable of values in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.includes",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether an array includes a certain element, returning true or false as appropriate.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The element to search for."
                },
                {
                  "name": "fromIndex",
                  "description": "The position in this array at which to begin searching for searchElement."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.flatMap",
            "parameters": [
              {
                "name": "callback",
                "type": "(this: This, value: MediaType, index: number, array: MediaType[]) => U | readonly U[]",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "This",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
              "params": [
                {
                  "name": "callback",
                  "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.flat",
            "parameters": [
              {
                "name": "depth",
                "type": "D",
                "optional": true
              }
            ],
            "returnType": "FlatArray<A, D>[]",
            "jsdoc": {
              "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
              "params": [
                {
                  "name": "depth",
                  "description": "The maximum recursion depth"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.__@iterator@41049",
            "parameters": [],
            "returnType": "ArrayIterator<MediaType>",
            "jsdoc": {
              "description": "Iterator",
              "deprecated": false
            }
          },
          {
            "name": "request.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": null
          },
          {
            "name": "request.is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
              "deprecated": false
            }
          },
          {
            "name": "request.charAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the character at the specified index.",
              "params": [
                {
                  "name": "pos",
                  "description": "The zero-based index of the desired character."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.charCodeAt",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the Unicode value of the character at the specified location.",
              "params": [
                {
                  "name": "index",
                  "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.localeCompare",
            "parameters": [
              {
                "name": "that",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Determines whether two strings are equivalent in the current locale.",
              "params": [
                {
                  "name": "that",
                  "description": "String to compare to target string"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.match",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpMatchArray",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.replace",
            "parameters": [
              {
                "name": "searchValue",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "replaceValue",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Replaces text in a string, using a regular expression or search string.",
              "params": [
                {
                  "name": "searchValue",
                  "description": "A string or regular expression to search for."
                },
                {
                  "name": "replaceValue",
                  "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.search",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Finds the first substring match in a regular expression search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "The regular expression pattern and applicable flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.split",
            "parameters": [
              {
                "name": "separator",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "limit",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Split a string into substrings using the specified separator and return them as an array.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
                },
                {
                  "name": "limit",
                  "description": "A value used to limit the number of elements returned in the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.substring",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the substring at the specified location within a String object.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based index number indicating the beginning of the substring."
                },
                {
                  "name": "end",
                  "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.toLowerCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to lowercase.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleLowerCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "request.toUpperCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to uppercase.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleUpperCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "request.trim",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading and trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.substr",
            "parameters": [
              {
                "name": "from",
                "type": "number",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Gets a substring beginning at the specified location and having the specified length.",
              "params": [
                {
                  "name": "from",
                  "description": "The starting position of the desired substring. The index of the first character in the string is zero."
                },
                {
                  "name": "length",
                  "description": "The number of characters to include in the returned substring."
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "request.valueOf",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the primitive value of the specified object.",
              "deprecated": false
            }
          },
          {
            "name": "request.codePointAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
              "deprecated": false
            }
          },
          {
            "name": "request.endsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "endPosition",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition  length(this). Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "request.normalize",
            "parameters": [
              {
                "name": "form",
                "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
              "params": [
                {
                  "name": "form",
                  "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.repeat",
            "parameters": [
              {
                "name": "count",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
              "params": [
                {
                  "name": "count",
                  "description": "number of copies to append"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.startsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "request.anchor",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
              "params": [
                {
                  "name": "name"
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "request.big",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<big>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.blink",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<blink>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.bold",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<b>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fixed",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<tt>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fontcolor",
            "parameters": [
              {
                "name": "color",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the color attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fontsize",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the size attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.italics",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<i>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.link",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML element and sets the href attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.small",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<small>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.strike",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<strike>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.sub",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sub>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.sup",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sup>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.padStart",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.padEnd",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.trimEnd",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.trimStart",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.trimLeft",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.trimRight",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.matchAll",
            "parameters": [
              {
                "name": "regexp",
                "type": "RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpStringIterator<RegExpExecArray>",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "request.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "request.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "request.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "request.set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "request.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "request.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "request.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "request.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "request.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "request.render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "request.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "request.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null
          },
          {
            "name": "request.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "request.__@captureRejectionSymbol@40899",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "request.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "request.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null
          },
          {
            "name": "request.status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false
            }
          },
          {
            "name": "request.sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false
            }
          },
          {
            "name": "request.send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false
            }
          },
          {
            "name": "request.json",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
              "deprecated": false
            }
          },
          {
            "name": "request.jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false
            }
          },
          {
            "name": "request.sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false
            }
          },
          {
            "name": "request.contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "request.type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "request.format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false
            }
          },
          {
            "name": "request.attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false
            }
          },
          {
            "name": "request.clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false
            }
          },
          {
            "name": "request.cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false
            }
          },
          {
            "name": "request.location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false
            }
          },
          {
            "name": "request.redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false
            }
          },
          {
            "name": "request.vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false
            }
          },
          {
            "name": "request.append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.",
              "params": [
                {
                  "name": "callback",
                  "description": "Optional function to be called when a timeout occurs. Same as binding to the `timeout` event."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request._write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request._writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request._construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request._destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request._final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\n```js\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n```\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding, if `chunk` is a string."
                },
                {
                  "name": "callback",
                  "description": "Callback for when this chunk of data is flushed."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.end",
            "parameters": [
              {
                "name": "cb",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\n```js\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n```",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding if `chunk` is a string"
                },
                {
                  "name": "callback",
                  "description": "Callback for when the stream is finished."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the writable\nstream has ended and subsequent calls to `write()` or `end()` will result in\nan `ERR_STREAM_DESTROYED` error.\nThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\nUse `end()` instead of destroy if data should flush before close, or wait for\nthe `'drain'` event before destroying the stream.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method,\nbut instead implement `writable._destroy()`.",
              "params": [
                {
                  "name": "error",
                  "description": "Optional, an error to emit with `'error'` event."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "request.compose",
            "parameters": [
              {
                "name": "stream",
                "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "request.next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.toFixed",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representing a number in fixed-point notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.toExponential",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented in exponential notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.toPrecision",
            "parameters": [
              {
                "name": "precision",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
              "params": [
                {
                  "name": "precision",
                  "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.destroySoon",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.pause",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Pauses the reading of data. That is, `'data'` events will not be emitted.\nUseful to throttle back an upload.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.resetAndDestroy",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.resume",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Resumes reading after a call to `socket.pause()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.setNoDelay",
            "parameters": [
              {
                "name": "noDelay",
                "type": "boolean",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
              "params": [
                {
                  "name": "noDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.setKeepAlive",
            "parameters": [
              {
                "name": "enable",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "initialDelay",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
              "params": [
                {
                  "name": "enable"
                },
                {
                  "name": "initialDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.address",
            "parameters": [],
            "returnType": "{} | AddressInfo",
            "jsdoc": {
              "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.unref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.ref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request._read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "request.read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false
            }
          },
          {
            "name": "request.drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false
            }
          },
          {
            "name": "request.take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false
            }
          },
          {
            "name": "request.asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false
            }
          },
          {
            "name": "request.__@asyncIterator@41528",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": null
          },
          {
            "name": "request.__@asyncDispose@41530",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false
            }
          },
          {
            "name": "sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false
            }
          },
          {
            "name": "send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false
            }
          },
          {
            "name": "jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false
            }
          },
          {
            "name": "sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false
            }
          },
          {
            "name": "contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false
            }
          },
          {
            "name": "attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false
            }
          },
          {
            "name": "clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false
            }
          },
          {
            "name": "cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false
            }
          },
          {
            "name": "location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false
            }
          },
          {
            "name": "redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false
            }
          },
          {
            "name": "vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false
            }
          },
          {
            "name": "append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "_write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "_writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "_final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\n```js\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n```\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding, if `chunk` is a string."
                },
                {
                  "name": "callback",
                  "description": "Callback for when this chunk of data is flushed."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "end",
            "parameters": [
              {
                "name": "cb",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\n```js\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n```",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding if `chunk` is a string"
                },
                {
                  "name": "callback",
                  "description": "Callback for when the stream is finished."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false
            }
          },
          {
            "name": "response.sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false
            }
          },
          {
            "name": "response.send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false
            }
          },
          {
            "name": "response.json",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
              "deprecated": false
            }
          },
          {
            "name": "response.jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false
            }
          },
          {
            "name": "response.sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false
            }
          },
          {
            "name": "response.contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "response.type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            }
          },
          {
            "name": "response.format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false
            }
          },
          {
            "name": "response.attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false
            }
          },
          {
            "name": "response.set",
            "parameters": [
              {
                "name": "field",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set header `field` to `val`, or pass\nan object of header fields.\n\nExamples:\n\n   res.set('Foo', ['bar', 'baz']);\n   res.set('Accept', 'application/json');\n   res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n\nAliased as `res.header()`.",
              "deprecated": false
            }
          },
          {
            "name": "response.header",
            "parameters": [
              {
                "name": "field",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.valueOf",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns the primitive value of the specified object.",
              "deprecated": false
            }
          },
          {
            "name": "response.get",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Get value for header `field`.",
              "deprecated": false
            }
          },
          {
            "name": "response.clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false
            }
          },
          {
            "name": "response.cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false
            }
          },
          {
            "name": "response.location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false
            }
          },
          {
            "name": "response.redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false
            }
          },
          {
            "name": "response.render",
            "parameters": [
              {
                "name": "view",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render `view` with the given `options` and optional callback `fn`.\nWhen a callback function is given a response will _not_ be made\nautomatically, otherwise a response of _200_ and _text/html_ is given.\n\nOptions:\n\n - `cache`     boolean hinting to the engine it should cache\n - `filename`  filename of the view being rendered",
              "deprecated": false
            }
          },
          {
            "name": "response.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.charAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the character at the specified index.",
              "params": [
                {
                  "name": "pos",
                  "description": "The zero-based index of the desired character."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.charCodeAt",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the Unicode value of the character at the specified location.",
              "params": [
                {
                  "name": "index",
                  "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.concat",
            "parameters": [
              {
                "name": "strings",
                "type": "string[]",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string that contains the concatenation of two or more strings.",
              "params": [
                {
                  "name": "strings",
                  "description": "The strings to append to the end of the string."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.indexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the position of the first occurrence of a substring.",
              "params": [
                {
                  "name": "searchString",
                  "description": "The substring to search for in the string"
                },
                {
                  "name": "position",
                  "description": "The index at which to begin searching the String object. If omitted, search starts at the beginning of the string."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.lastIndexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the last occurrence of a substring in the string.",
              "params": [
                {
                  "name": "searchString",
                  "description": "The substring to search for."
                },
                {
                  "name": "position",
                  "description": "The index at which to begin searching. If omitted, the search begins at the end of the string."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.localeCompare",
            "parameters": [
              {
                "name": "that",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Determines whether two strings are equivalent in the current locale.",
              "params": [
                {
                  "name": "that",
                  "description": "String to compare to target string"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.match",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpMatchArray",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.replace",
            "parameters": [
              {
                "name": "searchValue",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "replaceValue",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Replaces text in a string, using a regular expression or search string.",
              "params": [
                {
                  "name": "searchValue",
                  "description": "A string or regular expression to search for."
                },
                {
                  "name": "replaceValue",
                  "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.search",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Finds the first substring match in a regular expression search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "The regular expression pattern and applicable flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a section of a string.",
              "params": [
                {
                  "name": "start",
                  "description": "The index to the beginning of the specified portion of stringObj."
                },
                {
                  "name": "end",
                  "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.split",
            "parameters": [
              {
                "name": "separator",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "limit",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Split a string into substrings using the specified separator and return them as an array.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
                },
                {
                  "name": "limit",
                  "description": "A value used to limit the number of elements returned in the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.substring",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the substring at the specified location within a String object.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based index number indicating the beginning of the substring."
                },
                {
                  "name": "end",
                  "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.toLowerCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to lowercase.",
              "deprecated": false
            }
          },
          {
            "name": "response.toLocaleLowerCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "response.toUpperCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to uppercase.",
              "deprecated": false
            }
          },
          {
            "name": "response.toLocaleUpperCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "response.trim",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading and trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.substr",
            "parameters": [
              {
                "name": "from",
                "type": "number",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Gets a substring beginning at the specified location and having the specified length.",
              "params": [
                {
                  "name": "from",
                  "description": "The starting position of the desired substring. The index of the first character in the string is zero."
                },
                {
                  "name": "length",
                  "description": "The number of characters to include in the returned substring."
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "response.codePointAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
              "deprecated": false
            }
          },
          {
            "name": "response.includes",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if searchString appears as a substring of the result of converting this\nobject to a String, at one or more positions that are\ngreater than or equal to position; otherwise, returns false.",
              "params": [
                {
                  "name": "searchString",
                  "description": "search string"
                },
                {
                  "name": "position",
                  "description": "If position is undefined, 0 is assumed, so as to search all of the String."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.endsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "endPosition",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition  length(this). Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "response.normalize",
            "parameters": [
              {
                "name": "form",
                "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
              "params": [
                {
                  "name": "form",
                  "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.repeat",
            "parameters": [
              {
                "name": "count",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
              "params": [
                {
                  "name": "count",
                  "description": "number of copies to append"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.startsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "response.anchor",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
              "params": [
                {
                  "name": "name"
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "response.big",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<big>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.blink",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<blink>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.bold",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<b>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fixed",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<tt>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fontcolor",
            "parameters": [
              {
                "name": "color",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the color attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fontsize",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the size attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.italics",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<i>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.link",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML element and sets the href attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.small",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<small>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.strike",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<strike>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.sub",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sub>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.sup",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sup>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.padStart",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.padEnd",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.trimEnd",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.trimStart",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.trimLeft",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.trimRight",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.matchAll",
            "parameters": [
              {
                "name": "regexp",
                "type": "RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpStringIterator<RegExpExecArray>",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.__@iterator@41049",
            "parameters": [],
            "returnType": "StringIterator<string>",
            "jsdoc": {
              "description": "Iterator",
              "deprecated": false
            }
          },
          {
            "name": "response.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": null
          },
          {
            "name": "response.vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false
            }
          },
          {
            "name": "response.app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null
          },
          {
            "name": "response.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "response.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "response.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "response.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "response.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "response.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "response.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "response.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "response.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "response.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null
          },
          {
            "name": "response.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "response.__@captureRejectionSymbol@40899",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "response.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null
          },
          {
            "name": "response.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null
          },
          {
            "name": "response.append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "response.is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
              "deprecated": false
            }
          },
          {
            "name": "response.next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response._construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response._read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```",
              "params": [
                {
                  "name": "encoding",
                  "description": "The encoding to use."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.pause",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.resume",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.unshift",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n```\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
                },
                {
                  "name": "encoding",
                  "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.push",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": null
          },
          {
            "name": "response.iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.map",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. Async or not."
                }
              ],
              "returns": "a stream mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "response.filter",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to filter chunks from the stream. Async or not."
                }
              ],
              "returns": "a stream filtered with the predicate *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "response.forEach",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise for when the stream has finished.",
              "deprecated": false
            }
          },
          {
            "name": "response.toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false
            }
          },
          {
            "name": "response.some",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "response.find",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
              "deprecated": false
            }
          },
          {
            "name": "response.every",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "response.flatMap",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
                }
              ],
              "returns": "a stream flat-mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "response.drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false
            }
          },
          {
            "name": "response.take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false
            }
          },
          {
            "name": "response.asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false
            }
          },
          {
            "name": "response.reduce",
            "parameters": [
              {
                "name": "fn",
                "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
                "optional": false
              },
              {
                "name": "initial",
                "type": "undefined",
                "optional": true
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
              "params": [
                {
                  "name": "fn",
                  "description": "a reducer function to call over every chunk in the stream. Async or not."
                },
                {
                  "name": "initial",
                  "description": "the initial value to use in the reduction."
                }
              ],
              "returns": "a promise for the final value of the reduction.",
              "deprecated": false
            }
          },
          {
            "name": "response._destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.__@asyncIterator@41528",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": null
          },
          {
            "name": "response.__@asyncDispose@41530",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "response.compose",
            "parameters": [
              {
                "name": "stream",
                "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": null
          },
          {
            "name": "response.toFixed",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representing a number in fixed-point notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.toExponential",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented in exponential notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.toPrecision",
            "parameters": [
              {
                "name": "precision",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
              "params": [
                {
                  "name": "precision",
                  "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.toLocaleString",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              },
              {
                "name": "options",
                "type": "NumberFormatOptions",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts a number to a string by using the current or specified locale.",
              "params": [
                {
                  "name": "locales",
                  "description": "A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used."
                },
                {
                  "name": "options",
                  "description": "An object that contains one or more properties that specify comparison options."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\n```js\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n```",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\n```js\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n```\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.destroySoon",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.write",
            "parameters": [
              {
                "name": "buffer",
                "type": "string | Uint8Array<ArrayBufferLike>",
                "optional": false
              },
              {
                "name": "cb",
                "type": "(err?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string. It defaults to UTF8 encoding.\n\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.\n\nThe optional `callback` parameter will be executed when the data is finally\nwritten out, which may not be immediately.\n\nSee `Writable` stream `write()` method for more\ninformation.",
              "params": [
                {
                  "name": "encoding",
                  "description": "Only used when data is `string`."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.resetAndDestroy",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setNoDelay",
            "parameters": [
              {
                "name": "noDelay",
                "type": "boolean",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
              "params": [
                {
                  "name": "noDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setKeepAlive",
            "parameters": [
              {
                "name": "enable",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "initialDelay",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
              "params": [
                {
                  "name": "enable"
                },
                {
                  "name": "initialDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.address",
            "parameters": [],
            "returnType": "{} | AddressInfo",
            "jsdoc": {
              "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.unref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.ref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.end",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n\nSee `writable.end()` for further details.",
              "params": [
                {
                  "name": "encoding",
                  "description": "Only used when data is `string`."
                },
                {
                  "name": "callback",
                  "description": "Optional callback for when the socket is finished."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response._write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response._writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response._final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "response.setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n```\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\n```js\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n```\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\n```js\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n```\n\nor\n\n```js\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n```\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\n```js\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\n```js\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\n```js\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n```",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\n```js\noutgoingMessage.removeHeader('Content-Encoding');\n```",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\n```js\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n```\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "static",
            "parameters": [
              {
                "name": "root",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
                "optional": true
              }
            ],
            "returnType": "RequestHandler<Response<any, Record<string, any>>>",
            "jsdoc": null
          },
          {
            "name": "static.lookup",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fallback",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Look up a mime type based on extension.\n\nIf not found, uses the fallback argument if provided, and otherwise\nuses `default_type`.",
              "deprecated": false
            }
          },
          {
            "name": "static.extension",
            "parameters": [
              {
                "name": "mime",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Return a file extensions associated with a mime type.",
              "deprecated": false
            }
          },
          {
            "name": "static.load",
            "parameters": [
              {
                "name": "filepath",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Load an Apache2-style \".types\" file.",
              "deprecated": false
            }
          },
          {
            "name": "static.define",
            "parameters": [
              {
                "name": "mimes",
                "type": "TypeMap",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null
          },
          {
            "name": "urlencoded",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsUrlencoded",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null
          }
        ],
        "enums": [],
        "types": [],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": true
    },
    {
      "name": "e",
      "contents": {
        "functions": [
          {
            "name": "e.Router",
            "parameters": [
              {
                "name": "options",
                "type": "RouterOptions",
                "optional": true
              }
            ],
            "returnType": "Router",
            "jsdoc": null
          }
        ],
        "enums": [],
        "types": [
          {
            "name": "RouterOptions",
            "type": "RouterOptions",
            "properties": [
              {
                "name": "caseSensitive",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "mergeParams",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "strict",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Application",
            "type": "Application",
            "properties": [
              {
                "name": "init",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "defaultConfiguration",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "engine",
                "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Application",
                "optional": false
              },
              {
                "name": "set",
                "type": "(setting: string, val: any) => Application",
                "optional": false
              },
              {
                "name": "get",
                "type": "((name: string) => any) & IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "param",
                "type": "(name: string | string[], handler: RequestParamHandler) => Application",
                "optional": false
              },
              {
                "name": "path",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "enabled",
                "type": "(setting: string) => boolean",
                "optional": false
              },
              {
                "name": "disabled",
                "type": "(setting: string) => boolean",
                "optional": false
              },
              {
                "name": "enable",
                "type": "(setting: string) => Application",
                "optional": false
              },
              {
                "name": "disable",
                "type": "(setting: string) => Application",
                "optional": false
              },
              {
                "name": "render",
                "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
                "optional": false
              },
              {
                "name": "listen",
                "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
                "optional": false
              },
              {
                "name": "router",
                "type": "Router",
                "optional": false
              },
              {
                "name": "settings",
                "type": "any",
                "optional": false
              },
              {
                "name": "resource",
                "type": "any",
                "optional": false
              },
              {
                "name": "map",
                "type": "any",
                "optional": false
              },
              {
                "name": "locals",
                "type": "Record<string, any> & Locals",
                "optional": false
              },
              {
                "name": "routes",
                "type": "any",
                "optional": false
              },
              {
                "name": "_router",
                "type": "any",
                "optional": false
              },
              {
                "name": "use",
                "type": "ApplicationRequestHandler<Application>",
                "optional": false
              },
              {
                "name": "on",
                "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Application",
                "optional": false
              },
              {
                "name": "mountpath",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "__@captureRejectionSymbol@40899",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true
              },
              {
                "name": "addListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "once",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "removeListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Application",
                "optional": false
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Application",
                "optional": false
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "emit",
                "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
                "optional": false
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false
              },
              {
                "name": "prependListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "prependOnceListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Application, \"all\">",
                "optional": false
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Application, \"post\">",
                "optional": false
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Application, \"put\">",
                "optional": false
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Application, \"delete\">",
                "optional": false
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Application, \"patch\">",
                "optional": false
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Application, \"options\">",
                "optional": false
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Application, \"head\">",
                "optional": false
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Application, any>",
                "optional": false
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "extends": [
              "core.Application"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CookieOptions",
            "type": "CookieOptions",
            "properties": [
              {
                "name": "maxAge",
                "type": "number",
                "optional": true
              },
              {
                "name": "signed",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "expires",
                "type": "Date",
                "optional": true
              },
              {
                "name": "httpOnly",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "path",
                "type": "string",
                "optional": true
              },
              {
                "name": "domain",
                "type": "string",
                "optional": true
              },
              {
                "name": "secure",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "encode",
                "type": "(val: string) => string",
                "optional": true
              },
              {
                "name": "sameSite",
                "type": "boolean | \"lax\" | \"strict\" | \"none\"",
                "optional": true
              },
              {
                "name": "priority",
                "type": "\"low\" | \"medium\" | \"high\"",
                "optional": true
              },
              {
                "name": "partitioned",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [
              "core.CookieOptions"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Errback",
            "type": "Errback",
            "properties": [],
            "extends": [
              "core.Errback"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ErrorRequestHandler",
            "type": "ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [],
            "extends": [
              "core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Express",
            "type": "Express",
            "properties": [
              {
                "name": "request",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "response",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "init",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "defaultConfiguration",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "engine",
                "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Express",
                "optional": false
              },
              {
                "name": "set",
                "type": "(setting: string, val: any) => Express",
                "optional": false
              },
              {
                "name": "get",
                "type": "((name: string) => any) & IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "param",
                "type": "(name: string | string[], handler: RequestParamHandler) => Express",
                "optional": false
              },
              {
                "name": "path",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "enabled",
                "type": "(setting: string) => boolean",
                "optional": false
              },
              {
                "name": "disabled",
                "type": "(setting: string) => boolean",
                "optional": false
              },
              {
                "name": "enable",
                "type": "(setting: string) => Express",
                "optional": false
              },
              {
                "name": "disable",
                "type": "(setting: string) => Express",
                "optional": false
              },
              {
                "name": "render",
                "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
                "optional": false
              },
              {
                "name": "listen",
                "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
                "optional": false
              },
              {
                "name": "router",
                "type": "Router",
                "optional": false
              },
              {
                "name": "settings",
                "type": "any",
                "optional": false
              },
              {
                "name": "resource",
                "type": "any",
                "optional": false
              },
              {
                "name": "map",
                "type": "any",
                "optional": false
              },
              {
                "name": "locals",
                "type": "Record<string, any> & Locals",
                "optional": false
              },
              {
                "name": "routes",
                "type": "any",
                "optional": false
              },
              {
                "name": "_router",
                "type": "any",
                "optional": false
              },
              {
                "name": "use",
                "type": "ApplicationRequestHandler<Express>",
                "optional": false
              },
              {
                "name": "on",
                "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Express",
                "optional": false
              },
              {
                "name": "mountpath",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "__@captureRejectionSymbol@40899",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true
              },
              {
                "name": "addListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "once",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "removeListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Express",
                "optional": false
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Express",
                "optional": false
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "emit",
                "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
                "optional": false
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false
              },
              {
                "name": "prependListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "prependOnceListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Express, \"all\">",
                "optional": false
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Express, \"post\">",
                "optional": false
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Express, \"put\">",
                "optional": false
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Express, \"delete\">",
                "optional": false
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Express, \"patch\">",
                "optional": false
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Express, \"options\">",
                "optional": false
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Express, \"head\">",
                "optional": false
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Express, any>",
                "optional": false
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "extends": [
              "core.Express"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Handler",
            "type": "Handler",
            "properties": [],
            "extends": [
              "core.Handler"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IRoute",
            "type": "IRoute",
            "properties": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false
              },
              {
                "name": "all",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "get",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "post",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "put",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "delete",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "patch",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "options",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "head",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "checkout",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "copy",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "lock",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "merge",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "mkactivity",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "mkcol",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "move",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "m-search",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "notify",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "purge",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "report",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "search",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "subscribe",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "trace",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "unlock",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              },
              {
                "name": "unsubscribe",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false
              }
            ],
            "extends": [
              "core.IRoute"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IRouter",
            "type": "IRouter",
            "properties": [
              {
                "name": "param",
                "type": "(name: string, handler: RequestParamHandler) => IRouter",
                "optional": false
              },
              {
                "name": "all",
                "type": "IRouterMatcher<IRouter, \"all\">",
                "optional": false
              },
              {
                "name": "get",
                "type": "IRouterMatcher<IRouter, \"get\">",
                "optional": false
              },
              {
                "name": "post",
                "type": "IRouterMatcher<IRouter, \"post\">",
                "optional": false
              },
              {
                "name": "put",
                "type": "IRouterMatcher<IRouter, \"put\">",
                "optional": false
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<IRouter, \"delete\">",
                "optional": false
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<IRouter, \"patch\">",
                "optional": false
              },
              {
                "name": "options",
                "type": "IRouterMatcher<IRouter, \"options\">",
                "optional": false
              },
              {
                "name": "head",
                "type": "IRouterMatcher<IRouter, \"head\">",
                "optional": false
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "move",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "report",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "search",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "link",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "use",
                "type": "IRouterHandler<IRouter, string> & IRouterMatcher<IRouter, any>",
                "optional": false
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "extends": [
              "core.IRouter"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IRouterHandler",
            "type": "IRouterHandler<T>",
            "properties": [],
            "extends": [
              "core.IRouterHandler<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IRouterMatcher",
            "type": "IRouterMatcher<T>",
            "properties": [],
            "extends": [
              "core.IRouterMatcher<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MediaType",
            "type": "MediaType",
            "properties": [
              {
                "name": "value",
                "type": "string",
                "optional": false
              },
              {
                "name": "quality",
                "type": "number",
                "optional": false
              },
              {
                "name": "type",
                "type": "string",
                "optional": false
              },
              {
                "name": "subtype",
                "type": "string",
                "optional": false
              }
            ],
            "extends": [
              "core.MediaType"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NextFunction",
            "type": "NextFunction",
            "properties": [],
            "extends": [
              "core.NextFunction"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Locals",
            "type": "Locals",
            "properties": [],
            "extends": [
              "core.Locals"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Request",
            "type": "Request<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [
              {
                "name": "get",
                "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
                "optional": false
              },
              {
                "name": "header",
                "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
                "optional": false
              },
              {
                "name": "accepts",
                "type": "{ (): string[]; (type: string): string | false; (type: string[]): string | false; (...type: string[]): string | false; }",
                "optional": false
              },
              {
                "name": "acceptsCharsets",
                "type": "{ (): string[]; (charset: string): string | false; (charset: string[]): string | false; (...charset: string[]): string | false; }",
                "optional": false
              },
              {
                "name": "acceptsEncodings",
                "type": "{ (): string[]; (encoding: string): string | false; (encoding: string[]): string | false; (...encoding: string[]): string | false; }",
                "optional": false
              },
              {
                "name": "acceptsLanguages",
                "type": "{ (): string[]; (lang: string): string | false; (lang: string[]): string | false; (...lang: string[]): string | false; }",
                "optional": false
              },
              {
                "name": "range",
                "type": "(size: number, options?: Options) => Ranges | Result",
                "optional": false
              },
              {
                "name": "accepted",
                "type": "MediaType[]",
                "optional": false
              },
              {
                "name": "is",
                "type": "(type: string | string[]) => string | false",
                "optional": false
              },
              {
                "name": "protocol",
                "type": "string",
                "optional": false
              },
              {
                "name": "secure",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "ip",
                "type": "string",
                "optional": false
              },
              {
                "name": "ips",
                "type": "string[]",
                "optional": false
              },
              {
                "name": "subdomains",
                "type": "string[]",
                "optional": false
              },
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "host",
                "type": "string",
                "optional": false
              },
              {
                "name": "fresh",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "stale",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "xhr",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "body",
                "type": "ReqBody",
                "optional": false
              },
              {
                "name": "cookies",
                "type": "any",
                "optional": false
              },
              {
                "name": "method",
                "type": "string",
                "optional": false
              },
              {
                "name": "params",
                "type": "P",
                "optional": false
              },
              {
                "name": "query",
                "type": "ReqQuery",
                "optional": false
              },
              {
                "name": "route",
                "type": "any",
                "optional": false
              },
              {
                "name": "signedCookies",
                "type": "any",
                "optional": false
              },
              {
                "name": "originalUrl",
                "type": "string",
                "optional": false
              },
              {
                "name": "url",
                "type": "string",
                "optional": false
              },
              {
                "name": "baseUrl",
                "type": "string",
                "optional": false
              },
              {
                "name": "app",
                "type": "Application<Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<ResBody, Locals, number>",
                "optional": true
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": true
              },
              {
                "name": "aborted",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "httpVersion",
                "type": "string",
                "optional": false
              },
              {
                "name": "httpVersionMajor",
                "type": "number",
                "optional": false
              },
              {
                "name": "httpVersionMinor",
                "type": "number",
                "optional": false
              },
              {
                "name": "complete",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "connection",
                "type": "Socket",
                "optional": false
              },
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              },
              {
                "name": "headers",
                "type": "IncomingHttpHeaders",
                "optional": false
              },
              {
                "name": "headersDistinct",
                "type": "Dict<string[]>",
                "optional": false
              },
              {
                "name": "rawHeaders",
                "type": "string[]",
                "optional": false
              },
              {
                "name": "trailers",
                "type": "Dict<string>",
                "optional": false
              },
              {
                "name": "trailersDistinct",
                "type": "Dict<string[]>",
                "optional": false
              },
              {
                "name": "rawTrailers",
                "type": "string[]",
                "optional": false
              },
              {
                "name": "setTimeout",
                "type": "(msecs: number, callback?: () => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "statusCode",
                "type": "number",
                "optional": true
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "destroy",
                "type": "(error?: Error) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "readableAborted",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "readable",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "readableDidRead",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "readableEncoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "readableEnded",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "readableFlowing",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "readableHighWaterMark",
                "type": "number",
                "optional": false
              },
              {
                "name": "readableLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "readableObjectMode",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "destroyed",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "closed",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "errored",
                "type": "Error",
                "optional": false
              },
              {
                "name": "_construct",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": true
              },
              {
                "name": "_read",
                "type": "(size: number) => void",
                "optional": false
              },
              {
                "name": "read",
                "type": "(size?: number) => any",
                "optional": false
              },
              {
                "name": "setEncoding",
                "type": "(encoding: BufferEncoding) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "pause",
                "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "resume",
                "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "isPaused",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "unpipe",
                "type": "(destination?: WritableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(chunk: any, encoding?: BufferEncoding) => void",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "(stream: ReadableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "push",
                "type": "(chunk: any, encoding?: BufferEncoding) => boolean",
                "optional": false
              },
              {
                "name": "iterator",
                "type": "(options?: { destroyOnReturn?: boolean; }) => AsyncIterator<any, any, any>",
                "optional": false
              },
              {
                "name": "map",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Readable",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>, options?: ArrayOptions) => Promise<void>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "(options?: Pick<ArrayOptions, \"signal\">) => Promise<any[]>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <T>(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T, options?: ArrayOptions): Promise<T>; (fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<...>, options?: ArrayOptions): Promise<...>; }",
                "optional": false
              },
              {
                "name": "every",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false
              },
              {
                "name": "take",
                "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false
              },
              {
                "name": "asIndexedPairs",
                "type": "(options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <T = any>(fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T, initial?: undefined, options?: Pick<ArrayOptions, \"signal\">): Promise<...>; <T = any>(fn: (previous: T, data: any, options?: Pick<...>) => T, initial: T, options?: Pick<...>): Promise<...>; }",
                "optional": false
              },
              {
                "name": "_destroy",
                "type": "(error: Error, callback: (error?: Error) => void) => void",
                "optional": false
              },
              {
                "name": "addListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "emit",
                "type": "{ (event: \"close\"): boolean; (event: \"data\", chunk: any): boolean; (event: \"end\"): boolean; (event: \"error\", err: Error): boolean; (event: \"pause\"): boolean; (event: \"readable\"): boolean; (event: \"resume\"): boolean; (event: string | symbol, ...args: any[]): boolean; }",
                "optional": false
              },
              {
                "name": "on",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "once",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "prependListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "prependOnceListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "removeListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false
              },
              {
                "name": "__@asyncIterator@41528",
                "type": "() => AsyncIterator<any, any, any>",
                "optional": false
              },
              {
                "name": "__@asyncDispose@41530",
                "type": "() => Promise<void>",
                "optional": false
              },
              {
                "name": "pipe",
                "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
                "optional": false
              },
              {
                "name": "compose",
                "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
                "optional": false
              },
              {
                "name": "__@captureRejectionSymbol@40899",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false
              }
            ],
            "extends": [
              "core.Request<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RequestHandler",
            "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [],
            "extends": [
              "core.RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RequestParamHandler",
            "type": "RequestParamHandler",
            "properties": [],
            "extends": [
              "core.RequestParamHandler"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Response",
            "type": "Response<ResBody, Locals>",
            "properties": [
              {
                "name": "status",
                "type": "(code: number) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "sendStatus",
                "type": "(code: number) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "links",
                "type": "(links: any) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "send",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false
              },
              {
                "name": "json",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false
              },
              {
                "name": "jsonp",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false
              },
              {
                "name": "sendFile",
                "type": "{ (path: string, fn?: Errback): void; (path: string, options: SendFileOptions, fn?: Errback): void; }",
                "optional": false
              },
              {
                "name": "download",
                "type": "{ (path: string, fn?: Errback): void; (path: string, filename: string, fn?: Errback): void; (path: string, filename: string, options: DownloadOptions, fn?: Errback): void; }",
                "optional": false
              },
              {
                "name": "contentType",
                "type": "(type: string) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "type",
                "type": "(type: string) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "format",
                "type": "(obj: any) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "attachment",
                "type": "(filename?: string) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
                "optional": false
              },
              {
                "name": "header",
                "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
                "optional": false
              },
              {
                "name": "headersSent",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "get",
                "type": "(field: string) => string",
                "optional": false
              },
              {
                "name": "clearCookie",
                "type": "(name: string, options?: CookieOptions) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "cookie",
                "type": "{ (name: string, val: string, options: CookieOptions): Response<ResBody, Locals>; (name: string, val: any, options: CookieOptions): Response<...>; (name: string, val: any): Response<...>; }",
                "optional": false
              },
              {
                "name": "location",
                "type": "(url: string) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "redirect",
                "type": "{ (url: string): void; (status: number, url: string): void; }",
                "optional": false
              },
              {
                "name": "render",
                "type": "{ (view: string, options?: object, callback?: (err: Error, html: string) => void): void; (view: string, callback?: (err: Error, html: string) => void): void; }",
                "optional": false
              },
              {
                "name": "locals",
                "type": "Locals & Locals",
                "optional": false
              },
              {
                "name": "charset",
                "type": "string",
                "optional": false
              },
              {
                "name": "vary",
                "type": "(field: string) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "app",
                "type": "Application<Record<string, any>>",
                "optional": false
              },
              {
                "name": "append",
                "type": "(field: string, value?: string | string[]) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": false
              },
              {
                "name": "strictContentLength",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "assignSocket",
                "type": "(socket: Socket) => void",
                "optional": false
              },
              {
                "name": "detachSocket",
                "type": "(socket: Socket) => void",
                "optional": false
              },
              {
                "name": "writeContinue",
                "type": "(callback?: () => void) => void",
                "optional": false
              },
              {
                "name": "writeEarlyHints",
                "type": "(hints: Record<string, string | string[]>, callback?: () => void) => void",
                "optional": false
              },
              {
                "name": "writeHead",
                "type": "{ (statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<ResBody, Locals>; (statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<...>; }",
                "optional": false
              },
              {
                "name": "writeProcessing",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "chunkedEncoding",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "shouldKeepAlive",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "useChunkedEncodingByDefault",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "sendDate",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "finished",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "connection",
                "type": "Socket",
                "optional": false
              },
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              },
              {
                "name": "setTimeout",
                "type": "(msecs: number, callback?: () => void) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "setHeader",
                "type": "(name: string, value: string | number | readonly string[]) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "setHeaders",
                "type": "(headers: Headers | Map<string, string | number | readonly string[]>) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "appendHeader",
                "type": "(name: string, value: string | readonly string[]) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "getHeader",
                "type": "(name: string) => string | number | string[]",
                "optional": false
              },
              {
                "name": "getHeaders",
                "type": "() => OutgoingHttpHeaders",
                "optional": false
              },
              {
                "name": "getHeaderNames",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "hasHeader",
                "type": "(name: string) => boolean",
                "optional": false
              },
              {
                "name": "removeHeader",
                "type": "(name: string) => void",
                "optional": false
              },
              {
                "name": "addTrailers",
                "type": "(headers: OutgoingHttpHeaders | readonly [string, string][]) => void",
                "optional": false
              },
              {
                "name": "flushHeaders",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "writable",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "writableEnded",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "writableFinished",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "writableHighWaterMark",
                "type": "number",
                "optional": false
              },
              {
                "name": "writableLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "writableObjectMode",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "writableCorked",
                "type": "number",
                "optional": false
              },
              {
                "name": "destroyed",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "closed",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "errored",
                "type": "Error",
                "optional": false
              },
              {
                "name": "writableNeedDrain",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "_write",
                "type": "(chunk: any, encoding: BufferEncoding, callback: (error?: Error) => void) => void",
                "optional": false
              },
              {
                "name": "_writev",
                "type": "(chunks: { chunk: any; encoding: BufferEncoding; }[], callback: (error?: Error) => void) => void",
                "optional": true
              },
              {
                "name": "_construct",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": true
              },
              {
                "name": "_destroy",
                "type": "(error: Error, callback: (error?: Error) => void) => void",
                "optional": false
              },
              {
                "name": "_final",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": false
              },
              {
                "name": "write",
                "type": "{ (chunk: any, callback?: (error: Error) => void): boolean; (chunk: any, encoding: BufferEncoding, callback?: (error: Error) => void): boolean; }",
                "optional": false
              },
              {
                "name": "setDefaultEncoding",
                "type": "(encoding: BufferEncoding) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "end",
                "type": "{ (cb?: () => void): Response<ResBody, Locals>; (chunk: any, cb?: () => void): Response<ResBody, Locals>; (chunk: any, encoding: BufferEncoding, cb?: () => void): Response<...>; }",
                "optional": false
              },
              {
                "name": "cork",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "uncork",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "destroy",
                "type": "(error?: Error) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "addListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "emit",
                "type": "{ (event: \"close\"): boolean; (event: \"drain\"): boolean; (event: \"error\", err: Error): boolean; (event: \"finish\"): boolean; (event: \"pipe\", src: Readable): boolean; (event: \"unpipe\", src: Readable): boolean; (event: string | symbol, ...args: any[]): boolean; }",
                "optional": false
              },
              {
                "name": "on",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "once",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "prependListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "prependOnceListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "removeListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false
              },
              {
                "name": "pipe",
                "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
                "optional": false
              },
              {
                "name": "compose",
                "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
                "optional": false
              },
              {
                "name": "__@captureRejectionSymbol@40899",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Response<ResBody, Locals>",
                "optional": false
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false
              }
            ],
            "extends": [
              "core.Response<ResBody, Locals>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Router",
            "type": "Router",
            "properties": [
              {
                "name": "param",
                "type": "(name: string, handler: RequestParamHandler) => Router",
                "optional": false
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Router, \"all\">",
                "optional": false
              },
              {
                "name": "get",
                "type": "IRouterMatcher<Router, \"get\">",
                "optional": false
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Router, \"post\">",
                "optional": false
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Router, \"put\">",
                "optional": false
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Router, \"delete\">",
                "optional": false
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Router, \"patch\">",
                "optional": false
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Router, \"options\">",
                "optional": false
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Router, \"head\">",
                "optional": false
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "use",
                "type": "IRouterHandler<Router, string> & IRouterMatcher<Router, any>",
                "optional": false
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "extends": [
              "core.Router"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Send",
            "type": "Send",
            "properties": [],
            "extends": [
              "core.Send"
            ],
            "jsdoc": null,
            "isExported": false
          }
        ],
        "classes": [],
        "constants": [
          {
            "name": "json",
            "type": "(options?: OptionsJson) => NextHandleFunction",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "raw",
            "type": "(options?: Options) => NextHandleFunction",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "text",
            "type": "(options?: OptionsText) => NextHandleFunction",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "application",
            "type": "Application",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "request",
            "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "response",
            "type": "Response<any, Record<string, any>>",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "static",
            "type": "RequestHandlerConstructor<Response<any, Record<string, any>>>",
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "urlencoded",
            "type": "(options?: OptionsUrlencoded) => NextHandleFunction",
            "jsdoc": null,
            "isExported": false
          }
        ]
      },
      "jsdoc": null,
      "isExported": false
    }
  ],
  "version": "4.19.2"
}