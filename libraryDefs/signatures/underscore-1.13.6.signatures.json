{
  "functions": [
    {
      "name": "_",
      "parameters": [
        {
          "name": "value",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "Underscore<TypeOfCollection<V, never>, V>",
      "jsdoc": null
    },
    {
      "name": "each",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "CollectionIterator<TypeOfCollection<V, never>, void, V>",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "V",
      "jsdoc": {
        "description": "*************\nCollections *\n*************",
        "deprecated": false
      }
    },
    {
      "name": "forEach",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "CollectionIterator<TypeOfCollection<V, never>, void, V>",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "V",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "map",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "IterateeResult<I, TypeOfCollection<V, never>>[]",
      "jsdoc": {
        "description": "Produces a new array of values by mapping each value in `collection`\nthrough a transformation `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to transform."
          },
          {
            "name": "iteratee",
            "description": "The iteratee to use to transform each item in\n`collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The mapped result.",
        "deprecated": false
      }
    },
    {
      "name": "collect",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "IterateeResult<I, TypeOfCollection<V, never>>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "reduce",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "Also known as inject and foldl, reduce boils down a `collection` of\nvalues into a single value. `memo` is the initial state of the\nreduction, and each successive step of it should be returned by\n`iteratee`.\n\nIf no memo is passed to the initial invocation of reduce, `iteratee`\nis not invoked on the first element of `collection`. The first\nelement is instead passed as the memo in the invocation of\n`iteratee` on the next element in `collection`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to reduce."
          },
          {
            "name": "iteratee",
            "description": "The function to call on each iteration to reduce the\ncollection."
          },
          {
            "name": "memo",
            "description": "The initial reduce state or undefined to use the first\nitem in `collection` as initial state."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The reduced result.",
        "deprecated": false
      }
    },
    {
      "name": "inject",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "foldl",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "reduceRight",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "The right-associative version of reduce.\n\nThis is not as useful in JavaScript as it would be in a language\nwith lazy evaluation.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to reduce."
          },
          {
            "name": "iteratee",
            "description": "The function to call on each iteration to reduce the\ncollection."
          },
          {
            "name": "memo",
            "description": "The initial reduce state or undefined to use the first\nitem in `collection` as the initial state."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The reduced result.",
        "deprecated": false
      }
    },
    {
      "name": "foldr",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "find",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning the first one\nthat passes a truth test (`iteratee`), or undefined if no value\npasses the test. The function returns as soon as it finds an\nacceptable element, and doesn't traverse the entire collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to search."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The first element in `collection` that passes the truth\ntest or undefined if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "detect",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "filter",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning an array of\nall the values that pass a truth test (`iteratee`).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to filter."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The set of values that pass the truth test.",
        "deprecated": false
      }
    },
    {
      "name": "select",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "where",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "properties",
          "type": "Partial<TypeOfCollection<V, never>>",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning an array of all\nthe elements that match the key-value pairs listed in `properties`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find elements that\nmatch `properties`."
          },
          {
            "name": "properties",
            "description": "The properties to check for on the elements within\n`collection`."
          }
        ],
        "returns": "The elements in `collection` that match `properties`.",
        "deprecated": false
      }
    },
    {
      "name": "findWhere",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "properties",
          "type": "Partial<TypeOfCollection<V, never>>",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Looks through `collection` and returns the first value that matches\nall of the key-value pairs listed in `properties`. If no match is\nfound, or if list is empty, undefined will be returned.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find an element that\nmatches `properties`."
          },
          {
            "name": "properties",
            "description": "The properties to check for on the elements within\n`collection`."
          }
        ],
        "returns": "The first element in `collection` that matches `properties`\nor undefined if no match is found.",
        "deprecated": false
      }
    },
    {
      "name": "reject",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns the values in `collection` without the elements that pass a\ntruth test (`iteratee`).\nThe opposite of filter.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to filter."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The set of values that fail the truth test.",
        "deprecated": false
      }
    },
    {
      "name": "every",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if all of the values in `collection` pass the\n`iteratee` truth test. Short-circuits and stops traversing\n`collection` if a false element is found.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "True if all elements pass the truth test, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "all",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "some",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if any of the values in `collection` pass the\n`iteratee` truth test. Short-circuits and stops traversing\n`collection` if a true element is found.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "True if any element passed the truth test, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "any",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "contains",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the value is present in `collection`. Uses indexOf\ninternally, if `collection` is a List. Use `fromIndex` to start your\nsearch at a given index.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to check for `value`."
          },
          {
            "name": "value",
            "description": "The value to check `collection` for."
          },
          {
            "name": "fromIndex",
            "description": "The index to start searching from, optional,\ndefault = 0, only used when `collection` is a List."
          }
        ],
        "returns": "True if `value` is present in `collection` after\n`fromIndex`, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "include",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "includes",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "invoke",
      "parameters": [
        {
          "name": "list",
          "type": "Collection<any>",
          "optional": false
        },
        {
          "name": "methodName",
          "type": "string",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any[]",
      "jsdoc": {
        "description": "Calls the method named by `methodName` on each value in\n`collection`. Any extra arguments passed to invoke will be forwarded\non to the method invocation.",
        "params": [
          {
            "name": "collection",
            "description": "The collection of elements to invoke `methodName`\non."
          },
          {
            "name": "methodName",
            "description": "The name of the method to call on each element in\n`collection`."
          },
          {
            "name": "args",
            "description": "Additional arguments to pass to method `methodName`."
          }
        ],
        "returns": "An array containing the result of the method call for each\nitem in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "pluck",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "propertyName",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]",
      "jsdoc": {
        "description": "A convenient version of what is perhaps the most common use-case for\nmap: extracting a list of property values.",
        "params": [
          {
            "name": "collection",
            "description": "The collection of items."
          },
          {
            "name": "propertyName",
            "description": "The name of a specific property to retrieve from\nall items in `collection`."
          }
        ],
        "returns": "The set of values for the specified `propertyName` for each\nitem in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "max",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number | TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Returns the maximum value in `collection`. If an `iteratee` is\nprovided, it will be used on each element to generate the criterion\nby which the element is ranked. -Infinity is returned if list is\nempty. Non-numerical values returned by `iteratee` will be ignored.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find the maximum value."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that provides the criterion by which\neach element is ranked, optional if evaluating a collection of\nnumbers."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The maximum element within `collection` or -Infinity if\n`collection` is empty.",
        "deprecated": false
      }
    },
    {
      "name": "min",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number | TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Returns the minimum value in `collection`. If an `iteratee` is\nprovided, it will be used on each element to generate the criterion\nby which the element is ranked. Infinity is returned if list is\nempty. Non-numerical values returned by `iteratee` will be ignored.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find the minimum value."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that provides the criterion by which\neach element is ranked, optional if evaluating a collection of\nnumbers."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The minimum element within `collection` or Infinity if\n`collection` is empty.",
        "deprecated": false
      }
    },
    {
      "name": "sortBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns a (stably) sorted copy of `collection`, ranked in ascending\norder by the results of running each value through `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sort."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to sort by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A sorted copy of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "groupBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<TypeOfCollection<V, never>[]>",
      "jsdoc": {
        "description": "Splits `collection` into sets that are grouped by the result of\nrunning each value through `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to group."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to group by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary with the group names provided by `iteratee` as\nproperties where each property contains the grouped elements from\n`collection`.",
        "deprecated": false
      }
    },
    {
      "name": "indexBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<TypeOfCollection<V, never>>",
      "jsdoc": {
        "description": "Given a `collection` and an `iteratee` function that returns a key\nfor each element in `collection`, returns an object that acts as an\nindex of each item.  Just like `groupBy`, but for when you know your\nkeys are unique.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to index."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to index by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary where each item in `collection` is assigned to\nthe property designated by `iteratee`.",
        "deprecated": false
      }
    },
    {
      "name": "countBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<number>",
      "jsdoc": {
        "description": "Sorts `collection` into groups and returns a count for the number of\nobjects in each group. Similar to `groupBy`, but instead of\nreturning a list of values, returns a count for the number of values\nin that group.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to count."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to count by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary with the group names provided by `iteratee` as\nproperties where each property contains the count of the grouped\nelements from `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "shuffle",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns a shuffled copy of `collection`, using a version of the\nFisher-Yates shuffle.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to shuffle."
          }
        ],
        "returns": "A shuffled copy of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "sample",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Produce a random sample from `collection`. Pass a number to return\n`n` random elements from `collection`. Otherwise a single random\nitem will be returned.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          },
          {
            "name": "n",
            "description": "The number of elements to sample from `collection`."
          }
        ],
        "returns": "A random sample of `n` elements from `collection` or a\nsingle element if `n` is not specified.",
        "deprecated": false
      }
    },
    {
      "name": "toArray",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Creates a real Array from `collection` (anything that can be\niterated over). Useful for transmuting the arguments object.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to transform into an array."
          }
        ],
        "returns": "An array containing the elements of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "size",
      "parameters": [
        {
          "name": "collection",
          "type": "Collection<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines the number of values in `collection`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to determine the number of values\nfor."
          }
        ],
        "returns": "The number of values in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "partition",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "[TypeOfCollection<V, never>[], TypeOfCollection<V, never>[]]",
      "jsdoc": {
        "description": "Splits `collection` into two arrays: one whose elements all satisfy\n`iteratee` and one whose elements all do not satisfy `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to partition."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that defines the partitioning scheme\nfor each element in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "An array composed of two elements, where the first element\ncontains the elements in `collection` that satisfied the predicate\nand the second element contains the elements that did not.",
        "deprecated": false
      }
    },
    {
      "name": "first",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "********\nArrays *\n********",
        "deprecated": false
      }
    },
    {
      "name": "head",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "take",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "initial",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns everything but the last entry of `list`. Especially useful\non the arguments object. Pass `n` to exclude the last\n`n` elements from the result.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "n",
            "description": "The number of elements from the end of `list` to omit,\noptional, default = 1."
          }
        ],
        "returns": "The elements of `list` with the last `n` items omitted.",
        "deprecated": false
      }
    },
    {
      "name": "last",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "Returns the last element of `list`. Passing `n` will return the last\n`n` elements of `list`.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "n",
            "description": "The number of elements to retrieve, optional."
          }
        ],
        "returns": "The last `n` elements of `list` or the last element if `n`\nis omitted.",
        "deprecated": false
      }
    },
    {
      "name": "rest",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns the rest of the elements in `list`. Pass an `index` to\nreturn the values of the list from that index onward.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "index",
            "description": "The index to start retrieving elements from, optional,\ndefault = 1."
          }
        ],
        "returns": "The elements of `list` from `index` to the end of the list.",
        "deprecated": false
      }
    },
    {
      "name": "tail",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "drop",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "compact",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "Exclude<TypeOfList<V>, AnyFalsy>[]",
      "jsdoc": {
        "description": "Returns a copy of `list` with all falsy values removed. In\nJavaScript, false, null, 0, \"\", undefined and NaN are all falsy.",
        "params": [
          {
            "name": "list",
            "description": "The list to compact."
          }
        ],
        "returns": "An array containing the elements of `list` without falsy\nvalues.",
        "deprecated": false
      }
    },
    {
      "name": "flatten",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "depth",
          "type": "true | 1",
          "optional": false
        }
      ],
      "returnType": "ListItemOrSelf<TypeOfList<V>>[]",
      "jsdoc": {
        "description": "Flattens a nested `list` (the nesting can be to any depth). If you\npass true or 1 as the depth, the `list` will only be flattened a\nsingle level. Passing a greater number will cause the flattening to\ndescend deeper into the nesting hierarchy. Omitting the depth\nargument, or passing false or Infinity, flattens the `list` all the\nway to the deepest nesting level.",
        "params": [
          {
            "name": "list",
            "description": "The list to flatten."
          },
          {
            "name": "depth",
            "description": "True to only flatten one level, optional,\ndefault = false."
          }
        ],
        "returns": "The flattened `list`.",
        "deprecated": false
      }
    },
    {
      "name": "without",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "values",
          "type": "TypeOfList<V>[]",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns a copy of `list` with all instances of `values` removed.",
        "params": [
          {
            "name": "list",
            "description": "The list to exclude `values` from."
          },
          {
            "name": "values",
            "description": "The values to exclude from `list`."
          }
        ],
        "returns": "An array that contains all elements of `list` except for\n`values`.",
        "deprecated": false
      }
    },
    {
      "name": "union",
      "parameters": [
        {
          "name": "lists",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Computes the union of the passed-in `lists`: the list of unique\nitems, examined in order from first list to last list, that are\npresent in one or more of the lists.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to compute the union of."
          }
        ],
        "returns": "The union of elements within `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "intersection",
      "parameters": [
        {
          "name": "lists",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Computes the list of values that are the intersection of the\npassed-in `lists`. Each value in the result is present in each of\nthe lists.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to compute the intersection of."
          }
        ],
        "returns": "The intersection of elements within the `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "difference",
      "parameters": [
        {
          "name": "list",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "others",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Similar to without, but returns the values from `list` that are not\npresent in `others`.",
        "params": [
          {
            "name": "list",
            "description": "The starting list."
          },
          {
            "name": "others",
            "description": "The lists of values to exclude from `list`."
          }
        ],
        "returns": "The contents of `list` without the values in `others`.",
        "deprecated": false
      }
    },
    {
      "name": "uniq",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "isSorted",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Produces a duplicate-free version of `list`, using === to test\nobject equality. If you know in advance that `list` is sorted,\npassing true for isSorted will run a much faster algorithm. If you\nwant to compute unique items based on a transformation, pass an\niteratee function.",
        "params": [
          {
            "name": "list",
            "description": "The list to remove duplicates from."
          },
          {
            "name": "isSorted",
            "description": "True if `list` is already sorted, optional,\ndefault = false."
          },
          {
            "name": "iteratee",
            "description": "Transform the elements of `list` before comparisons\nfor uniqueness."
          },
          {
            "name": "context",
            "description": "'this' object in `iteratee`, optional."
          }
        ],
        "returns": "An array containing only the unique elements in `list`.",
        "deprecated": false
      }
    },
    {
      "name": "unique",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "isSorted",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "zip",
      "parameters": [],
      "returnType": "[]",
      "jsdoc": {
        "description": "Merges together the values of each of the `lists` with the values at\nthe corresponding position. Useful when you have separate data\nsources that are coordinated through matching list indexes.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to zip."
          }
        ],
        "returns": "The zipped version of `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "unzip",
      "parameters": [
        {
          "name": "lists",
          "type": "List<[T, U, V]>",
          "optional": false
        }
      ],
      "returnType": "[T[], U[], V[]]",
      "jsdoc": {
        "description": "The opposite of zip. Given a list of lists, returns a series of new\narrays, the first of which contains all of the first elements in the\ninput lists, the second of which contains all of the second\nelements, and so on. (alias: transpose)",
        "params": [
          {
            "name": "lists",
            "description": "The lists to unzip."
          }
        ],
        "returns": "The unzipped version of `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "transpose",
      "parameters": [
        {
          "name": "lists",
          "type": "List<[T, U, V]>",
          "optional": false
        }
      ],
      "returnType": "[T[], U[], V[]]",
      "jsdoc": null
    },
    {
      "name": "object",
      "parameters": [
        {
          "name": "list",
          "type": "TList",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<TValue>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<TValue>",
      "jsdoc": {
        "description": "Converts lists into objects. Pass either a single `list` of\n[key, value] pairs, or a `list` of keys and a list of `values`.\nPassing by pairs is the reverse of pairs. If duplicate keys exist,\nthe last value wins.",
        "params": [
          {
            "name": "list",
            "description": "A list of [key, value] pairs or a list of keys."
          },
          {
            "name": "values",
            "description": "If `list` is a list of keys, a list of values\ncorresponding to those keys."
          }
        ],
        "returns": "An object comprised of the provided keys and values.",
        "deprecated": false
      }
    },
    {
      "name": "indexOf",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "isSortedOrFromIndex",
          "type": "number | boolean",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index at which `value` can be found in `list`, or -1 if\n`value` is not present. If you're working with a large list and you\nknow that the list is already sorted, pass true for\n`isSortedOrFromIndex` to use a faster binary search...or, pass a\nnumber in order to look for the first matching value in the list\nafter the given index.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of `value`."
          },
          {
            "name": "value",
            "description": "The value to search for within `list`."
          },
          {
            "name": "isSortedOrFromIndex",
            "description": "True if `list` is already sorted OR the\nstarting index for the search, optional."
          }
        ],
        "returns": "The index of the first occurrence of `value` within `list`\nor -1 if `value` is not found.",
        "deprecated": false
      }
    },
    {
      "name": "lastIndexOf",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the last occurrence of `value` in `list`, or -1\nif `value` is not present. Pass `fromIndex` to start your search at\na given index.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the last occurrence of `value`."
          },
          {
            "name": "value",
            "description": "The value to search for within `list`."
          },
          {
            "name": "fromIndex",
            "description": "The starting index for the search, optional."
          }
        ],
        "returns": "The index of the last occurrence of `value` within `list`\nor -1 if `value` is not found.",
        "deprecated": false
      }
    },
    {
      "name": "findIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the first index of an element in `list` where the `iteratee`\ntruth test passes, otherwise returns -1.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of the first element\nthat passes the truth test."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index of the first element in `list` where the\ntruth test passes or -1 if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "findLastIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the last index of an element in `list` where the `iteratee`\ntruth test passes, otherwise returns -1.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of the last element\nthat passes the truth test."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index of the last element in `list` where the\ntruth test passes or -1 if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "sortedIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Uses a binary search to determine the lowest index at which the\nvalue should be inserted into `list` in order to maintain `list`'s\nsorted order. If an iteratee is provided, it will be used to compute\nthe sort ranking of each value, including the value you pass.",
        "params": [
          {
            "name": "list",
            "description": "A sorted list."
          },
          {
            "name": "value",
            "description": "The value to determine an insert index for to mainain\nthe sorting in `list`."
          },
          {
            "name": "iteratee",
            "description": "Iteratee to compute the sort ranking of each\nelement including `value`, optional."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index where `value` should be inserted into `list`.",
        "deprecated": false
      }
    },
    {
      "name": "range",
      "parameters": [
        {
          "name": "startOrStop",
          "type": "number",
          "optional": false
        },
        {
          "name": "stop",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "A function to create flexibly-numbered lists of integers, handy for\n`each` and `map` loops. Returns a list of integers from\n`startOrStop` (inclusive) to `stop` (exclusive), incremented\n(or decremented) by `step`. Note that ranges that `stop` before they\n`start` are considered to be zero-length instead of negative - if\nyou'd like a negative range, use a negative `step`.\n\nIf `stop` is not specified, `startOrStop` will be the number to stop\nat and the default start of 0 will be used.",
        "params": [
          {
            "name": "startOrStop",
            "description": "If `stop` is specified, the number to start at.\nOtherwise, this is the number to stop at and the default start of 0\nwill be used."
          },
          {
            "name": "stop",
            "description": "The number to stop at."
          },
          {
            "name": "step",
            "description": "The number to count up by each iteration, optional,\ndefault = 1."
          }
        ],
        "returns": "An array of numbers from start to `stop` with increments\nof `step`.",
        "deprecated": false
      }
    },
    {
      "name": "chunk",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>[][]",
      "jsdoc": {
        "description": "Chunks `list` into multiple arrays, each containing `length` or\nfewer items.",
        "params": [
          {
            "name": "list",
            "description": "The list to chunk."
          },
          {
            "name": "length",
            "description": "The maximum size of the chunks."
          }
        ],
        "returns": "The contents of `list` in chunks no greater than `length`\nin size.",
        "deprecated": false
      }
    },
    {
      "name": "bind",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "() => any",
      "jsdoc": {
        "description": "***********\nFunctions *\n***********",
        "deprecated": false
      }
    },
    {
      "name": "bindAll",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "methodNames",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Binds a number of methods on the object, specified by methodNames, to be run in the context of that object\nwhenever they are invoked. Very handy for binding functions that are going to be used as event handlers,\nwhich would otherwise be invoked with a fairly useless this. If no methodNames are provided, all of the\nobject's function properties will be bound to it.",
        "params": [
          {
            "name": "object",
            "description": "The object to bind the methods `methodName` to."
          },
          {
            "name": "methodNames",
            "description": "The methods to bind to `object`, optional and if not provided all of `object`'s\nmethods are bound."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "partial",
      "parameters": [
        {
          "name": "fn",
          "type": "(p1: T1) => T2",
          "optional": false
        },
        {
          "name": "p1",
          "type": "T1",
          "optional": false
        }
      ],
      "returnType": "() => T2",
      "jsdoc": {
        "description": "Partially apply a function by filling in any number of its arguments, without changing its dynamic this value.\nA close cousin of bind.  You may pass _ in your list of arguments to specify an argument that should not be\npre-filled, but left open to supply at call-time.",
        "params": [
          {
            "name": "fn",
            "description": "Function to partially fill in arguments."
          },
          {
            "name": "arguments",
            "description": "The partial arguments."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "memoize",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        },
        {
          "name": "hashFn",
          "type": "(...args: any[]) => string",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Memoizes a given function by caching the computed result. Useful for speeding up slow-running computations.\nIf passed an optional hashFunction, it will be used to compute the hash key for storing the result, based\non the arguments to the original function. The default hashFunction just uses the first argument to the\nmemoized function as the key.",
        "params": [
          {
            "name": "fn",
            "description": "Computationally expensive function that will now memoized results."
          },
          {
            "name": "hashFn",
            "description": "Hash function for storing the result of `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "delay",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Much like setTimeout, invokes function after wait milliseconds. If you pass the optional arguments,\nthey will be forwarded on to the function when it is invoked.",
        "params": [
          {
            "name": "func",
            "description": "Function to delay `waitMS` amount of ms."
          },
          {
            "name": "wait",
            "description": "The amount of milliseconds to delay `fn`."
          },
          {
            "name": "args",
            "description": "Additional arguments to pass to `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "defer",
      "parameters": [
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Defers invoking the function until the current call stack has cleared, similar to using setTimeout\nwith a delay of 0. Useful for performing expensive computations or HTML rendering in chunks without\nblocking the UI thread from updating. If you pass the optional arguments, they will be forwarded on\nto the function when it is invoked.",
        "params": [
          {
            "name": "fn",
            "description": "The function to defer."
          },
          {
            "name": "arguments",
            "description": "Additional arguments to pass to `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "throttle",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "ThrottleSettings",
          "optional": true
        }
      ],
      "returnType": "T & Cancelable",
      "jsdoc": {
        "description": "Creates and returns a new, throttled version of the passed function, that, when invoked repeatedly,\nwill only actually call the original function at most once per every wait milliseconds. Useful for\nrate-limiting events that occur faster than you can keep up with.\nBy default, throttle will execute the function as soon as you call it for the first time, and,\nif you call it again any number of times during the wait period, as soon as that period is over.\nIf you'd like to disable the leading-edge call, pass {leading: false}, and if you'd like to disable\nthe execution on the trailing-edge, pass {trailing: false}.",
        "params": [
          {
            "name": "func",
            "description": "Function to throttle `waitMS` ms."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to wait before `fn` can be invoked again."
          },
          {
            "name": "options",
            "description": "Allows for disabling execution of the throttled function on either the leading or trailing edge."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "debounce",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "immediate",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "T & Cancelable",
      "jsdoc": {
        "description": "Creates and returns a new debounced version of the passed function that will postpone its execution\nuntil after wait milliseconds have elapsed since the last time it was invoked. Useful for implementing\nbehavior that should only happen after the input has stopped arriving. For example: rendering a preview\nof a Markdown comment, recalculating a layout after the window has stopped being resized, and so on.\n\nPass true for the immediate parameter to cause debounce to trigger the function on the leading instead\nof the trailing edge of the wait interval. Useful in circumstances like preventing accidental double\n-clicks on a \"submit\" button from firing a second time.",
        "params": [
          {
            "name": "fn",
            "description": "Function to debounce `waitMS` ms."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to wait before `fn` can be invoked again."
          },
          {
            "name": "immediate",
            "description": "True if `fn` should be invoked on the leading edge of `waitMS` instead of the trailing edge."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "once",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a version of the function that can only be called one time. Repeated calls to the modified\nfunction will have no effect, returning the value from the original call. Useful for initialization\nfunctions, instead of having to set a boolean flag and then check it later.",
        "params": [
          {
            "name": "fn",
            "description": "Function to only execute once."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "restArgs",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "starIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\nThis accumulates the arguments passed into an array, after a given index.",
        "deprecated": false
      }
    },
    {
      "name": "after",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Creates a version of the function that will only be run after first being called count times. Useful\nfor grouping asynchronous responses, where you want to be sure that all the async calls have finished,\nbefore proceeding.",
        "params": [
          {
            "name": "number",
            "description": "count Number of times to be called before actually executing."
          },
          {
            "name": "Function",
            "description": "fn The function to defer execution `count` times."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "before",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Creates a version of the function that can be called no more than count times.  The result of\nthe last function call is memoized and returned when count has been reached.",
        "params": [
          {
            "name": "number",
            "description": "count  The maxmimum number of times the function can be called."
          },
          {
            "name": "Function",
            "description": "fn The function to limit the number of times it can be called."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "wrap",
      "parameters": [
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        },
        {
          "name": "wrapper",
          "type": "(fn: Function, ...args: any[]) => any",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Wraps the first function inside of the wrapper function, passing it as the first argument. This allows\nthe wrapper to execute code before and after the function runs, adjust the arguments, and execute it\nconditionally.",
        "params": [
          {
            "name": "fn",
            "description": "Function to wrap."
          },
          {
            "name": "wrapper",
            "description": "The function that will wrap `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "negate",
      "parameters": [
        {
          "name": "predicate",
          "type": "(...args: any[]) => boolean",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => boolean",
      "jsdoc": {
        "description": "Returns a negated version of the pass-in predicate.",
        "params": [
          {
            "name": "",
            "description": "(...args: any[]) => boolean predicate"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "compose",
      "parameters": [
        {
          "name": "functions",
          "type": "Function[]",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Returns the composition of a list of functions, where each function consumes the return value of the\nfunction that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).",
        "params": [
          {
            "name": "functions",
            "description": "List of functions to compose."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "keys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "*********\nObjects *\n*********",
        "deprecated": false
      }
    },
    {
      "name": "allKeys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Retrieve all the names of object's own and inherited properties.",
        "params": [
          {
            "name": "object",
            "description": "Retrieve the key or property names from this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "values",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Return all of the values of the object's properties.",
        "params": [
          {
            "name": "object",
            "description": "Retrieve the values of all the properties on this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "mapObject",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "{ [K in keyof V]: IterateeResult<I, V[K]>; }",
      "jsdoc": {
        "description": "Like map, but for objects. Transform the value of each property in\nturn.",
        "params": [
          {
            "name": "object",
            "description": "The object to transform."
          },
          {
            "name": "iteratee",
            "description": "The iteratee to use to transform property values."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A new object with all of `object`'s property values\ntransformed through `iteratee`.",
        "deprecated": false
      }
    },
    {
      "name": "pairs",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "[Extract<keyof V, string>, TypeOfCollection<V, any>][]",
      "jsdoc": {
        "description": "Converts `object` into a list of [key, value] pairs. The opposite\nof the single-argument signature of `_.object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to convert."
          }
        ],
        "returns": "The list of [key, value] pairs from `object`.",
        "deprecated": false
      }
    },
    {
      "name": "invert",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Returns a copy of the object where the keys have become the values and the values the keys.\nFor this to work, all of your object's values should be unique and string serializable.",
        "params": [
          {
            "name": "object",
            "description": "Object to invert key/value pairs."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "functions",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns a sorted list of the names of every method in an object - that is to say,\nthe name of every function property of the object.",
        "params": [
          {
            "name": "object",
            "description": "Object to pluck all function property names from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "methods",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "extend",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "sources",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Copy all of the properties in the source objects over to the destination object, and return\nthe destination object. It's in-order, so the last source will override properties of the\nsame name in previous arguments.",
        "params": [
          {
            "name": "destination",
            "description": "Object to extend all the properties from `sources`."
          },
          {
            "name": "sources",
            "description": "Extends `destination` with all properties from these source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "extendOwn",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "source",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Like extend, but only copies own properties over to the destination object. (alias: assign)",
        "deprecated": false
      }
    },
    {
      "name": "assign",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "source",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Like extend, but only copies own properties over to the destination object. (alias: extendOwn)",
        "deprecated": false
      }
    },
    {
      "name": "findKey",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, any>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Extract<keyof V, string>",
      "jsdoc": {
        "description": "Similar to `findIndex` but for keys in objects. Returns the key\nwhere the `iteratee` truth test passes or undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The first element in `object` that passes the truth test or\nundefined if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "pick",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(K | K[])[]",
          "optional": false
        }
      ],
      "returnType": "_Pick<V, K>",
      "jsdoc": {
        "description": "Return a copy of `object` that is filtered to only have values for\nthe allowed keys (or array of keys).",
        "params": [
          {
            "name": "object",
            "description": "The object to pick specific keys in."
          },
          {
            "name": "keys",
            "description": "The keys to keep on `object`."
          }
        ],
        "returns": "A copy of `object` with only the `keys` properties.",
        "deprecated": false
      }
    },
    {
      "name": "omit",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(K | K[])[]",
          "optional": false
        }
      ],
      "returnType": "_Omit<V, K>",
      "jsdoc": {
        "description": "Return a copy of `object` that is filtered to omit the disallowed\nkeys (or array of keys).",
        "params": [
          {
            "name": "object",
            "description": "The object to omit specific keys from."
          },
          {
            "name": "keys",
            "description": "The keys to omit from `object`."
          }
        ],
        "returns": "A copy of `object` without the `keys` properties.",
        "deprecated": false
      }
    },
    {
      "name": "defaults",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Fill in null and undefined properties in object with values from the defaults objects,\nand return the object. As soon as the property is filled, further defaults will have no effect.",
        "params": [
          {
            "name": "object",
            "description": "Fill this object with default values."
          },
          {
            "name": "defaults",
            "description": "The default values to add to `object`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "create",
      "parameters": [
        {
          "name": "prototype",
          "type": "any",
          "optional": false
        },
        {
          "name": "props",
          "type": "object",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Creates an object that inherits from the given prototype object.\nIf additional properties are provided then they will be added to the\ncreated object.",
        "params": [
          {
            "name": "prototype",
            "description": "The prototype that the returned object will inherit from."
          },
          {
            "name": "props",
            "description": "Additional props added to the returned object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "clone",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Create a shallow-copied clone of the object.\nAny nested objects or arrays will be copied by reference, not duplicated.",
        "params": [
          {
            "name": "object",
            "description": "Object to clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "tap",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "intercepter",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Invokes interceptor with the object, and then returns object. The primary purpose of this method\nis to \"tap into\" a method chain, in order to perform operations on intermediate results within the chain.",
        "params": [
          {
            "name": "object",
            "description": "Argument to `interceptor`."
          },
          {
            "name": "intercepter",
            "description": "The function to modify `object` before continuing the method chain."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "has",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "key",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Does the object contain the given key? Identical to object.hasOwnProperty(key), but uses a safe\nreference to the hasOwnProperty function, in case it's been overridden accidentally.",
        "params": [
          {
            "name": "object",
            "description": "Object to check for `key`."
          },
          {
            "name": "key",
            "description": "The key to check for on `object`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "matches",
      "parameters": [
        {
          "name": "attrs",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "Predicate<T>",
      "jsdoc": {
        "description": "Returns a predicate function that will tell you if a passed in object contains all of the key/value properties present in attrs.",
        "params": [
          {
            "name": "attrs",
            "description": "Object with key values pair"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "matcher",
      "parameters": [
        {
          "name": "attrs",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "Predicate<T>",
      "jsdoc": {
        "description": "Returns a predicate function that will tell you if a passed in object contains all of the key/value properties present in attrs.",
        "params": [
          {
            "name": "attrs",
            "description": "Object with key values pair"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "get",
      "parameters": [
        {
          "name": "object",
          "type": "null",
          "optional": false
        },
        {
          "name": "path",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "undefined",
      "jsdoc": {
        "description": "Returns the specified property of `object`. `path` may be specified\nas a simple key, or as an array of object keys or array indexes,\nfor deep property fetching. If the property does not exist or is `undefined`,\nthe optional default is returned.",
        "params": [
          {
            "name": "object",
            "description": "The object that maybe contains the property."
          },
          {
            "name": "path",
            "description": "The path to the property on `object`."
          },
          {
            "name": "defaultValue",
            "description": "Default if not found."
          }
        ],
        "returns": "The item on the `object` or the `defaultValue`",
        "deprecated": false
      }
    },
    {
      "name": "property",
      "parameters": [
        {
          "name": "key",
          "type": "string | number | (string | number)[]",
          "optional": false
        }
      ],
      "returnType": "(object: any) => any",
      "jsdoc": {
        "description": "Returns a function that will itself return the key property of any passed-in object.",
        "params": [
          {
            "name": "key",
            "description": "Property of the object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "propertyOf",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "(key: string | number | (string | number)[]) => any",
      "jsdoc": {
        "description": "Returns a function that will itself return the value of a object key property.",
        "params": [
          {
            "name": "key",
            "description": "The object to get the property value from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isEqual",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs an optimized deep comparison between `object` and `other`\nto determine if they should be considered equal.",
        "params": [
          {
            "name": "object",
            "description": "Compare to `other`."
          },
          {
            "name": "other",
            "description": "Compare to `object`."
          }
        ],
        "returns": "True if `object` should be considered equal to `other`.",
        "deprecated": false
      }
    },
    {
      "name": "isEmpty",
      "parameters": [
        {
          "name": "collection",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `collection` contains no values.\nFor strings and array-like objects checks if the length property is\n0.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to check."
          }
        ],
        "returns": "True if `collection` has no elements.",
        "deprecated": false
      }
    },
    {
      "name": "isMatch",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "properties",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the keys and values in `properties` are contained in\n`object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          },
          {
            "name": "properties",
            "description": "The properties to check for in `object`."
          }
        ],
        "returns": "True if all keys and values in `properties` are also in\n`object`.",
        "deprecated": false
      }
    },
    {
      "name": "isElement",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a DOM element.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a DOM element, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isArray",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Array.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Array, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isArrayBuffer",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an ArrayBuffer.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an ArrayBuffer, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isDataView",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a DataView.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a DataView, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isTypedArray",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a TypedArray.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a TypedArray, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isSymbol",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Symbol.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Symbol, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isObject",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Object. Note that JavaScript arrays\nand functions are objects,\nwhile (normal) strings and numbers are not.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Object, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isArguments",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Arguments object.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Arguments object, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isFunction",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Function.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Function, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isError",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Error.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Error, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isString",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a String.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a String, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isNumber",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Number (including NaN).",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Number, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isFinite",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a finite Number.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a finite Number.",
        "deprecated": false
      }
    },
    {
      "name": "isBoolean",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Boolean.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Boolean, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isDate",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Date.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Date, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isRegExp",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a RegExp.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a RegExp, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isNaN",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is NaN.\nNote: this is not the same as the native isNaN function,\nwhich will also return true if the variable is undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is NaN, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isNull",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is null.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is null, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isUndefined",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is undefined, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isSet",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Set.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Set, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isWeakSet",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a WeakSet.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a WeakSet, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isMap",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Map.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Map, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "isWeakMap",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a WeakMap.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a WeakMap, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "toPath",
      "parameters": [
        {
          "name": "path",
          "type": "P",
          "optional": false
        }
      ],
      "returnType": "P extends readonly (string | number)[] ? P : P extends string | number ? [P] : never",
      "jsdoc": {
        "description": "Ensures that path is an array.",
        "params": [
          {
            "name": "path",
            "description": " 1. If path is a string, it is wrapped in a single-element array;\n 2. if it is an array already, it is returned unmodified."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "noConflict",
      "parameters": [],
      "returnType": "any",
      "jsdoc": {
        "description": "*********\nUtility *\n*********",
        "deprecated": false
      }
    },
    {
      "name": "identity",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Returns the same value that is used as the argument. In math: f(x) = x\nThis function looks useless, but is used throughout Underscore as a default iterator.",
        "params": [
          {
            "name": "value",
            "description": "Identity of this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "constant",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "() => T",
      "jsdoc": {
        "description": "Creates a function that returns the same value that is used as the argument of _.constant",
        "params": [
          {
            "name": "value",
            "description": "Identity of this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "noop",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Returns undefined irrespective of the arguments passed to it.  Useful as the default\nfor optional callback arguments.\nNote there is no way to indicate a 'undefined' return, so it is currently typed as void.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "times",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "iterator",
          "type": "(n: number) => TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "Invokes the given iterator function n times.\nEach invocation of iterator is called with an index argument",
        "params": [
          {
            "name": "n",
            "description": "Number of times to invoke `iterator`."
          },
          {
            "name": "iterator",
            "description": "Function iterator to invoke `n` times."
          },
          {
            "name": "context",
            "description": "`this` object in `iterator`, optional."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "random",
      "parameters": [
        {
          "name": "max",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a random integer between min and max, inclusive. If you only pass one argument,\nit will return a number between 0 and that number.",
        "params": [
          {
            "name": "max",
            "description": "The maximum random number."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "mixin",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Allows you to extend Underscore with your own utility functions. Pass a hash of\n{name: function} definitions to have your functions added to the Underscore object,\nas well as the OOP wrapper.",
        "params": [
          {
            "name": "object",
            "description": "Mixin object containing key/function pairs to add to the Underscore object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "iteratee",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "A mostly-internal function to generate callbacks that can be applied to each element\nin a collection, returning the desired result -- either identity, an arbitrary callback,\na property matcher, or a propetery accessor.",
        "params": [
          {
            "name": "string",
            "description": "|Function|Object value The value to iterate over, usually the key."
          },
          {
            "name": "any",
            "description": "context"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "uniqueId",
      "parameters": [
        {
          "name": "prefix",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Generate a globally-unique id for client-side models or DOM elements that need one.\nIf prefix is passed, the id will be appended to it. Without prefix, returns an integer.",
        "params": [
          {
            "name": "prefix",
            "description": "A prefix string to start the unique ID with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "escape",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Escapes a string for insertion into HTML, replacing &, <, >, \", ', and / characters.",
        "params": [
          {
            "name": "str",
            "description": "Raw string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unescape",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "The opposite of escape, replaces &amp;, &lt;, &gt;, &quot;, and &#x27; with their unescaped counterparts.",
        "params": [
          {
            "name": "str",
            "description": "HTML escaped string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "result",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "property",
          "type": "string",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "If the value of the named property is a function then invoke it; otherwise, return it.",
        "params": [
          {
            "name": "object",
            "description": "Object to maybe invoke function `property` on."
          },
          {
            "name": "property",
            "description": "The function by name to invoke on `object`."
          },
          {
            "name": "defaultValue",
            "description": "The value to be returned in case `property` doesn't exist or is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "template",
      "parameters": [
        {
          "name": "templateString",
          "type": "string",
          "optional": false
        },
        {
          "name": "settings",
          "type": "TemplateSettings",
          "optional": true
        }
      ],
      "returnType": "CompiledTemplate",
      "jsdoc": {
        "description": "Compiles JavaScript templates into functions that can be evaluated for rendering. Useful\nfor rendering complicated bits of HTML from JSON data sources. Template functions can both\ninterpolate variables, using <%= ... %>, as well as execute arbitrary JavaScript code, with\n<% ... %>. If you wish to interpolate a value, and have it be HTML-escaped, use <%- ... %> When\nyou evaluate a template function, pass in a data object that has properties corresponding to\nthe template's free variables. If you're writing a one-off, you can pass the data object as\nthe second parameter to template in order to render immediately instead of returning a template\nfunction. The settings argument should be a hash containing any _.templateSettings that should\nbe overridden.",
        "params": [
          {
            "name": "templateString",
            "description": "Underscore HTML template."
          },
          {
            "name": "data",
            "description": "Data to use when compiling `templateString`."
          },
          {
            "name": "settings",
            "description": "Settings to use while compiling."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "now",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns an integer timestamp for the current time, using the fastest method available in the runtime. Useful for implementing timing/animation functions.",
        "deprecated": false
      }
    },
    {
      "name": "chain",
      "parameters": [
        {
          "name": "value",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "_Chain<TypeOfCollection<V, never>, V>",
      "jsdoc": {
        "description": "**********\nChaining *\n**********",
        "deprecated": false
      }
    },
    {
      "name": "_.each",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "CollectionIterator<TypeOfCollection<V, never>, void, V>",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "V",
      "jsdoc": {
        "description": "*************\nCollections *\n*************",
        "deprecated": false
      }
    },
    {
      "name": "_.forEach",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "CollectionIterator<TypeOfCollection<V, never>, void, V>",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "V",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.map",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "IterateeResult<I, TypeOfCollection<V, never>>[]",
      "jsdoc": {
        "description": "Produces a new array of values by mapping each value in `collection`\nthrough a transformation `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to transform."
          },
          {
            "name": "iteratee",
            "description": "The iteratee to use to transform each item in\n`collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The mapped result.",
        "deprecated": false
      }
    },
    {
      "name": "_.collect",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "IterateeResult<I, TypeOfCollection<V, never>>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.reduce",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "Also known as inject and foldl, reduce boils down a `collection` of\nvalues into a single value. `memo` is the initial state of the\nreduction, and each successive step of it should be returned by\n`iteratee`.\n\nIf no memo is passed to the initial invocation of reduce, `iteratee`\nis not invoked on the first element of `collection`. The first\nelement is instead passed as the memo in the invocation of\n`iteratee` on the next element in `collection`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to reduce."
          },
          {
            "name": "iteratee",
            "description": "The function to call on each iteration to reduce the\ncollection."
          },
          {
            "name": "memo",
            "description": "The initial reduce state or undefined to use the first\nitem in `collection` as initial state."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The reduced result.",
        "deprecated": false
      }
    },
    {
      "name": "_.inject",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.foldl",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.reduceRight",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "The right-associative version of reduce.\n\nThis is not as useful in JavaScript as it would be in a language\nwith lazy evaluation.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to reduce."
          },
          {
            "name": "iteratee",
            "description": "The function to call on each iteration to reduce the\ncollection."
          },
          {
            "name": "memo",
            "description": "The initial reduce state or undefined to use the first\nitem in `collection` as the initial state."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The reduced result.",
        "deprecated": false
      }
    },
    {
      "name": "_.foldr",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>",
          "optional": false
        },
        {
          "name": "memo",
          "type": "TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.find",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning the first one\nthat passes a truth test (`iteratee`), or undefined if no value\npasses the test. The function returns as soon as it finds an\nacceptable element, and doesn't traverse the entire collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to search."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The first element in `collection` that passes the truth\ntest or undefined if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "_.detect",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.filter",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning an array of\nall the values that pass a truth test (`iteratee`).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to filter."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The set of values that pass the truth test.",
        "deprecated": false
      }
    },
    {
      "name": "_.select",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.where",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "properties",
          "type": "Partial<TypeOfCollection<V, never>>",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Looks through each value in `collection`, returning an array of all\nthe elements that match the key-value pairs listed in `properties`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find elements that\nmatch `properties`."
          },
          {
            "name": "properties",
            "description": "The properties to check for on the elements within\n`collection`."
          }
        ],
        "returns": "The elements in `collection` that match `properties`.",
        "deprecated": false
      }
    },
    {
      "name": "_.findWhere",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "properties",
          "type": "Partial<TypeOfCollection<V, never>>",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Looks through `collection` and returns the first value that matches\nall of the key-value pairs listed in `properties`. If no match is\nfound, or if list is empty, undefined will be returned.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find an element that\nmatches `properties`."
          },
          {
            "name": "properties",
            "description": "The properties to check for on the elements within\n`collection`."
          }
        ],
        "returns": "The first element in `collection` that matches `properties`\nor undefined if no match is found.",
        "deprecated": false
      }
    },
    {
      "name": "_.reject",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns the values in `collection` without the elements that pass a\ntruth test (`iteratee`).\nThe opposite of filter.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to filter."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The set of values that fail the truth test.",
        "deprecated": false
      }
    },
    {
      "name": "_.every",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if all of the values in `collection` pass the\n`iteratee` truth test. Short-circuits and stops traversing\n`collection` if a false element is found.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "True if all elements pass the truth test, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.all",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.some",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if any of the values in `collection` pass the\n`iteratee` truth test. Short-circuits and stops traversing\n`collection` if a true element is found.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "True if any element passed the truth test, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.any",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.contains",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the value is present in `collection`. Uses indexOf\ninternally, if `collection` is a List. Use `fromIndex` to start your\nsearch at a given index.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to check for `value`."
          },
          {
            "name": "value",
            "description": "The value to check `collection` for."
          },
          {
            "name": "fromIndex",
            "description": "The index to start searching from, optional,\ndefault = 0, only used when `collection` is a List."
          }
        ],
        "returns": "True if `value` is present in `collection` after\n`fromIndex`, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.include",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.includes",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.invoke",
      "parameters": [
        {
          "name": "list",
          "type": "Collection<any>",
          "optional": false
        },
        {
          "name": "methodName",
          "type": "string",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any[]",
      "jsdoc": {
        "description": "Calls the method named by `methodName` on each value in\n`collection`. Any extra arguments passed to invoke will be forwarded\non to the method invocation.",
        "params": [
          {
            "name": "collection",
            "description": "The collection of elements to invoke `methodName`\non."
          },
          {
            "name": "methodName",
            "description": "The name of the method to call on each element in\n`collection`."
          },
          {
            "name": "args",
            "description": "Additional arguments to pass to method `methodName`."
          }
        ],
        "returns": "An array containing the result of the method call for each\nitem in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.pluck",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "propertyName",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]",
      "jsdoc": {
        "description": "A convenient version of what is perhaps the most common use-case for\nmap: extracting a list of property values.",
        "params": [
          {
            "name": "collection",
            "description": "The collection of items."
          },
          {
            "name": "propertyName",
            "description": "The name of a specific property to retrieve from\nall items in `collection`."
          }
        ],
        "returns": "The set of values for the specified `propertyName` for each\nitem in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.max",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number | TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Returns the maximum value in `collection`. If an `iteratee` is\nprovided, it will be used on each element to generate the criterion\nby which the element is ranked. -Infinity is returned if list is\nempty. Non-numerical values returned by `iteratee` will be ignored.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find the maximum value."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that provides the criterion by which\neach element is ranked, optional if evaluating a collection of\nnumbers."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The maximum element within `collection` or -Infinity if\n`collection` is empty.",
        "deprecated": false
      }
    },
    {
      "name": "_.min",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number | TypeOfCollection<V, never>",
      "jsdoc": {
        "description": "Returns the minimum value in `collection`. If an `iteratee` is\nprovided, it will be used on each element to generate the criterion\nby which the element is ranked. Infinity is returned if list is\nempty. Non-numerical values returned by `iteratee` will be ignored.",
        "params": [
          {
            "name": "collection",
            "description": "The collection in which to find the minimum value."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that provides the criterion by which\neach element is ranked, optional if evaluating a collection of\nnumbers."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The minimum element within `collection` or Infinity if\n`collection` is empty.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns a (stably) sorted copy of `collection`, ranked in ascending\norder by the results of running each value through `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sort."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to sort by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A sorted copy of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.groupBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<TypeOfCollection<V, never>[]>",
      "jsdoc": {
        "description": "Splits `collection` into sets that are grouped by the result of\nrunning each value through `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to group."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to group by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary with the group names provided by `iteratee` as\nproperties where each property contains the grouped elements from\n`collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.indexBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<TypeOfCollection<V, never>>",
      "jsdoc": {
        "description": "Given a `collection` and an `iteratee` function that returns a key\nfor each element in `collection`, returns an object that acts as an\nindex of each item.  Just like `groupBy`, but for when you know your\nkeys are unique.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to index."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to index by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary where each item in `collection` is assigned to\nthe property designated by `iteratee`.",
        "deprecated": false
      }
    },
    {
      "name": "_.countBy",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, string | number, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Dictionary<number>",
      "jsdoc": {
        "description": "Sorts `collection` into groups and returns a count for the number of\nobjects in each group. Similar to `groupBy`, but instead of\nreturning a list of values, returns a count for the number of values\nin that group.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to count."
          },
          {
            "name": "iteratee",
            "description": "An iteratee that provides the value to count by for\neach item in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A dictionary with the group names provided by `iteratee` as\nproperties where each property contains the count of the grouped\nelements from `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.shuffle",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Returns a shuffled copy of `collection`, using a version of the\nFisher-Yates shuffle.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to shuffle."
          }
        ],
        "returns": "A shuffled copy of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sample",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Produce a random sample from `collection`. Pass a number to return\n`n` random elements from `collection`. Otherwise a single random\nitem will be returned.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          },
          {
            "name": "n",
            "description": "The number of elements to sample from `collection`."
          }
        ],
        "returns": "A random sample of `n` elements from `collection` or a\nsingle element if `n` is not specified.",
        "deprecated": false
      }
    },
    {
      "name": "_.toArray",
      "parameters": [
        {
          "name": "collection",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfCollection<V, never>[]",
      "jsdoc": {
        "description": "Creates a real Array from `collection` (anything that can be\niterated over). Useful for transmuting the arguments object.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to transform into an array."
          }
        ],
        "returns": "An array containing the elements of `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.size",
      "parameters": [
        {
          "name": "collection",
          "type": "Collection<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines the number of values in `collection`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to determine the number of values\nfor."
          }
        ],
        "returns": "The number of values in `collection`.",
        "deprecated": false
      }
    },
    {
      "name": "_.partition",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "[TypeOfCollection<V, never>[], TypeOfCollection<V, never>[]]",
      "jsdoc": {
        "description": "Splits `collection` into two arrays: one whose elements all satisfy\n`iteratee` and one whose elements all do not satisfy `iteratee`.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to partition."
          },
          {
            "name": "iteratee",
            "description": "The iteratee that defines the partitioning scheme\nfor each element in `collection`."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "An array composed of two elements, where the first element\ncontains the elements in `collection` that satisfied the predicate\nand the second element contains the elements that did not.",
        "deprecated": false
      }
    },
    {
      "name": "_.first",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "********\nArrays *\n********",
        "deprecated": false
      }
    },
    {
      "name": "_.head",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.take",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.initial",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns everything but the last entry of `list`. Especially useful\non the arguments object. Pass `n` to exclude the last\n`n` elements from the result.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "n",
            "description": "The number of elements from the end of `list` to omit,\noptional, default = 1."
          }
        ],
        "returns": "The elements of `list` with the last `n` items omitted.",
        "deprecated": false
      }
    },
    {
      "name": "_.last",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>",
      "jsdoc": {
        "description": "Returns the last element of `list`. Passing `n` will return the last\n`n` elements of `list`.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "n",
            "description": "The number of elements to retrieve, optional."
          }
        ],
        "returns": "The last `n` elements of `list` or the last element if `n`\nis omitted.",
        "deprecated": false
      }
    },
    {
      "name": "_.rest",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns the rest of the elements in `list`. Pass an `index` to\nreturn the values of the list from that index onward.",
        "params": [
          {
            "name": "list",
            "description": "The list to retrieve elements from."
          },
          {
            "name": "index",
            "description": "The index to start retrieving elements from, optional,\ndefault = 1."
          }
        ],
        "returns": "The elements of `list` from `index` to the end of the list.",
        "deprecated": false
      }
    },
    {
      "name": "_.tail",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.drop",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "index",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.compact",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "Exclude<TypeOfList<V>, AnyFalsy>[]",
      "jsdoc": {
        "description": "Returns a copy of `list` with all falsy values removed. In\nJavaScript, false, null, 0, \"\", undefined and NaN are all falsy.",
        "params": [
          {
            "name": "list",
            "description": "The list to compact."
          }
        ],
        "returns": "An array containing the elements of `list` without falsy\nvalues.",
        "deprecated": false
      }
    },
    {
      "name": "_.flatten",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "depth",
          "type": "true | 1",
          "optional": false
        }
      ],
      "returnType": "ListItemOrSelf<TypeOfList<V>>[]",
      "jsdoc": {
        "description": "Flattens a nested `list` (the nesting can be to any depth). If you\npass true or 1 as the depth, the `list` will only be flattened a\nsingle level. Passing a greater number will cause the flattening to\ndescend deeper into the nesting hierarchy. Omitting the depth\nargument, or passing false or Infinity, flattens the `list` all the\nway to the deepest nesting level.",
        "params": [
          {
            "name": "list",
            "description": "The list to flatten."
          },
          {
            "name": "depth",
            "description": "True to only flatten one level, optional,\ndefault = false."
          }
        ],
        "returns": "The flattened `list`.",
        "deprecated": false
      }
    },
    {
      "name": "_.without",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "values",
          "type": "TypeOfList<V>[]",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Returns a copy of `list` with all instances of `values` removed.",
        "params": [
          {
            "name": "list",
            "description": "The list to exclude `values` from."
          },
          {
            "name": "values",
            "description": "The values to exclude from `list`."
          }
        ],
        "returns": "An array that contains all elements of `list` except for\n`values`.",
        "deprecated": false
      }
    },
    {
      "name": "_.union",
      "parameters": [
        {
          "name": "lists",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Computes the union of the passed-in `lists`: the list of unique\nitems, examined in order from first list to last list, that are\npresent in one or more of the lists.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to compute the union of."
          }
        ],
        "returns": "The union of elements within `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "_.intersection",
      "parameters": [
        {
          "name": "lists",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Computes the list of values that are the intersection of the\npassed-in `lists`. Each value in the result is present in each of\nthe lists.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to compute the intersection of."
          }
        ],
        "returns": "The intersection of elements within the `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "_.difference",
      "parameters": [
        {
          "name": "list",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "others",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Similar to without, but returns the values from `list` that are not\npresent in `others`.",
        "params": [
          {
            "name": "list",
            "description": "The starting list."
          },
          {
            "name": "others",
            "description": "The lists of values to exclude from `list`."
          }
        ],
        "returns": "The contents of `list` without the values in `others`.",
        "deprecated": false
      }
    },
    {
      "name": "_.uniq",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "isSorted",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "Produces a duplicate-free version of `list`, using === to test\nobject equality. If you know in advance that `list` is sorted,\npassing true for isSorted will run a much faster algorithm. If you\nwant to compute unique items based on a transformation, pass an\niteratee function.",
        "params": [
          {
            "name": "list",
            "description": "The list to remove duplicates from."
          },
          {
            "name": "isSorted",
            "description": "True if `list` is already sorted, optional,\ndefault = false."
          },
          {
            "name": "iteratee",
            "description": "Transform the elements of `list` before comparisons\nfor uniqueness."
          },
          {
            "name": "context",
            "description": "'this' object in `iteratee`, optional."
          }
        ],
        "returns": "An array containing only the unique elements in `list`.",
        "deprecated": false
      }
    },
    {
      "name": "_.unique",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "isSorted",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TypeOfList<V>[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.zip",
      "parameters": [],
      "returnType": "[]",
      "jsdoc": {
        "description": "Merges together the values of each of the `lists` with the values at\nthe corresponding position. Useful when you have separate data\nsources that are coordinated through matching list indexes.",
        "params": [
          {
            "name": "lists",
            "description": "The lists to zip."
          }
        ],
        "returns": "The zipped version of `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "_.unzip",
      "parameters": [
        {
          "name": "lists",
          "type": "List<[T, U, V]>",
          "optional": false
        }
      ],
      "returnType": "[T[], U[], V[]]",
      "jsdoc": {
        "description": "The opposite of zip. Given a list of lists, returns a series of new\narrays, the first of which contains all of the first elements in the\ninput lists, the second of which contains all of the second\nelements, and so on. (alias: transpose)",
        "params": [
          {
            "name": "lists",
            "description": "The lists to unzip."
          }
        ],
        "returns": "The unzipped version of `lists`.",
        "deprecated": false
      }
    },
    {
      "name": "_.transpose",
      "parameters": [
        {
          "name": "lists",
          "type": "List<[T, U, V]>",
          "optional": false
        }
      ],
      "returnType": "[T[], U[], V[]]",
      "jsdoc": null
    },
    {
      "name": "_.object",
      "parameters": [
        {
          "name": "list",
          "type": "TList",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<TValue>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<TValue>",
      "jsdoc": {
        "description": "Converts lists into objects. Pass either a single `list` of\n[key, value] pairs, or a `list` of keys and a list of `values`.\nPassing by pairs is the reverse of pairs. If duplicate keys exist,\nthe last value wins.",
        "params": [
          {
            "name": "list",
            "description": "A list of [key, value] pairs or a list of keys."
          },
          {
            "name": "values",
            "description": "If `list` is a list of keys, a list of values\ncorresponding to those keys."
          }
        ],
        "returns": "An object comprised of the provided keys and values.",
        "deprecated": false
      }
    },
    {
      "name": "_.indexOf",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "isSortedOrFromIndex",
          "type": "number | boolean",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index at which `value` can be found in `list`, or -1 if\n`value` is not present. If you're working with a large list and you\nknow that the list is already sorted, pass true for\n`isSortedOrFromIndex` to use a faster binary search...or, pass a\nnumber in order to look for the first matching value in the list\nafter the given index.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of `value`."
          },
          {
            "name": "value",
            "description": "The value to search for within `list`."
          },
          {
            "name": "isSortedOrFromIndex",
            "description": "True if `list` is already sorted OR the\nstarting index for the search, optional."
          }
        ],
        "returns": "The index of the first occurrence of `value` within `list`\nor -1 if `value` is not found.",
        "deprecated": false
      }
    },
    {
      "name": "_.lastIndexOf",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the last occurrence of `value` in `list`, or -1\nif `value` is not present. Pass `fromIndex` to start your search at\na given index.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the last occurrence of `value`."
          },
          {
            "name": "value",
            "description": "The value to search for within `list`."
          },
          {
            "name": "fromIndex",
            "description": "The starting index for the search, optional."
          }
        ],
        "returns": "The index of the last occurrence of `value` within `list`\nor -1 if `value` is not found.",
        "deprecated": false
      }
    },
    {
      "name": "_.findIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the first index of an element in `list` where the `iteratee`\ntruth test passes, otherwise returns -1.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of the first element\nthat passes the truth test."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index of the first element in `list` where the\ntruth test passes or -1 if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "_.findLastIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the last index of an element in `list` where the `iteratee`\ntruth test passes, otherwise returns -1.",
        "params": [
          {
            "name": "list",
            "description": "The list to search for the index of the last element\nthat passes the truth test."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index of the last element in `list` where the\ntruth test passes or -1 if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedIndex",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "value",
          "type": "TypeOfList<V>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, any, TypeOfCollection<V, never>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Uses a binary search to determine the lowest index at which the\nvalue should be inserted into `list` in order to maintain `list`'s\nsorted order. If an iteratee is provided, it will be used to compute\nthe sort ranking of each value, including the value you pass.",
        "params": [
          {
            "name": "list",
            "description": "A sorted list."
          },
          {
            "name": "value",
            "description": "The value to determine an insert index for to mainain\nthe sorting in `list`."
          },
          {
            "name": "iteratee",
            "description": "Iteratee to compute the sort ranking of each\nelement including `value`, optional."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The index where `value` should be inserted into `list`.",
        "deprecated": false
      }
    },
    {
      "name": "_.range",
      "parameters": [
        {
          "name": "startOrStop",
          "type": "number",
          "optional": false
        },
        {
          "name": "stop",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "A function to create flexibly-numbered lists of integers, handy for\n`each` and `map` loops. Returns a list of integers from\n`startOrStop` (inclusive) to `stop` (exclusive), incremented\n(or decremented) by `step`. Note that ranges that `stop` before they\n`start` are considered to be zero-length instead of negative - if\nyou'd like a negative range, use a negative `step`.\n\nIf `stop` is not specified, `startOrStop` will be the number to stop\nat and the default start of 0 will be used.",
        "params": [
          {
            "name": "startOrStop",
            "description": "If `stop` is specified, the number to start at.\nOtherwise, this is the number to stop at and the default start of 0\nwill be used."
          },
          {
            "name": "stop",
            "description": "The number to stop at."
          },
          {
            "name": "step",
            "description": "The number to count up by each iteration, optional,\ndefault = 1."
          }
        ],
        "returns": "An array of numbers from start to `stop` with increments\nof `step`.",
        "deprecated": false
      }
    },
    {
      "name": "_.chunk",
      "parameters": [
        {
          "name": "list",
          "type": "V",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "TypeOfList<V>[][]",
      "jsdoc": {
        "description": "Chunks `list` into multiple arrays, each containing `length` or\nfewer items.",
        "params": [
          {
            "name": "list",
            "description": "The list to chunk."
          },
          {
            "name": "length",
            "description": "The maximum size of the chunks."
          }
        ],
        "returns": "The contents of `list` in chunks no greater than `length`\nin size.",
        "deprecated": false
      }
    },
    {
      "name": "_.bind",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "() => any",
      "jsdoc": {
        "description": "***********\nFunctions *\n***********",
        "deprecated": false
      }
    },
    {
      "name": "_.bindAll",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "methodNames",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Binds a number of methods on the object, specified by methodNames, to be run in the context of that object\nwhenever they are invoked. Very handy for binding functions that are going to be used as event handlers,\nwhich would otherwise be invoked with a fairly useless this. If no methodNames are provided, all of the\nobject's function properties will be bound to it.",
        "params": [
          {
            "name": "object",
            "description": "The object to bind the methods `methodName` to."
          },
          {
            "name": "methodNames",
            "description": "The methods to bind to `object`, optional and if not provided all of `object`'s\nmethods are bound."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.partial",
      "parameters": [
        {
          "name": "fn",
          "type": "(p1: T1) => T2",
          "optional": false
        },
        {
          "name": "p1",
          "type": "T1",
          "optional": false
        }
      ],
      "returnType": "() => T2",
      "jsdoc": {
        "description": "Partially apply a function by filling in any number of its arguments, without changing its dynamic this value.\nA close cousin of bind.  You may pass _ in your list of arguments to specify an argument that should not be\npre-filled, but left open to supply at call-time.",
        "params": [
          {
            "name": "fn",
            "description": "Function to partially fill in arguments."
          },
          {
            "name": "arguments",
            "description": "The partial arguments."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.memoize",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        },
        {
          "name": "hashFn",
          "type": "(...args: any[]) => string",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Memoizes a given function by caching the computed result. Useful for speeding up slow-running computations.\nIf passed an optional hashFunction, it will be used to compute the hash key for storing the result, based\non the arguments to the original function. The default hashFunction just uses the first argument to the\nmemoized function as the key.",
        "params": [
          {
            "name": "fn",
            "description": "Computationally expensive function that will now memoized results."
          },
          {
            "name": "hashFn",
            "description": "Hash function for storing the result of `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.delay",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Much like setTimeout, invokes function after wait milliseconds. If you pass the optional arguments,\nthey will be forwarded on to the function when it is invoked.",
        "params": [
          {
            "name": "func",
            "description": "Function to delay `waitMS` amount of ms."
          },
          {
            "name": "wait",
            "description": "The amount of milliseconds to delay `fn`."
          },
          {
            "name": "args",
            "description": "Additional arguments to pass to `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.defer",
      "parameters": [
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Defers invoking the function until the current call stack has cleared, similar to using setTimeout\nwith a delay of 0. Useful for performing expensive computations or HTML rendering in chunks without\nblocking the UI thread from updating. If you pass the optional arguments, they will be forwarded on\nto the function when it is invoked.",
        "params": [
          {
            "name": "fn",
            "description": "The function to defer."
          },
          {
            "name": "arguments",
            "description": "Additional arguments to pass to `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.throttle",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "ThrottleSettings",
          "optional": true
        }
      ],
      "returnType": "T & Cancelable",
      "jsdoc": {
        "description": "Creates and returns a new, throttled version of the passed function, that, when invoked repeatedly,\nwill only actually call the original function at most once per every wait milliseconds. Useful for\nrate-limiting events that occur faster than you can keep up with.\nBy default, throttle will execute the function as soon as you call it for the first time, and,\nif you call it again any number of times during the wait period, as soon as that period is over.\nIf you'd like to disable the leading-edge call, pass {leading: false}, and if you'd like to disable\nthe execution on the trailing-edge, pass {trailing: false}.",
        "params": [
          {
            "name": "func",
            "description": "Function to throttle `waitMS` ms."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to wait before `fn` can be invoked again."
          },
          {
            "name": "options",
            "description": "Allows for disabling execution of the throttled function on either the leading or trailing edge."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.debounce",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "immediate",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "T & Cancelable",
      "jsdoc": {
        "description": "Creates and returns a new debounced version of the passed function that will postpone its execution\nuntil after wait milliseconds have elapsed since the last time it was invoked. Useful for implementing\nbehavior that should only happen after the input has stopped arriving. For example: rendering a preview\nof a Markdown comment, recalculating a layout after the window has stopped being resized, and so on.\n\nPass true for the immediate parameter to cause debounce to trigger the function on the leading instead\nof the trailing edge of the wait interval. Useful in circumstances like preventing accidental double\n-clicks on a \"submit\" button from firing a second time.",
        "params": [
          {
            "name": "fn",
            "description": "Function to debounce `waitMS` ms."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to wait before `fn` can be invoked again."
          },
          {
            "name": "immediate",
            "description": "True if `fn` should be invoked on the leading edge of `waitMS` instead of the trailing edge."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.once",
      "parameters": [
        {
          "name": "fn",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a version of the function that can only be called one time. Repeated calls to the modified\nfunction will have no effect, returning the value from the original call. Useful for initialization\nfunctions, instead of having to set a boolean flag and then check it later.",
        "params": [
          {
            "name": "fn",
            "description": "Function to only execute once."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.restArgs",
      "parameters": [
        {
          "name": "func",
          "type": "Function",
          "optional": false
        },
        {
          "name": "starIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\nThis accumulates the arguments passed into an array, after a given index.",
        "deprecated": false
      }
    },
    {
      "name": "_.after",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Creates a version of the function that will only be run after first being called count times. Useful\nfor grouping asynchronous responses, where you want to be sure that all the async calls have finished,\nbefore proceeding.",
        "params": [
          {
            "name": "number",
            "description": "count Number of times to be called before actually executing."
          },
          {
            "name": "Function",
            "description": "fn The function to defer execution `count` times."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.before",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Creates a version of the function that can be called no more than count times.  The result of\nthe last function call is memoized and returned when count has been reached.",
        "params": [
          {
            "name": "number",
            "description": "count  The maxmimum number of times the function can be called."
          },
          {
            "name": "Function",
            "description": "fn The function to limit the number of times it can be called."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.wrap",
      "parameters": [
        {
          "name": "fn",
          "type": "Function",
          "optional": false
        },
        {
          "name": "wrapper",
          "type": "(fn: Function, ...args: any[]) => any",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Wraps the first function inside of the wrapper function, passing it as the first argument. This allows\nthe wrapper to execute code before and after the function runs, adjust the arguments, and execute it\nconditionally.",
        "params": [
          {
            "name": "fn",
            "description": "Function to wrap."
          },
          {
            "name": "wrapper",
            "description": "The function that will wrap `fn`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.negate",
      "parameters": [
        {
          "name": "predicate",
          "type": "(...args: any[]) => boolean",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => boolean",
      "jsdoc": {
        "description": "Returns a negated version of the pass-in predicate.",
        "params": [
          {
            "name": "",
            "description": "(...args: any[]) => boolean predicate"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.compose",
      "parameters": [
        {
          "name": "functions",
          "type": "Function[]",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "Returns the composition of a list of functions, where each function consumes the return value of the\nfunction that follows. In math terms, composing the functions f(), g(), and h() produces f(g(h())).",
        "params": [
          {
            "name": "functions",
            "description": "List of functions to compose."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.keys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "*********\nObjects *\n*********",
        "deprecated": false
      }
    },
    {
      "name": "_.allKeys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Retrieve all the names of object's own and inherited properties.",
        "params": [
          {
            "name": "object",
            "description": "Retrieve the key or property names from this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.values",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Return all of the values of the object's properties.",
        "params": [
          {
            "name": "object",
            "description": "Retrieve the values of all the properties on this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.mapObject",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "I",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "{ [K in keyof V]: IterateeResult<I, V[K]>; }",
      "jsdoc": {
        "description": "Like map, but for objects. Transform the value of each property in\nturn.",
        "params": [
          {
            "name": "object",
            "description": "The object to transform."
          },
          {
            "name": "iteratee",
            "description": "The iteratee to use to transform property values."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "A new object with all of `object`'s property values\ntransformed through `iteratee`.",
        "deprecated": false
      }
    },
    {
      "name": "_.pairs",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "[Extract<keyof V, string>, TypeOfCollection<V, any>][]",
      "jsdoc": {
        "description": "Converts `object` into a list of [key, value] pairs. The opposite\nof the single-argument signature of `_.object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to convert."
          }
        ],
        "returns": "The list of [key, value] pairs from `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.invert",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Returns a copy of the object where the keys have become the values and the values the keys.\nFor this to work, all of your object's values should be unique and string serializable.",
        "params": [
          {
            "name": "object",
            "description": "Object to invert key/value pairs."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.functions",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns a sorted list of the names of every method in an object - that is to say,\nthe name of every function property of the object.",
        "params": [
          {
            "name": "object",
            "description": "Object to pluck all function property names from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.methods",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.extend",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "sources",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Copy all of the properties in the source objects over to the destination object, and return\nthe destination object. It's in-order, so the last source will override properties of the\nsame name in previous arguments.",
        "params": [
          {
            "name": "destination",
            "description": "Object to extend all the properties from `sources`."
          },
          {
            "name": "sources",
            "description": "Extends `destination` with all properties from these source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.extendOwn",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "source",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Like extend, but only copies own properties over to the destination object. (alias: assign)",
        "deprecated": false
      }
    },
    {
      "name": "_.assign",
      "parameters": [
        {
          "name": "destination",
          "type": "any",
          "optional": false
        },
        {
          "name": "source",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Like extend, but only copies own properties over to the destination object. (alias: extendOwn)",
        "deprecated": false
      }
    },
    {
      "name": "_.findKey",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "Iteratee<V, boolean, TypeOfCollection<V, any>>",
          "optional": true
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Extract<keyof V, string>",
      "jsdoc": {
        "description": "Similar to `findIndex` but for keys in objects. Returns the key\nwhere the `iteratee` truth test passes or undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "iteratee",
            "description": "The truth test to apply."
          },
          {
            "name": "context",
            "description": "`this` object in `iteratee`, optional."
          }
        ],
        "returns": "The first element in `object` that passes the truth test or\nundefined if no elements pass.",
        "deprecated": false
      }
    },
    {
      "name": "_.pick",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(K | K[])[]",
          "optional": false
        }
      ],
      "returnType": "_Pick<V, K>",
      "jsdoc": {
        "description": "Return a copy of `object` that is filtered to only have values for\nthe allowed keys (or array of keys).",
        "params": [
          {
            "name": "object",
            "description": "The object to pick specific keys in."
          },
          {
            "name": "keys",
            "description": "The keys to keep on `object`."
          }
        ],
        "returns": "A copy of `object` with only the `keys` properties.",
        "deprecated": false
      }
    },
    {
      "name": "_.omit",
      "parameters": [
        {
          "name": "object",
          "type": "V",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(K | K[])[]",
          "optional": false
        }
      ],
      "returnType": "_Omit<V, K>",
      "jsdoc": {
        "description": "Return a copy of `object` that is filtered to omit the disallowed\nkeys (or array of keys).",
        "params": [
          {
            "name": "object",
            "description": "The object to omit specific keys from."
          },
          {
            "name": "keys",
            "description": "The keys to omit from `object`."
          }
        ],
        "returns": "A copy of `object` without the `keys` properties.",
        "deprecated": false
      }
    },
    {
      "name": "_.defaults",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Fill in null and undefined properties in object with values from the defaults objects,\nand return the object. As soon as the property is filled, further defaults will have no effect.",
        "params": [
          {
            "name": "object",
            "description": "Fill this object with default values."
          },
          {
            "name": "defaults",
            "description": "The default values to add to `object`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.create",
      "parameters": [
        {
          "name": "prototype",
          "type": "any",
          "optional": false
        },
        {
          "name": "props",
          "type": "object",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Creates an object that inherits from the given prototype object.\nIf additional properties are provided then they will be added to the\ncreated object.",
        "params": [
          {
            "name": "prototype",
            "description": "The prototype that the returned object will inherit from."
          },
          {
            "name": "props",
            "description": "Additional props added to the returned object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.clone",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Create a shallow-copied clone of the object.\nAny nested objects or arrays will be copied by reference, not duplicated.",
        "params": [
          {
            "name": "object",
            "description": "Object to clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.tap",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "intercepter",
          "type": "Function",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Invokes interceptor with the object, and then returns object. The primary purpose of this method\nis to \"tap into\" a method chain, in order to perform operations on intermediate results within the chain.",
        "params": [
          {
            "name": "object",
            "description": "Argument to `interceptor`."
          },
          {
            "name": "intercepter",
            "description": "The function to modify `object` before continuing the method chain."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.has",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "key",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Does the object contain the given key? Identical to object.hasOwnProperty(key), but uses a safe\nreference to the hasOwnProperty function, in case it's been overridden accidentally.",
        "params": [
          {
            "name": "object",
            "description": "Object to check for `key`."
          },
          {
            "name": "key",
            "description": "The key to check for on `object`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.matches",
      "parameters": [
        {
          "name": "attrs",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "Predicate<T>",
      "jsdoc": {
        "description": "Returns a predicate function that will tell you if a passed in object contains all of the key/value properties present in attrs.",
        "params": [
          {
            "name": "attrs",
            "description": "Object with key values pair"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.matcher",
      "parameters": [
        {
          "name": "attrs",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "Predicate<T>",
      "jsdoc": {
        "description": "Returns a predicate function that will tell you if a passed in object contains all of the key/value properties present in attrs.",
        "params": [
          {
            "name": "attrs",
            "description": "Object with key values pair"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.get",
      "parameters": [
        {
          "name": "object",
          "type": "null",
          "optional": false
        },
        {
          "name": "path",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "undefined",
      "jsdoc": {
        "description": "Returns the specified property of `object`. `path` may be specified\nas a simple key, or as an array of object keys or array indexes,\nfor deep property fetching. If the property does not exist or is `undefined`,\nthe optional default is returned.",
        "params": [
          {
            "name": "object",
            "description": "The object that maybe contains the property."
          },
          {
            "name": "path",
            "description": "The path to the property on `object`."
          },
          {
            "name": "defaultValue",
            "description": "Default if not found."
          }
        ],
        "returns": "The item on the `object` or the `defaultValue`",
        "deprecated": false
      }
    },
    {
      "name": "_.property",
      "parameters": [
        {
          "name": "key",
          "type": "string | number | (string | number)[]",
          "optional": false
        }
      ],
      "returnType": "(object: any) => any",
      "jsdoc": {
        "description": "Returns a function that will itself return the key property of any passed-in object.",
        "params": [
          {
            "name": "key",
            "description": "Property of the object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.propertyOf",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "(key: string | number | (string | number)[]) => any",
      "jsdoc": {
        "description": "Returns a function that will itself return the value of a object key property.",
        "params": [
          {
            "name": "key",
            "description": "The object to get the property value from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isEqual",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs an optimized deep comparison between `object` and `other`\nto determine if they should be considered equal.",
        "params": [
          {
            "name": "object",
            "description": "Compare to `other`."
          },
          {
            "name": "other",
            "description": "Compare to `object`."
          }
        ],
        "returns": "True if `object` should be considered equal to `other`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isEmpty",
      "parameters": [
        {
          "name": "collection",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `collection` contains no values.\nFor strings and array-like objects checks if the length property is\n0.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to check."
          }
        ],
        "returns": "True if `collection` has no elements.",
        "deprecated": false
      }
    },
    {
      "name": "_.isMatch",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "properties",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the keys and values in `properties` are contained in\n`object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          },
          {
            "name": "properties",
            "description": "The properties to check for in `object`."
          }
        ],
        "returns": "True if all keys and values in `properties` are also in\n`object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isElement",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a DOM element.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a DOM element, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isArray",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Array.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Array, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isArrayBuffer",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an ArrayBuffer.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an ArrayBuffer, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isDataView",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a DataView.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a DataView, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isTypedArray",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a TypedArray.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a TypedArray, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isSymbol",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Symbol.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Symbol, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isObject",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Object. Note that JavaScript arrays\nand functions are objects,\nwhile (normal) strings and numbers are not.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Object, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isArguments",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Arguments object.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is an Arguments object, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isFunction",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Function.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Function, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isError",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is an Error.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Error, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isString",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a String.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a String, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isNumber",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Number (including NaN).",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Number, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isFinite",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a finite Number.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a finite Number.",
        "deprecated": false
      }
    },
    {
      "name": "_.isBoolean",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Boolean.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Boolean, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isDate",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Date.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Date, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isRegExp",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a RegExp.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a RegExp, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isNaN",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is NaN.\nNote: this is not the same as the native isNaN function,\nwhich will also return true if the variable is undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is NaN, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isNull",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is null.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is null, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isUndefined",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is undefined.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is undefined, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isSet",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Set.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Set, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isWeakSet",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a WeakSet.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a WeakSet, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isMap",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a Map.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a Map, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isWeakMap",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if `object` is a WeakMap.",
        "params": [
          {
            "name": "object",
            "description": "The object to check."
          }
        ],
        "returns": "True if `object` is a WeakMap, otherwise false.",
        "deprecated": false
      }
    },
    {
      "name": "_.toPath",
      "parameters": [
        {
          "name": "path",
          "type": "P",
          "optional": false
        }
      ],
      "returnType": "P extends readonly (string | number)[] ? P : P extends string | number ? [P] : never",
      "jsdoc": {
        "description": "Ensures that path is an array.",
        "params": [
          {
            "name": "path",
            "description": " 1. If path is a string, it is wrapped in a single-element array;\n 2. if it is an array already, it is returned unmodified."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.noConflict",
      "parameters": [],
      "returnType": "any",
      "jsdoc": {
        "description": "*********\nUtility *\n*********",
        "deprecated": false
      }
    },
    {
      "name": "_.identity",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Returns the same value that is used as the argument. In math: f(x) = x\nThis function looks useless, but is used throughout Underscore as a default iterator.",
        "params": [
          {
            "name": "value",
            "description": "Identity of this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.constant",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "() => T",
      "jsdoc": {
        "description": "Creates a function that returns the same value that is used as the argument of _.constant",
        "params": [
          {
            "name": "value",
            "description": "Identity of this object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.noop",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Returns undefined irrespective of the arguments passed to it.  Useful as the default\nfor optional callback arguments.\nNote there is no way to indicate a 'undefined' return, so it is currently typed as void.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.times",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "iterator",
          "type": "(n: number) => TResult",
          "optional": false
        },
        {
          "name": "context",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "Invokes the given iterator function n times.\nEach invocation of iterator is called with an index argument",
        "params": [
          {
            "name": "n",
            "description": "Number of times to invoke `iterator`."
          },
          {
            "name": "iterator",
            "description": "Function iterator to invoke `n` times."
          },
          {
            "name": "context",
            "description": "`this` object in `iterator`, optional."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.random",
      "parameters": [
        {
          "name": "max",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a random integer between min and max, inclusive. If you only pass one argument,\nit will return a number between 0 and that number.",
        "params": [
          {
            "name": "max",
            "description": "The maximum random number."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.mixin",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Allows you to extend Underscore with your own utility functions. Pass a hash of\n{name: function} definitions to have your functions added to the Underscore object,\nas well as the OOP wrapper.",
        "params": [
          {
            "name": "object",
            "description": "Mixin object containing key/function pairs to add to the Underscore object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.iteratee",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Function",
      "jsdoc": {
        "description": "A mostly-internal function to generate callbacks that can be applied to each element\nin a collection, returning the desired result -- either identity, an arbitrary callback,\na property matcher, or a propetery accessor.",
        "params": [
          {
            "name": "string",
            "description": "|Function|Object value The value to iterate over, usually the key."
          },
          {
            "name": "any",
            "description": "context"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.uniqueId",
      "parameters": [
        {
          "name": "prefix",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Generate a globally-unique id for client-side models or DOM elements that need one.\nIf prefix is passed, the id will be appended to it. Without prefix, returns an integer.",
        "params": [
          {
            "name": "prefix",
            "description": "A prefix string to start the unique ID with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.escape",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Escapes a string for insertion into HTML, replacing &, <, >, \", ', and / characters.",
        "params": [
          {
            "name": "str",
            "description": "Raw string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unescape",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "The opposite of escape, replaces &amp;, &lt;, &gt;, &quot;, and &#x27; with their unescaped counterparts.",
        "params": [
          {
            "name": "str",
            "description": "HTML escaped string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.result",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "property",
          "type": "string",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "If the value of the named property is a function then invoke it; otherwise, return it.",
        "params": [
          {
            "name": "object",
            "description": "Object to maybe invoke function `property` on."
          },
          {
            "name": "property",
            "description": "The function by name to invoke on `object`."
          },
          {
            "name": "defaultValue",
            "description": "The value to be returned in case `property` doesn't exist or is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.template",
      "parameters": [
        {
          "name": "templateString",
          "type": "string",
          "optional": false
        },
        {
          "name": "settings",
          "type": "TemplateSettings",
          "optional": true
        }
      ],
      "returnType": "CompiledTemplate",
      "jsdoc": {
        "description": "Compiles JavaScript templates into functions that can be evaluated for rendering. Useful\nfor rendering complicated bits of HTML from JSON data sources. Template functions can both\ninterpolate variables, using <%= ... %>, as well as execute arbitrary JavaScript code, with\n<% ... %>. If you wish to interpolate a value, and have it be HTML-escaped, use <%- ... %> When\nyou evaluate a template function, pass in a data object that has properties corresponding to\nthe template's free variables. If you're writing a one-off, you can pass the data object as\nthe second parameter to template in order to render immediately instead of returning a template\nfunction. The settings argument should be a hash containing any _.templateSettings that should\nbe overridden.",
        "params": [
          {
            "name": "templateString",
            "description": "Underscore HTML template."
          },
          {
            "name": "data",
            "description": "Data to use when compiling `templateString`."
          },
          {
            "name": "settings",
            "description": "Settings to use while compiling."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.now",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns an integer timestamp for the current time, using the fastest method available in the runtime. Useful for implementing timing/animation functions.",
        "deprecated": false
      }
    },
    {
      "name": "_.chain",
      "parameters": [
        {
          "name": "value",
          "type": "V",
          "optional": false
        }
      ],
      "returnType": "_Chain<TypeOfCollection<V, never>, V>",
      "jsdoc": {
        "description": "**********\nChaining *\n**********",
        "deprecated": false
      }
    },
    {
      "name": "_.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string that contains the concatenation of two or more strings.",
        "params": [
          {
            "name": "strings",
            "description": "The strings to append to the end of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a section of a string.",
        "params": [
          {
            "name": "start",
            "description": "The index to the beginning of the specified portion of stringObj."
          },
          {
            "name": "end",
            "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false
      }
    },
    {
      "name": "_.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "_.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false
      }
    },
    {
      "name": "_.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "_.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "_.valueOf",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false
      }
    },
    {
      "name": "_.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false
      }
    },
    {
      "name": "_.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition – length(this). Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "_.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "_.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "_.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.__@iterator@33146",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "_.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": null
    }
  ],
  "enums": [],
  "types": [
    {
      "name": "List",
      "type": "List<T>",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Dictionary",
      "type": "Dictionary<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Element",
      "type": "Element",
      "properties": [
        {
          "name": "attributes",
          "type": "NamedNodeMap",
          "optional": false
        },
        {
          "name": "classList",
          "type": "DOMTokenList",
          "optional": false
        },
        {
          "name": "className",
          "type": "string",
          "optional": false
        },
        {
          "name": "clientHeight",
          "type": "number",
          "optional": false
        },
        {
          "name": "clientLeft",
          "type": "number",
          "optional": false
        },
        {
          "name": "clientTop",
          "type": "number",
          "optional": false
        },
        {
          "name": "clientWidth",
          "type": "number",
          "optional": false
        },
        {
          "name": "currentCSSZoom",
          "type": "number",
          "optional": false
        },
        {
          "name": "id",
          "type": "string",
          "optional": false
        },
        {
          "name": "innerHTML",
          "type": "string",
          "optional": false
        },
        {
          "name": "localName",
          "type": "string",
          "optional": false
        },
        {
          "name": "namespaceURI",
          "type": "string",
          "optional": false
        },
        {
          "name": "onfullscreenchange",
          "type": "(this: Element, ev: Event) => any",
          "optional": false
        },
        {
          "name": "onfullscreenerror",
          "type": "(this: Element, ev: Event) => any",
          "optional": false
        },
        {
          "name": "outerHTML",
          "type": "string",
          "optional": false
        },
        {
          "name": "ownerDocument",
          "type": "Document",
          "optional": false
        },
        {
          "name": "part",
          "type": "DOMTokenList",
          "optional": false
        },
        {
          "name": "prefix",
          "type": "string",
          "optional": false
        },
        {
          "name": "scrollHeight",
          "type": "number",
          "optional": false
        },
        {
          "name": "scrollLeft",
          "type": "number",
          "optional": false
        },
        {
          "name": "scrollTop",
          "type": "number",
          "optional": false
        },
        {
          "name": "scrollWidth",
          "type": "number",
          "optional": false
        },
        {
          "name": "shadowRoot",
          "type": "ShadowRoot",
          "optional": false
        },
        {
          "name": "slot",
          "type": "string",
          "optional": false
        },
        {
          "name": "tagName",
          "type": "string",
          "optional": false
        },
        {
          "name": "attachShadow",
          "type": "(init: ShadowRootInit) => ShadowRoot",
          "optional": false
        },
        {
          "name": "checkVisibility",
          "type": "(options?: CheckVisibilityOptions) => boolean",
          "optional": false
        },
        {
          "name": "closest",
          "type": "{ <K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K]; <K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K]; <K extends keyof MathMLElementTagNameMap>(selector: K): MathMLElementTagNameMap[K]; <E extends Element = Element>(selectors: string): E; }",
          "optional": false
        },
        {
          "name": "computedStyleMap",
          "type": "() => StylePropertyMapReadOnly",
          "optional": false
        },
        {
          "name": "getAttribute",
          "type": "(qualifiedName: string) => string",
          "optional": false
        },
        {
          "name": "getAttributeNS",
          "type": "(namespace: string, localName: string) => string",
          "optional": false
        },
        {
          "name": "getAttributeNames",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "getAttributeNode",
          "type": "(qualifiedName: string) => Attr",
          "optional": false
        },
        {
          "name": "getAttributeNodeNS",
          "type": "(namespace: string, localName: string) => Attr",
          "optional": false
        },
        {
          "name": "getBoundingClientRect",
          "type": "() => DOMRect",
          "optional": false
        },
        {
          "name": "getClientRects",
          "type": "() => DOMRectList",
          "optional": false
        },
        {
          "name": "getElementsByClassName",
          "type": "(classNames: string) => HTMLCollectionOf<Element>",
          "optional": false
        },
        {
          "name": "getElementsByTagName",
          "type": "{ <K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>; <K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<...>; <K extends keyof MathMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<...>; <K extends keyof HTMLElementDeprecatedTagNameMa...",
          "optional": false
        },
        {
          "name": "getElementsByTagNameNS",
          "type": "{ (namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>; (namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<...>; (namespaceURI: \"http://www.w3.org/1998/Math/MathML\", localName: string): HTMLCollectionOf<...>; (namespace: string, localName: st...",
          "optional": false
        },
        {
          "name": "getHTML",
          "type": "(options?: GetHTMLOptions) => string",
          "optional": false
        },
        {
          "name": "hasAttribute",
          "type": "(qualifiedName: string) => boolean",
          "optional": false
        },
        {
          "name": "hasAttributeNS",
          "type": "(namespace: string, localName: string) => boolean",
          "optional": false
        },
        {
          "name": "hasAttributes",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "hasPointerCapture",
          "type": "(pointerId: number) => boolean",
          "optional": false
        },
        {
          "name": "insertAdjacentElement",
          "type": "(where: InsertPosition, element: Element) => Element",
          "optional": false
        },
        {
          "name": "insertAdjacentHTML",
          "type": "(position: InsertPosition, string: string) => void",
          "optional": false
        },
        {
          "name": "insertAdjacentText",
          "type": "(where: InsertPosition, data: string) => void",
          "optional": false
        },
        {
          "name": "matches",
          "type": "(selectors: string) => boolean",
          "optional": false
        },
        {
          "name": "releasePointerCapture",
          "type": "(pointerId: number) => void",
          "optional": false
        },
        {
          "name": "removeAttribute",
          "type": "(qualifiedName: string) => void",
          "optional": false
        },
        {
          "name": "removeAttributeNS",
          "type": "(namespace: string, localName: string) => void",
          "optional": false
        },
        {
          "name": "removeAttributeNode",
          "type": "(attr: Attr) => Attr",
          "optional": false
        },
        {
          "name": "requestFullscreen",
          "type": "(options?: FullscreenOptions) => Promise<void>",
          "optional": false
        },
        {
          "name": "requestPointerLock",
          "type": "(options?: PointerLockOptions) => Promise<void>",
          "optional": false
        },
        {
          "name": "scroll",
          "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
          "optional": false
        },
        {
          "name": "scrollBy",
          "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
          "optional": false
        },
        {
          "name": "scrollIntoView",
          "type": "(arg?: boolean | ScrollIntoViewOptions) => void",
          "optional": false
        },
        {
          "name": "scrollTo",
          "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
          "optional": false
        },
        {
          "name": "setAttribute",
          "type": "(qualifiedName: string, value: string) => void",
          "optional": false
        },
        {
          "name": "setAttributeNS",
          "type": "(namespace: string, qualifiedName: string, value: string) => void",
          "optional": false
        },
        {
          "name": "setAttributeNode",
          "type": "(attr: Attr) => Attr",
          "optional": false
        },
        {
          "name": "setAttributeNodeNS",
          "type": "(attr: Attr) => Attr",
          "optional": false
        },
        {
          "name": "setHTMLUnsafe",
          "type": "(html: string) => void",
          "optional": false
        },
        {
          "name": "setPointerCapture",
          "type": "(pointerId: number) => void",
          "optional": false
        },
        {
          "name": "toggleAttribute",
          "type": "(qualifiedName: string, force?: boolean) => boolean",
          "optional": false
        },
        {
          "name": "webkitMatchesSelector",
          "type": "(selectors: string) => boolean",
          "optional": false
        },
        {
          "name": "addEventListener",
          "type": "{ <K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void; (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void; }",
          "optional": false
        },
        {
          "name": "removeEventListener",
          "type": "{ <K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void; (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void; }",
          "optional": false
        },
        {
          "name": "baseURI",
          "type": "string",
          "optional": false
        },
        {
          "name": "childNodes",
          "type": "NodeListOf<ChildNode>",
          "optional": false
        },
        {
          "name": "firstChild",
          "type": "ChildNode",
          "optional": false
        },
        {
          "name": "isConnected",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "lastChild",
          "type": "ChildNode",
          "optional": false
        },
        {
          "name": "nextSibling",
          "type": "ChildNode",
          "optional": false
        },
        {
          "name": "nodeName",
          "type": "string",
          "optional": false
        },
        {
          "name": "nodeType",
          "type": "number",
          "optional": false
        },
        {
          "name": "nodeValue",
          "type": "string",
          "optional": false
        },
        {
          "name": "parentElement",
          "type": "HTMLElement",
          "optional": false
        },
        {
          "name": "parentNode",
          "type": "ParentNode",
          "optional": false
        },
        {
          "name": "previousSibling",
          "type": "ChildNode",
          "optional": false
        },
        {
          "name": "textContent",
          "type": "string",
          "optional": false
        },
        {
          "name": "appendChild",
          "type": "<T extends Node>(node: T) => T",
          "optional": false
        },
        {
          "name": "cloneNode",
          "type": "(subtree?: boolean) => Node",
          "optional": false
        },
        {
          "name": "compareDocumentPosition",
          "type": "(other: Node) => number",
          "optional": false
        },
        {
          "name": "contains",
          "type": "(other: Node) => boolean",
          "optional": false
        },
        {
          "name": "getRootNode",
          "type": "(options?: GetRootNodeOptions) => Node",
          "optional": false
        },
        {
          "name": "hasChildNodes",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "insertBefore",
          "type": "<T extends Node>(node: T, child: Node) => T",
          "optional": false
        },
        {
          "name": "isDefaultNamespace",
          "type": "(namespace: string) => boolean",
          "optional": false
        },
        {
          "name": "isEqualNode",
          "type": "(otherNode: Node) => boolean",
          "optional": false
        },
        {
          "name": "isSameNode",
          "type": "(otherNode: Node) => boolean",
          "optional": false
        },
        {
          "name": "lookupNamespaceURI",
          "type": "(prefix: string) => string",
          "optional": false
        },
        {
          "name": "lookupPrefix",
          "type": "(namespace: string) => string",
          "optional": false
        },
        {
          "name": "normalize",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "removeChild",
          "type": "<T extends Node>(child: T) => T",
          "optional": false
        },
        {
          "name": "replaceChild",
          "type": "<T extends Node>(node: Node, child: T) => T",
          "optional": false
        },
        {
          "name": "ELEMENT_NODE",
          "type": "1",
          "optional": false
        },
        {
          "name": "ATTRIBUTE_NODE",
          "type": "2",
          "optional": false
        },
        {
          "name": "TEXT_NODE",
          "type": "3",
          "optional": false
        },
        {
          "name": "CDATA_SECTION_NODE",
          "type": "4",
          "optional": false
        },
        {
          "name": "ENTITY_REFERENCE_NODE",
          "type": "5",
          "optional": false
        },
        {
          "name": "ENTITY_NODE",
          "type": "6",
          "optional": false
        },
        {
          "name": "PROCESSING_INSTRUCTION_NODE",
          "type": "7",
          "optional": false
        },
        {
          "name": "COMMENT_NODE",
          "type": "8",
          "optional": false
        },
        {
          "name": "DOCUMENT_NODE",
          "type": "9",
          "optional": false
        },
        {
          "name": "DOCUMENT_TYPE_NODE",
          "type": "10",
          "optional": false
        },
        {
          "name": "DOCUMENT_FRAGMENT_NODE",
          "type": "11",
          "optional": false
        },
        {
          "name": "NOTATION_NODE",
          "type": "12",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_DISCONNECTED",
          "type": "1",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_PRECEDING",
          "type": "2",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_FOLLOWING",
          "type": "4",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_CONTAINS",
          "type": "8",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_CONTAINED_BY",
          "type": "16",
          "optional": false
        },
        {
          "name": "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
          "type": "32",
          "optional": false
        },
        {
          "name": "dispatchEvent",
          "type": "(event: Event) => boolean",
          "optional": false
        },
        {
          "name": "ariaAtomic",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaAutoComplete",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaBrailleLabel",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaBrailleRoleDescription",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaBusy",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaChecked",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaColCount",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaColIndex",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaColIndexText",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaColSpan",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaCurrent",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaDescription",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaDisabled",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaExpanded",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaHasPopup",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaHidden",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaInvalid",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaKeyShortcuts",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaLabel",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaLevel",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaLive",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaModal",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaMultiLine",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaMultiSelectable",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaOrientation",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaPlaceholder",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaPosInSet",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaPressed",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaReadOnly",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRelevant",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRequired",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRoleDescription",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRowCount",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRowIndex",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRowIndexText",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaRowSpan",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaSelected",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaSetSize",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaSort",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaValueMax",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaValueMin",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaValueNow",
          "type": "string",
          "optional": false
        },
        {
          "name": "ariaValueText",
          "type": "string",
          "optional": false
        },
        {
          "name": "role",
          "type": "string",
          "optional": false
        },
        {
          "name": "animate",
          "type": "(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions) => Animation",
          "optional": false
        },
        {
          "name": "getAnimations",
          "type": "(options?: GetAnimationsOptions) => Animation[]",
          "optional": false
        },
        {
          "name": "after",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "before",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "remove",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "replaceWith",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "nextElementSibling",
          "type": "Element",
          "optional": false
        },
        {
          "name": "previousElementSibling",
          "type": "Element",
          "optional": false
        },
        {
          "name": "childElementCount",
          "type": "number",
          "optional": false
        },
        {
          "name": "children",
          "type": "HTMLCollection",
          "optional": false
        },
        {
          "name": "firstElementChild",
          "type": "Element",
          "optional": false
        },
        {
          "name": "lastElementChild",
          "type": "Element",
          "optional": false
        },
        {
          "name": "append",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "prepend",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "querySelector",
          "type": "{ <K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K]; <K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K]; <K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K]; <K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLE...",
          "optional": false
        },
        {
          "name": "querySelectorAll",
          "type": "{ <K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>; <K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<...>; <K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<...>; <K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<....",
          "optional": false
        },
        {
          "name": "replaceChildren",
          "type": "(...nodes: (string | Node)[]) => void",
          "optional": false
        },
        {
          "name": "assignedSlot",
          "type": "HTMLSlotElement",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ThrottleSettings",
      "type": "ThrottleSettings",
      "properties": [
        {
          "name": "leading",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "trailing",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "underscore.js _.throttle options.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "TemplateSettings",
      "type": "TemplateSettings",
      "properties": [
        {
          "name": "evaluate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "interpolate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "escape",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "variable",
          "type": "string",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "underscore.js template settings, set templateSettings or pass as an argument\nto 'template()' to override defaults.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "CompiledTemplate",
      "type": "CompiledTemplate",
      "properties": [
        {
          "name": "source",
          "type": "string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Collection",
      "type": "Collection<T>",
      "properties": [
        {
          "name": "length",
          "type": "number | T",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CollectionKey",
      "type": "CollectionKey<V>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Predicate",
      "type": "Predicate<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CollectionIterator",
      "type": "CollectionIterator<T, TResult, V>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListIterator",
      "type": "ListIterator<T, TResult, V>",
      "properties": [],
      "extends": [
        "CollectionIterator<T, TResult, V>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectIterator",
      "type": "ObjectIterator<T, TResult, V>",
      "properties": [],
      "extends": [
        "CollectionIterator<T, TResult, V>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Iteratee",
      "type": "Iteratee<V, R, T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IterateeResult",
      "type": "IterateeResult<I, T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PropertyTypeOrAny",
      "type": "PropertyTypeOrAny<T, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoCollectionIterator",
      "type": "MemoCollectionIterator<T, TResult, V>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoIterator",
      "type": "MemoIterator<T, TResult, V>",
      "properties": [],
      "extends": [
        "MemoCollectionIterator<T, TResult, V>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoObjectIterator",
      "type": "MemoObjectIterator<T, TResult, V>",
      "properties": [],
      "extends": [
        "MemoCollectionIterator<T, TResult, V>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TypeOfList",
      "type": "TypeOfList<V>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TypeOfDictionary",
      "type": "TypeOfDictionary<V, TDefault>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TypeOfCollection",
      "type": "TypeOfCollection<V, TObjectDefault>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DeepTypeOfCollection",
      "type": "DeepTypeOfCollection<V, P>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListItemOrSelf",
      "type": "ListItemOrSelf<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DeepestListItemOrSelf",
      "type": "DeepestListItemOrSelf<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PairValue",
      "type": "PairValue<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "AnyFalsy",
      "type": "AnyFalsy",
      "properties": [
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => boolean)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Truthy",
      "type": "Truthy<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_Pick",
      "type": "_Pick<V, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_Omit",
      "type": "_Omit<V, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_ChainSingle",
      "type": "_ChainSingle<V>",
      "properties": [
        {
          "name": "each",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<TypeOfCollection<V, never>, V>",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<TypeOfCollection<V, never>, V>",
          "optional": false
        },
        {
          "name": "map",
          "type": "<I extends Iteratee<V, any, TypeOfCollection<V, never>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, never>>, IterateeResult<...>[]>",
          "optional": false
        },
        {
          "name": "collect",
          "type": "<I extends Iteratee<V, any, TypeOfCollection<V, never>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, never>>, IterateeResult<...>[]>",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "inject",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "foldl",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "foldr",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "detect",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "select",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "where",
          "type": "(properties: Partial<TypeOfCollection<V, never>>) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "findWhere",
          "type": "(properties: Partial<TypeOfCollection<V, never>>) => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "all",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "any",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "contains",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "include",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(methodName: string, ...args: any[]) => _Chain<any, any[]>",
          "optional": false
        },
        {
          "name": "pluck",
          "type": "<K extends string | number>(propertyName: K) => _Chain<PropertyTypeOrAny<TypeOfCollection<V, never>, K>, PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]>",
          "optional": false
        },
        {
          "name": "max",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "min",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>[], Dictionary<...>>",
          "optional": false
        },
        {
          "name": "indexBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, Dictionary<...>>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iterator?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<number, Dictionary<number>>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (): _ChainSingle<TypeOfCollection<V, never>>; }",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>[], [TypeOfCollection<...>[], TypeOfCollection<...>[]]>",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
          "optional": false
        },
        {
          "name": "initial",
          "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "last",
          "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "tail",
          "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "compact",
          "type": "() => _Chain<Exclude<TypeOfCollection<V, never>, AnyFalsy>, Exclude<TypeOfCollection<V, never>, AnyFalsy>[]>",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "{ (depth: true | 1): _Chain<ListItemOrSelf<TypeOfCollection<V, never>>, ListItemOrSelf<TypeOfCollection<V, never>>[]>; (depth?: number | false): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "(...values: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "union",
          "type": "(...lists: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "(...lists: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "difference",
          "type": "(...others: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; (iteratee?: Iteratee<...>, context?: any): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "unique",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; (iteratee?: Iteratee<...>, context?: any): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ (): V extends List<infer A> ? _Chain<[A], [A][]> : _Chain<never, []>; <A, B>(arrays_0: List<A>, arrays_1: List<B>): _Chain<[TypeOfCollection<V, never>, A, B], [...][]>; <A>(array: List<...>): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "() => TypeOfCollection<V, never> extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : TypeOfCollection<V, never> extends [...] ? _Chain<...> : TypeOfCollection<...> extends [...] ? _Chain<...> : TypeOfCollection<...> extends List<...> ? _Chain<...> : _Chain<...>",
          "optional": false
        },
        {
          "name": "transpose",
          "type": "() => TypeOfCollection<V, never> extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : TypeOfCollection<V, never> extends [...] ? _Chain<...> : TypeOfCollection<...> extends [...] ? _Chain<...> : TypeOfCollection<...> extends List<...> ? _Chain<...> : _Chain<...>",
          "optional": false
        },
        {
          "name": "object",
          "type": "{ <TValue>(values: List<TValue>): _Chain<TValue, Dictionary<TValue>>; (): _Chain<PairValue<TypeOfCollection<V, never>>, Dictionary<...>>; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(value: TypeOfCollection<V, never>, isSortedOrFromIndex?: number | boolean) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(value: TypeOfCollection<V, never>, fromIndex?: number) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "(value: TypeOfCollection<V, never>, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(stop?: number, step?: number) => _Chain<number, number[]>",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "(length: number) => _Chain<TypeOfCollection<V, never>[], TypeOfCollection<V, never>[][]>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(object: any, ...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: string[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "partial",
          "type": "(...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "(hashFn?: (n: any) => string) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "{ (wait: number, ...args: any[]): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (...args: any[]): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; }",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "(wait: number, options?: ThrottleSettings) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "(wait: number, immediate?: boolean) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "once",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "restArgs",
          "type": "(startIndex?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "after",
          "type": "(func: Function) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "before",
          "type": "(fn: Function) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "(wrapper: Function) => () => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "negate",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "compose",
          "type": "(...functions: Function[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => _Chain<string, string[]>",
          "optional": false
        },
        {
          "name": "allKeys",
          "type": "() => _Chain<string, string[]>",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => _Chain<any, any[]>",
          "optional": false
        },
        {
          "name": "mapObject",
          "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, any>>, { [K in keyof V]: IterateeResult<...>; }>",
          "optional": false
        },
        {
          "name": "pairs",
          "type": "() => _Chain<[Extract<keyof V, string>, TypeOfCollection<V, any>], [Extract<keyof V, string>, TypeOfCollection<V, any>][]>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "methods",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "extend",
          "type": "(...sources: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => _ChainSingle<Extract<keyof V, string>>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Pick<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Omit<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "(...defaults: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "create",
          "type": "(props?: object) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (...as: any[]) => any) => _Chain<TypeOfCollection<V, never>, V>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(key: string) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "matcher",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: string): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>>; <U>(path: string, defaultValue?: U): _Chain<...>; <P extends Array<string | number>, W = DeepTypeOfCollection<...>, U = undefined>(path: [......], defaultValue?: U): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "property",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(properties: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isDataView",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => _ChainSingle<V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never>",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "times",
          "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (max: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; }",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "result",
          "type": "(property: string, defaultValue?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(settings?: TemplateSettings) => _Chain<CompiledTemplate, CompiledTemplate[]>",
          "optional": false
        },
        {
          "name": "concat",
          "type": "(...arr: TypeOfCollection<V, never>[][]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: any) => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "pop",
          "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...item: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start: number, end?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: TypeOfCollection<V, never>, b: TypeOfCollection<V, never>) => boolean) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "(index: number, quantity: number, ...items: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => _Chain<TypeOfCollection<V, never>, V>",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => V",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TypedArray",
      "type": "TypedArray",
      "properties": [
        {
          "name": "BYTES_PER_ELEMENT",
          "type": "number",
          "optional": false
        },
        {
          "name": "buffer",
          "type": "ArrayBufferLike",
          "optional": false
        },
        {
          "name": "byteLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "byteOffset",
          "type": "number",
          "optional": false
        },
        {
          "name": "copyWithin",
          "type": "((target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>) | ((target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((target: number, start: number, end?: number) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "every",
          "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean) | ((predicate: (value: number, index: number, array: Uint8Array<...>) => unknown, thisArg?: any) => boolean) | ... 6 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) =...",
          "optional": false
        },
        {
          "name": "fill",
          "type": "((value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>) | ((value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((value: number, start?: number, end?: number) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "filter",
          "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>) | ... 7 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) => any, thisArg?: any) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "find",
          "type": "((predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number) | ((predicate: (value: number, index: number, obj: Uint8Array<...>) => boolean, thisArg?: any) => number) | ... 6 more ... | ((predicate: (value: number, index: number, obj: Float64Array<...>) => boolea...",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "((predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number) | ((predicate: (value: number, index: number, obj: Uint8Array<...>) => boolean, thisArg?: any) => number) | ... 6 more ... | ((predicate: (value: number, index: number, obj: Float64Array<...>) => boolea...",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "((callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void) | ((callbackfn: (value: number, index: number, array: Uint8Array<...>) => void, thisArg?: any) => void) | ... 6 more ... | ((callbackfn: (value: number, index: number, array: Float64Array<...>) => void, t...",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => number)",
          "optional": false
        },
        {
          "name": "join",
          "type": "((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string)",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => number)",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": false
        },
        {
          "name": "map",
          "type": "((callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>) | ... 7 more ... | ((callbackfn: (value: number, index: number, array: Float64Array<...>) => number, thisArg?: any) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<...>) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<...>) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U...",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "(() => Int8Array<ArrayBufferLike>) | (() => Uint8Array<ArrayBufferLike>) | (() => Int16Array<ArrayBufferLike>) | ... 5 more ... | (() => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "set",
          "type": "((array: ArrayLike<number>, offset?: number) => void) | ((array: ArrayLike<number>, offset?: number) => void) | ((array: ArrayLike<number>, offset?: number) => void) | ... 5 more ... | ((array: ArrayLike<...>, offset?: number) => void)",
          "optional": false
        },
        {
          "name": "slice",
          "type": "((start?: number, end?: number) => Int8Array<ArrayBuffer>) | ((start?: number, end?: number) => Uint8Array<ArrayBuffer>) | ((start?: number, end?: number) => Int16Array<...>) | ... 5 more ... | ((start?: number, end?: number) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "some",
          "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean) | ((predicate: (value: number, index: number, array: Uint8Array<...>) => unknown, thisArg?: any) => boolean) | ... 6 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) =...",
          "optional": false
        },
        {
          "name": "sort",
          "type": "((compareFn?: (a: number, b: number) => number) => Int8Array<ArrayBufferLike>) | ((compareFn?: (a: number, b: number) => number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((compareFn?: (a: number, b: number) => number) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "subarray",
          "type": "((begin?: number, end?: number) => Int8Array<ArrayBufferLike>) | ((begin?: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((begin?: number, end?: number) => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions): string; } | { (): string; (locales: string | string[], options?: NumberFormatOptions): string; } | ... 6 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "toString",
          "type": "(() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => Int8Array<ArrayBufferLike>) | (() => Uint8Array<ArrayBufferLike>) | (() => Int16Array<ArrayBufferLike>) | ... 5 more ... | (() => Float64Array<...>)",
          "optional": false
        },
        {
          "name": "entries",
          "type": "(() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | ... 4 more ... | (() => ArrayIterator<...>)",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
          "optional": false
        },
        {
          "name": "values",
          "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
          "optional": false
        },
        {
          "name": "includes",
          "type": "((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => boolean)",
          "optional": false
        },
        {
          "name": "__@iterator@33146",
          "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
          "optional": false
        },
        {
          "name": "__@toStringTag@34581",
          "type": "\"Int8Array\" | \"Uint8Array\" | \"Int16Array\" | \"Uint16Array\" | \"Int32Array\" | \"Uint32Array\" | \"Uint8ClampedArray\" | \"Float32Array\" | \"Float64Array\"",
          "optional": false
        },
        {
          "name": "at",
          "type": "(index: number) => number",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Cancelable",
      "type": "Cancelable",
      "properties": [
        {
          "name": "cancel",
          "type": "() => void",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "UnderscoreStatic",
      "type": "UnderscoreStatic",
      "properties": [
        {
          "name": "each",
          "type": "<V extends Collection<any>>(collection: V, iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "<V extends Collection<any>>(collection: V, iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
          "optional": false
        },
        {
          "name": "map",
          "type": "<V extends Collection<any>, I extends Iteratee<V, any>>(collection: V, iteratee: I, context?: any) => IterateeResult<I, TypeOfCollection<V, never>>[]",
          "optional": false
        },
        {
          "name": "collect",
          "type": "<V extends Collection<any>, I extends Iteratee<V, any>>(collection: V, iteratee: I, context?: any) => IterateeResult<I, TypeOfCollection<V, never>>[]",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "inject",
          "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "foldl",
          "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "foldr",
          "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>",
          "optional": false
        },
        {
          "name": "detect",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "select",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "where",
          "type": "<V extends Collection<any>>(collection: V, properties: Partial<TypeOfCollection<V, never>>) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "findWhere",
          "type": "<V extends Collection<any>>(collection: V, properties: Partial<TypeOfCollection<V, never>>) => TypeOfCollection<V, never>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "every",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "all",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "some",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "any",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "contains",
          "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "include",
          "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "includes",
          "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(list: Collection<any>, methodName: string, ...args: any[]) => any[]",
          "optional": false
        },
        {
          "name": "pluck",
          "type": "<V extends Collection<any>, K extends string | number>(collection: V, propertyName: K) => PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]",
          "optional": false
        },
        {
          "name": "max",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | TypeOfCollection<V, never>",
          "optional": false
        },
        {
          "name": "min",
          "type": "<V extends Collection<any>>(list: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | TypeOfCollection<V, never>",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<TypeOfCollection<V, never>[]>",
          "optional": false
        },
        {
          "name": "indexBy",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<TypeOfCollection<V, never>>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<number>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "<V extends Collection<any>>(collection: V) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ <V extends Collection<any>>(collection: V, n: number): TypeOfCollection<V, never>[]; <V extends Collection<any>>(collection: V): TypeOfCollection<V, never>; }",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "<V extends Collection<any>>(collection: V) => TypeOfCollection<V, never>[]",
          "optional": false
        },
        {
          "name": "size",
          "type": "(collection: Collection<any>) => number",
          "optional": false
        },
        {
          "name": "partition",
          "type": "<V extends Collection<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => [TypeOfCollection<V, never>[], TypeOfCollection<...>[]]",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
          "optional": false
        },
        {
          "name": "initial",
          "type": "<V extends List<any>>(list: V, n?: number) => TypeOfList<V>[]",
          "optional": false
        },
        {
          "name": "last",
          "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
          "optional": false
        },
        {
          "name": "rest",
          "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
          "optional": false
        },
        {
          "name": "tail",
          "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
          "optional": false
        },
        {
          "name": "drop",
          "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
          "optional": false
        },
        {
          "name": "compact",
          "type": "<V extends List<any> | null | undefined>(list: V) => Exclude<TypeOfList<V>, AnyFalsy>[]",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "{ <V extends List<any>>(list: V, depth: true | 1): ListItemOrSelf<TypeOfList<V>>[]; <V extends List<any>>(list: V, depth?: number | false): DeepestListItemOrSelf<TypeOfList<V>>[]; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "<V extends List<any>>(list: V, ...values: TypeOfList<V>[]) => TypeOfList<V>[]",
          "optional": false
        },
        {
          "name": "union",
          "type": "<T>(...lists: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "<T>(...lists: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "difference",
          "type": "<T>(list: List<T>, ...others: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "{ <V extends List<any>>(list: V, isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): TypeOfList<V>[]; <V extends List<any>>(list: V, iteratee?: Iteratee<...>, context?: any): TypeOfList<...>[]; }",
          "optional": false
        },
        {
          "name": "unique",
          "type": "{ <V extends List<any>>(list: V, isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): TypeOfList<V>[]; <V extends List<any>>(list: V, iteratee?: Iteratee<...>, context?: any): TypeOfList<...>[]; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ (): []; <T, U, V>(lists_0: List<T>, lists_1: List<U>, lists_2: List<V>): [T, U, V][]; <T, U>(lists_0: List<T>, lists_1: List<U>): [T, U][]; <T>(lists_0: List<...>): [...][]; <T>(...lists: List<...>[]): T[][]; (...lists: List<...>[]): any[][]; }",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "{ <T, U, V>(lists: List<[T, U, V]>): [T[], U[], V[]]; <T, U>(lists: List<[T, U]>): [T[], U[]]; <T>(lists: List<[T]>): [T[]]; <T>(lists: List<List<T>>): T[][]; (lists: List<...>): any[][]; (): []; }",
          "optional": false
        },
        {
          "name": "transpose",
          "type": "{ <T, U, V>(lists: List<[T, U, V]>): [T[], U[], V[]]; <T, U>(lists: List<[T, U]>): [T[], U[]]; <T>(lists: List<[T]>): [T[]]; <T>(lists: List<List<T>>): T[][]; (lists: List<...>): any[][]; (): []; }",
          "optional": false
        },
        {
          "name": "object",
          "type": "{ <TList extends List<string | number>, TValue>(list: TList, values: List<TValue>): Dictionary<TValue>; <TList extends List<List<any>>>(list: TList): Dictionary<PairValue<TypeOfList<TList>>>; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, isSortedOrFromIndex?: number | boolean) => number",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "<V extends List<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "<V extends List<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "range",
          "type": "(startOrStop: number, stop?: number, step?: number) => number[]",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "<V extends List<any>>(list: V, length: number) => TypeOfList<V>[][]",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(func: Function, context: any, ...args: any[]) => () => any",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(object: any, ...methodNames: string[]) => any",
          "optional": false
        },
        {
          "name": "partial",
          "type": "{ <T1, T2>(fn: (p1: T1) => T2, p1: T1): () => T2; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, p1: T1): (p2: T2) => T3; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, p1: T1, p2: T2): () => T3; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, stub1: UnderscoreStatic, p2: T2): (p1: T1) => T3; <T1, T2, T3, T4>(fn: (p1: T1, p2: T2, p3: ...",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "<T = Function>(fn: T, hashFn?: (...args: any[]) => string) => T",
          "optional": false
        },
        {
          "name": "delay",
          "type": "{ (func: Function, wait: number, ...args: any[]): any; (func: Function, ...args: any[]): any; }",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(fn: Function, ...args: any[]) => void",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "<T extends Function>(func: T, wait: number, options?: ThrottleSettings) => T & Cancelable",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "<T extends Function>(fn: T, wait: number, immediate?: boolean) => T & Cancelable",
          "optional": false
        },
        {
          "name": "once",
          "type": "<T extends Function>(fn: T) => T",
          "optional": false
        },
        {
          "name": "restArgs",
          "type": "(func: Function, starIndex?: number) => Function",
          "optional": false
        },
        {
          "name": "after",
          "type": "(count: number, fn: Function) => Function",
          "optional": false
        },
        {
          "name": "before",
          "type": "(count: number, fn: Function) => Function",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "(fn: Function, wrapper: (fn: Function, ...args: any[]) => any) => Function",
          "optional": false
        },
        {
          "name": "negate",
          "type": "(predicate: (...args: any[]) => boolean) => (...args: any[]) => boolean",
          "optional": false
        },
        {
          "name": "compose",
          "type": "(...functions: Function[]) => Function",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "allKeys",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "{ <T>(object: Dictionary<T>): T[]; (object: any): any[]; }",
          "optional": false
        },
        {
          "name": "mapObject",
          "type": "<V extends object, I extends Iteratee<V, any, TypeOfCollection<V, any>>>(object: V, iteratee: I, context?: any) => { [K in keyof V]: IterateeResult<I, V[K]>; }",
          "optional": false
        },
        {
          "name": "pairs",
          "type": "<V extends object>(object: V) => [Extract<keyof V, string>, TypeOfCollection<V, any>][]",
          "optional": false
        },
        {
          "name": "invert",
          "type": "(object: any) => any",
          "optional": false
        },
        {
          "name": "functions",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "methods",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "extend",
          "type": "(destination: any, ...sources: any[]) => any",
          "optional": false
        },
        {
          "name": "extendOwn",
          "type": "(destination: any, ...source: any[]) => any",
          "optional": false
        },
        {
          "name": "assign",
          "type": "(destination: any, ...source: any[]) => any",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "<V extends object>(object: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => Extract<keyof V, string>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <V, K extends string>(object: V, ...keys: (K | K[])[]): _Pick<V, K>; <V>(object: V, iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<...>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <V, K extends string>(object: V, ...keys: (K | K[])[]): _Omit<V, K>; <V>(object: V, iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<...>; }",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "(object: any, ...defaults: any[]) => any",
          "optional": false
        },
        {
          "name": "create",
          "type": "(prototype: any, props?: object) => any",
          "optional": false
        },
        {
          "name": "clone",
          "type": "<T>(object: T) => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "<T>(object: T, intercepter: Function) => T",
          "optional": false
        },
        {
          "name": "has",
          "type": "(object: any, key: string) => boolean",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<T>(attrs: T) => Predicate<T>",
          "optional": false
        },
        {
          "name": "matcher",
          "type": "<T>(attrs: T) => Predicate<T>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (object: null, path: string | string[]): undefined; <U>(object: null, path: string | string[], defaultValue?: U): U; <V extends Collection<any>>(object: V, path: string): TypeOfCollection<V, never>; <V extends Collection<any>, U>(object: V, path: string, defaultValue?: U): U | TypeOfCollection<...>; <V extends Col...",
          "optional": false
        },
        {
          "name": "property",
          "type": "(key: string | number | (string | number)[]) => (object: any) => any",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "(object: object) => (key: string | number | (string | number)[]) => any",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(object: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "(collection: any) => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(object: any, properties: any) => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "(object: any) => object is Element",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "(object: any) => object is any[]",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "(object: any) => object is ArrayBuffer",
          "optional": false
        },
        {
          "name": "isDataView",
          "type": "(object: any) => object is DataView<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "(object: any) => object is TypedArray",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "(object: any) => object is symbol",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "(object: any) => object is Dictionary<any> & object",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "(object: any) => object is IArguments",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "(object: any) => object is Function",
          "optional": false
        },
        {
          "name": "isError",
          "type": "(object: any) => object is Error",
          "optional": false
        },
        {
          "name": "isString",
          "type": "(object: any) => object is string",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "(object: any) => object is number",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "(object: any) => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "(object: any) => object is boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "(object: any) => object is Date",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "(object: any) => object is RegExp",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "(object: any) => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "(object: any) => object is null",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "(object: any) => object is undefined",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "(object: any) => object is Set<any>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "(object: any) => object is WeakSet<any>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "(object: any) => object is Map<any, any>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "(object: any) => object is WeakMap<any, any>",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "<P>(path: P) => P extends readonly (string | number)[] ? P : P extends string | number ? [P] : never",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "identity",
          "type": "<T>(value: T) => T",
          "optional": false
        },
        {
          "name": "constant",
          "type": "<T>(value: T) => () => T",
          "optional": false
        },
        {
          "name": "noop",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "times",
          "type": "<TResult>(n: number, iterator: (n: number) => TResult, context?: any) => TResult[]",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (max: number): number; (min: number, max: number): number; }",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "(object: any) => void",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "{ (value: string): Function; (value: Function, context?: any): Function; (value: object): Function; }",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "(prefix?: string) => string",
          "optional": false
        },
        {
          "name": "escape",
          "type": "(str: string) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "(str: string) => string",
          "optional": false
        },
        {
          "name": "result",
          "type": "(object: any, property: string, defaultValue?: any) => any",
          "optional": false
        },
        {
          "name": "template",
          "type": "(templateString: string, settings?: TemplateSettings) => CompiledTemplate",
          "optional": false
        },
        {
          "name": "templateSettings",
          "type": "TemplateSettings",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "chain",
          "type": "<V>(value: V) => _Chain<TypeOfCollection<V, never>, V>",
          "optional": false
        },
        {
          "name": "VERSION",
          "type": "string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Underscore",
      "type": "Underscore<T, V>",
      "properties": [
        {
          "name": "each",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
          "optional": false
        },
        {
          "name": "map",
          "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => IterateeResult<I, T>[]",
          "optional": false
        },
        {
          "name": "collect",
          "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => IterateeResult<I, T>[]",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
          "optional": false
        },
        {
          "name": "inject",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
          "optional": false
        },
        {
          "name": "foldl",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
          "optional": false
        },
        {
          "name": "foldr",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T",
          "optional": false
        },
        {
          "name": "detect",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
          "optional": false
        },
        {
          "name": "select",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
          "optional": false
        },
        {
          "name": "where",
          "type": "(properties: Partial<T>) => T[]",
          "optional": false
        },
        {
          "name": "findWhere",
          "type": "(properties: Partial<T>) => T",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
          "optional": false
        },
        {
          "name": "every",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "all",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "some",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "any",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
          "optional": false
        },
        {
          "name": "contains",
          "type": "(value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "include",
          "type": "(value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(value: any, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(methodName: string, ...args: any[]) => any[]",
          "optional": false
        },
        {
          "name": "pluck",
          "type": "<K extends string | number>(propertyName: K) => PropertyTypeOrAny<T, K>[]",
          "optional": false
        },
        {
          "name": "max",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | T",
          "optional": false
        },
        {
          "name": "min",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | T",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => T[]",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<T[]>",
          "optional": false
        },
        {
          "name": "indexBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<T>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<number>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ (n: number): T[]; (): T; }",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => [T[], T[]]",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ (): T; (n: number): T[]; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ (): T; (n: number): T[]; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "{ (): T; (n: number): T[]; }",
          "optional": false
        },
        {
          "name": "initial",
          "type": "(n?: number) => T[]",
          "optional": false
        },
        {
          "name": "last",
          "type": "{ (): T; (n: number): T[]; }",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(n?: number) => T[]",
          "optional": false
        },
        {
          "name": "tail",
          "type": "(n?: number) => T[]",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(n?: number) => T[]",
          "optional": false
        },
        {
          "name": "compact",
          "type": "() => Exclude<T, AnyFalsy>[]",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "{ (depth: true | 1): ListItemOrSelf<T>[]; (depth?: number | false): DeepestListItemOrSelf<T>[]; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "(...values: T[]) => T[]",
          "optional": false
        },
        {
          "name": "union",
          "type": "(...lists: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "(...lists: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "difference",
          "type": "(...others: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, cotext?: any): T[]; (iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): T[]; }",
          "optional": false
        },
        {
          "name": "unique",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, cotext?: any): T[]; (iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): T[]; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ (): V extends List<infer A> ? [A][] : []; <A, B>(lists_0: List<A>, lists_1: List<B>): [T, A, B][]; <A>(list: List<A>): [T, A][]; (...lists: List<...>[]): T[][]; (...lists: List<...>[]): any[][]; }",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "() => T extends [infer A, infer B, infer C] ? [A[], B[], C[]] : T extends [infer A, infer B] ? [A[], B[]] : T extends [infer A] ? [A[]] : T extends List<...> ? A[][] : []",
          "optional": false
        },
        {
          "name": "transpose",
          "type": "() => T extends [infer A, infer B, infer C] ? [A[], B[], C[]] : T extends [infer A, infer B] ? [A[], B[]] : T extends [infer A] ? [A[]] : T extends List<...> ? A[][] : []",
          "optional": false
        },
        {
          "name": "object",
          "type": "{ <TValue>(values: List<TValue>): Dictionary<TValue>; (): Dictionary<PairValue<T>>; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(value: T, isSortedOrFromIndex?: number | boolean) => number",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(value: T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "(value: T, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number",
          "optional": false
        },
        {
          "name": "range",
          "type": "(stop?: number, step?: number) => number[]",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "(length: number) => T[][]",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(object: any, ...args: any[]) => Function",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: string[]) => any",
          "optional": false
        },
        {
          "name": "partial",
          "type": "(...args: any[]) => Function",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "(hashFn?: (n: any) => string) => Function",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "delay",
          "type": "{ (wait: number, ...args: any[]): any; (...args: any[]): any; }",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "(wait: number, options?: ThrottleSettings) => Function & Cancelable",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "(wait: number, immediate?: boolean) => Function & Cancelable",
          "optional": false
        },
        {
          "name": "once",
          "type": "() => Function",
          "optional": false
        },
        {
          "name": "restArgs",
          "type": "(starIndex?: number) => Function",
          "optional": false
        },
        {
          "name": "after",
          "type": "(fn: Function) => Function",
          "optional": false
        },
        {
          "name": "before",
          "type": "(fn: Function) => Function",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "(wrapper: Function) => () => Function",
          "optional": false
        },
        {
          "name": "negate",
          "type": "() => (...args: any[]) => boolean",
          "optional": false
        },
        {
          "name": "compose",
          "type": "(...functions: Function[]) => Function",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "allKeys",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "mapObject",
          "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => { [K in keyof V]: IterateeResult<I, V[K]>; }",
          "optional": false
        },
        {
          "name": "pairs",
          "type": "() => [Extract<keyof V, string>, TypeOfCollection<V, any>][]",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "methods",
          "type": "() => string[]",
          "optional": false
        },
        {
          "name": "extend",
          "type": "(...sources: any[]) => any",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => Extract<keyof V, string>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _Pick<V, K>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<V>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _Omit<V, K>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<V>; }",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "(...defaults: any[]) => any",
          "optional": false
        },
        {
          "name": "create",
          "type": "(props?: object) => any",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (...as: any[]) => any) => any",
          "optional": false
        },
        {
          "name": "has",
          "type": "(key: string) => boolean",
          "optional": false
        },
        {
          "name": "matches",
          "type": "() => ListIterator<T, boolean, List<T>>",
          "optional": false
        },
        {
          "name": "matcher",
          "type": "() => ListIterator<T, boolean, List<T>>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: string): TypeOfCollection<V, never>; <U>(path: string, defaultValue?: U): TypeOfCollection<V, never> | U; <P extends Array<string | number>, U = undefined>(path: [......], defaultValue?: U): U | DeepTypeOfCollection<...>; }",
          "optional": false
        },
        {
          "name": "property",
          "type": "() => (object: any) => any",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => (key: string) => any",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(properties: any) => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDataView",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => () => T",
          "optional": false
        },
        {
          "name": "noop",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "times",
          "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => TResult[]",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (): number; (max: number): number; }",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(context?: any) => Function",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "result",
          "type": "(property: string, defaultValue?: any) => any",
          "optional": false
        },
        {
          "name": "template",
          "type": "(settings?: TemplateSettings) => CompiledTemplate",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => _Chain<T, V>",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => V",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_Chain",
      "type": "_Chain<T, V>",
      "properties": [
        {
          "name": "each",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<T, V>",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<T, V>",
          "optional": false
        },
        {
          "name": "map",
          "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, T>, IterateeResult<I, T>[]>",
          "optional": false
        },
        {
          "name": "collect",
          "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, T>, IterateeResult<I, T>[]>",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "inject",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "foldl",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "foldr",
          "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "detect",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "select",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "where",
          "type": "(properties: Partial<T>) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "findWhere",
          "type": "(properties: Partial<T>) => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "all",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "any",
          "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "contains",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "include",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(methodName: string, ...args: any[]) => _Chain<any, any[]>",
          "optional": false
        },
        {
          "name": "pluck",
          "type": "<K extends string | number>(propertyName: K) => _Chain<PropertyTypeOrAny<T, K>, PropertyTypeOrAny<T, K>[]>",
          "optional": false
        },
        {
          "name": "max",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | T>",
          "optional": false
        },
        {
          "name": "min",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | T>",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<T[], Dictionary<T[]>>",
          "optional": false
        },
        {
          "name": "indexBy",
          "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<T, Dictionary<T>>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iterator?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<number, Dictionary<number>>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ (n: number): _Chain<T, T[]>; (): _ChainSingle<T>; }",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<T[], [T[], T[]]>",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "initial",
          "type": "(n?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "last",
          "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(n?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "tail",
          "type": "(n?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(n?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "compact",
          "type": "() => _Chain<Exclude<T, AnyFalsy>, Exclude<T, AnyFalsy>[]>",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "{ (depth: true | 1): _Chain<ListItemOrSelf<T>, ListItemOrSelf<T>[]>; (depth?: number | false): _Chain<DeepestListItemOrSelf<T>, DeepestListItemOrSelf<...>[]>; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "(...values: T[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "union",
          "type": "(...lists: List<T>[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "(...lists: List<T>[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "difference",
          "type": "(...others: List<T>[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<T, T[]>; (iteratee?: Iteratee<V, any, TypeOfCollection<...>>, context?: any): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "unique",
          "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<T, T[]>; (iteratee?: Iteratee<V, any, TypeOfCollection<...>>, context?: any): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ (): V extends List<infer A> ? _Chain<[A], [A][]> : _Chain<never, []>; <A, B>(arrays_0: List<A>, arrays_1: List<B>): _Chain<[T, A, B], [...][]>; <A>(array: List<...>): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "() => T extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : T extends [infer A, infer B] ? _Chain<A[] | B[], [A[], B[]]> : T extends [...] ? _Chain<...> : T extends List<...> ? _Chain<...> : _Chain<...>",
          "optional": false
        },
        {
          "name": "transpose",
          "type": "() => T extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : T extends [infer A, infer B] ? _Chain<A[] | B[], [A[], B[]]> : T extends [...] ? _Chain<...> : T extends List<...> ? _Chain<...> : _Chain<...>",
          "optional": false
        },
        {
          "name": "object",
          "type": "{ <TValue>(values: List<TValue>): _Chain<TValue, Dictionary<TValue>>; (): _Chain<PairValue<T>, Dictionary<PairValue<T>>>; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(value: T, isSortedOrFromIndex?: number | boolean) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(value: T, fromIndex?: number) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "(value: T, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(stop?: number, step?: number) => _Chain<number, number[]>",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "(length: number) => _Chain<T[], T[][]>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(object: any, ...args: any[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: string[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "partial",
          "type": "(...args: any[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "(hashFn?: (n: any) => string) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "{ (wait: number, ...args: any[]): _Chain<T, T[]>; (...args: any[]): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "(wait: number, options?: ThrottleSettings) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "(wait: number, immediate?: boolean) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "once",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "restArgs",
          "type": "(startIndex?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "after",
          "type": "(func: Function) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "before",
          "type": "(fn: Function) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "(wrapper: Function) => () => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "negate",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "compose",
          "type": "(...functions: Function[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => _Chain<string, string[]>",
          "optional": false
        },
        {
          "name": "allKeys",
          "type": "() => _Chain<string, string[]>",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => _Chain<any, any[]>",
          "optional": false
        },
        {
          "name": "mapObject",
          "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, any>>, { [K in keyof V]: IterateeResult<...>; }>",
          "optional": false
        },
        {
          "name": "pairs",
          "type": "() => _Chain<[Extract<keyof V, string>, TypeOfCollection<V, any>], [Extract<keyof V, string>, TypeOfCollection<V, any>][]>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "methods",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "extend",
          "type": "(...sources: any[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => _ChainSingle<Extract<keyof V, string>>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Pick<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Omit<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "(...defaults: any[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "create",
          "type": "(props?: object) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (...as: any[]) => any) => _Chain<T, V>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(key: string) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "matcher",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: string): _Chain<TypeOfCollection<V, never>, T>; <U>(path: string, defaultValue?: U): _Chain<TypeOfCollection<V, never> | U, T | U>; <P extends Array<string | number>, W = DeepTypeOfCollection<...>, U = undefined>(path: [......], defaultValue?: U): _Chain<...>; }",
          "optional": false
        },
        {
          "name": "property",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(properties: any) => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isDataView",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => _ChainSingle<boolean>",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => _ChainSingle<V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never>",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "times",
          "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (): _Chain<T, T[]>; (max: number): _Chain<T, T[]>; }",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(context?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "result",
          "type": "(property: string, defaultValue?: any) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(settings?: TemplateSettings) => _Chain<CompiledTemplate, CompiledTemplate[]>",
          "optional": false
        },
        {
          "name": "concat",
          "type": "(...arr: T[][]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: any) => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "pop",
          "type": "() => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...item: T[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start: number, end?: number) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: T, b: T) => boolean) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "(index: number, quantity: number, ...items: T[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => _ChainSingle<T>",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: T[]) => _Chain<T, T[]>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => _Chain<T, V>",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => V",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    }
  ],
  "classes": [],
  "constants": [
    {
      "name": "_",
      "type": "UnderscoreStatic",
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_.VERSION",
      "type": "string",
      "value": "\"1.13.6\"",
      "jsdoc": {
        "description": "Current version",
        "deprecated": false
      },
      "isExported": false
    }
  ],
  "namespaces": [
    {
      "name": "underscore",
      "contents": {
        "functions": [],
        "enums": [],
        "types": [
          {
            "name": "List",
            "type": "List<T>",
            "properties": [
              {
                "name": "length",
                "type": "number",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Dictionary",
            "type": "Dictionary<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          }
        ],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": true
    },
    {
      "name": "__global",
      "contents": {
        "functions": [],
        "enums": [],
        "types": [
          {
            "name": "Element",
            "type": "Element",
            "properties": [
              {
                "name": "attributes",
                "type": "NamedNodeMap",
                "optional": false
              },
              {
                "name": "classList",
                "type": "DOMTokenList",
                "optional": false
              },
              {
                "name": "className",
                "type": "string",
                "optional": false
              },
              {
                "name": "clientHeight",
                "type": "number",
                "optional": false
              },
              {
                "name": "clientLeft",
                "type": "number",
                "optional": false
              },
              {
                "name": "clientTop",
                "type": "number",
                "optional": false
              },
              {
                "name": "clientWidth",
                "type": "number",
                "optional": false
              },
              {
                "name": "currentCSSZoom",
                "type": "number",
                "optional": false
              },
              {
                "name": "id",
                "type": "string",
                "optional": false
              },
              {
                "name": "innerHTML",
                "type": "string",
                "optional": false
              },
              {
                "name": "localName",
                "type": "string",
                "optional": false
              },
              {
                "name": "namespaceURI",
                "type": "string",
                "optional": false
              },
              {
                "name": "onfullscreenchange",
                "type": "(this: Element, ev: Event) => any",
                "optional": false
              },
              {
                "name": "onfullscreenerror",
                "type": "(this: Element, ev: Event) => any",
                "optional": false
              },
              {
                "name": "outerHTML",
                "type": "string",
                "optional": false
              },
              {
                "name": "ownerDocument",
                "type": "Document",
                "optional": false
              },
              {
                "name": "part",
                "type": "DOMTokenList",
                "optional": false
              },
              {
                "name": "prefix",
                "type": "string",
                "optional": false
              },
              {
                "name": "scrollHeight",
                "type": "number",
                "optional": false
              },
              {
                "name": "scrollLeft",
                "type": "number",
                "optional": false
              },
              {
                "name": "scrollTop",
                "type": "number",
                "optional": false
              },
              {
                "name": "scrollWidth",
                "type": "number",
                "optional": false
              },
              {
                "name": "shadowRoot",
                "type": "ShadowRoot",
                "optional": false
              },
              {
                "name": "slot",
                "type": "string",
                "optional": false
              },
              {
                "name": "tagName",
                "type": "string",
                "optional": false
              },
              {
                "name": "attachShadow",
                "type": "(init: ShadowRootInit) => ShadowRoot",
                "optional": false
              },
              {
                "name": "checkVisibility",
                "type": "(options?: CheckVisibilityOptions) => boolean",
                "optional": false
              },
              {
                "name": "closest",
                "type": "{ <K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K]; <K extends keyof SVGElementTagNameMap>(selector: K): SVGElementTagNameMap[K]; <K extends keyof MathMLElementTagNameMap>(selector: K): MathMLElementTagNameMap[K]; <E extends Element = Element>(selectors: string): E; }",
                "optional": false
              },
              {
                "name": "computedStyleMap",
                "type": "() => StylePropertyMapReadOnly",
                "optional": false
              },
              {
                "name": "getAttribute",
                "type": "(qualifiedName: string) => string",
                "optional": false
              },
              {
                "name": "getAttributeNS",
                "type": "(namespace: string, localName: string) => string",
                "optional": false
              },
              {
                "name": "getAttributeNames",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "getAttributeNode",
                "type": "(qualifiedName: string) => Attr",
                "optional": false
              },
              {
                "name": "getAttributeNodeNS",
                "type": "(namespace: string, localName: string) => Attr",
                "optional": false
              },
              {
                "name": "getBoundingClientRect",
                "type": "() => DOMRect",
                "optional": false
              },
              {
                "name": "getClientRects",
                "type": "() => DOMRectList",
                "optional": false
              },
              {
                "name": "getElementsByClassName",
                "type": "(classNames: string) => HTMLCollectionOf<Element>",
                "optional": false
              },
              {
                "name": "getElementsByTagName",
                "type": "{ <K extends keyof HTMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<HTMLElementTagNameMap[K]>; <K extends keyof SVGElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<...>; <K extends keyof MathMLElementTagNameMap>(qualifiedName: K): HTMLCollectionOf<...>; <K extends keyof HTMLElementDeprecatedTagNameMa...",
                "optional": false
              },
              {
                "name": "getElementsByTagNameNS",
                "type": "{ (namespaceURI: \"http://www.w3.org/1999/xhtml\", localName: string): HTMLCollectionOf<HTMLElement>; (namespaceURI: \"http://www.w3.org/2000/svg\", localName: string): HTMLCollectionOf<...>; (namespaceURI: \"http://www.w3.org/1998/Math/MathML\", localName: string): HTMLCollectionOf<...>; (namespace: string, localName: st...",
                "optional": false
              },
              {
                "name": "getHTML",
                "type": "(options?: GetHTMLOptions) => string",
                "optional": false
              },
              {
                "name": "hasAttribute",
                "type": "(qualifiedName: string) => boolean",
                "optional": false
              },
              {
                "name": "hasAttributeNS",
                "type": "(namespace: string, localName: string) => boolean",
                "optional": false
              },
              {
                "name": "hasAttributes",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "hasPointerCapture",
                "type": "(pointerId: number) => boolean",
                "optional": false
              },
              {
                "name": "insertAdjacentElement",
                "type": "(where: InsertPosition, element: Element) => Element",
                "optional": false
              },
              {
                "name": "insertAdjacentHTML",
                "type": "(position: InsertPosition, string: string) => void",
                "optional": false
              },
              {
                "name": "insertAdjacentText",
                "type": "(where: InsertPosition, data: string) => void",
                "optional": false
              },
              {
                "name": "matches",
                "type": "(selectors: string) => boolean",
                "optional": false
              },
              {
                "name": "releasePointerCapture",
                "type": "(pointerId: number) => void",
                "optional": false
              },
              {
                "name": "removeAttribute",
                "type": "(qualifiedName: string) => void",
                "optional": false
              },
              {
                "name": "removeAttributeNS",
                "type": "(namespace: string, localName: string) => void",
                "optional": false
              },
              {
                "name": "removeAttributeNode",
                "type": "(attr: Attr) => Attr",
                "optional": false
              },
              {
                "name": "requestFullscreen",
                "type": "(options?: FullscreenOptions) => Promise<void>",
                "optional": false
              },
              {
                "name": "requestPointerLock",
                "type": "(options?: PointerLockOptions) => Promise<void>",
                "optional": false
              },
              {
                "name": "scroll",
                "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
                "optional": false
              },
              {
                "name": "scrollBy",
                "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
                "optional": false
              },
              {
                "name": "scrollIntoView",
                "type": "(arg?: boolean | ScrollIntoViewOptions) => void",
                "optional": false
              },
              {
                "name": "scrollTo",
                "type": "{ (options?: ScrollToOptions): void; (x: number, y: number): void; }",
                "optional": false
              },
              {
                "name": "setAttribute",
                "type": "(qualifiedName: string, value: string) => void",
                "optional": false
              },
              {
                "name": "setAttributeNS",
                "type": "(namespace: string, qualifiedName: string, value: string) => void",
                "optional": false
              },
              {
                "name": "setAttributeNode",
                "type": "(attr: Attr) => Attr",
                "optional": false
              },
              {
                "name": "setAttributeNodeNS",
                "type": "(attr: Attr) => Attr",
                "optional": false
              },
              {
                "name": "setHTMLUnsafe",
                "type": "(html: string) => void",
                "optional": false
              },
              {
                "name": "setPointerCapture",
                "type": "(pointerId: number) => void",
                "optional": false
              },
              {
                "name": "toggleAttribute",
                "type": "(qualifiedName: string, force?: boolean) => boolean",
                "optional": false
              },
              {
                "name": "webkitMatchesSelector",
                "type": "(selectors: string) => boolean",
                "optional": false
              },
              {
                "name": "addEventListener",
                "type": "{ <K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void; (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void; }",
                "optional": false
              },
              {
                "name": "removeEventListener",
                "type": "{ <K extends keyof ElementEventMap>(type: K, listener: (this: Element, ev: ElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void; (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void; }",
                "optional": false
              },
              {
                "name": "baseURI",
                "type": "string",
                "optional": false
              },
              {
                "name": "childNodes",
                "type": "NodeListOf<ChildNode>",
                "optional": false
              },
              {
                "name": "firstChild",
                "type": "ChildNode",
                "optional": false
              },
              {
                "name": "isConnected",
                "type": "boolean",
                "optional": false
              },
              {
                "name": "lastChild",
                "type": "ChildNode",
                "optional": false
              },
              {
                "name": "nextSibling",
                "type": "ChildNode",
                "optional": false
              },
              {
                "name": "nodeName",
                "type": "string",
                "optional": false
              },
              {
                "name": "nodeType",
                "type": "number",
                "optional": false
              },
              {
                "name": "nodeValue",
                "type": "string",
                "optional": false
              },
              {
                "name": "parentElement",
                "type": "HTMLElement",
                "optional": false
              },
              {
                "name": "parentNode",
                "type": "ParentNode",
                "optional": false
              },
              {
                "name": "previousSibling",
                "type": "ChildNode",
                "optional": false
              },
              {
                "name": "textContent",
                "type": "string",
                "optional": false
              },
              {
                "name": "appendChild",
                "type": "<T extends Node>(node: T) => T",
                "optional": false
              },
              {
                "name": "cloneNode",
                "type": "(subtree?: boolean) => Node",
                "optional": false
              },
              {
                "name": "compareDocumentPosition",
                "type": "(other: Node) => number",
                "optional": false
              },
              {
                "name": "contains",
                "type": "(other: Node) => boolean",
                "optional": false
              },
              {
                "name": "getRootNode",
                "type": "(options?: GetRootNodeOptions) => Node",
                "optional": false
              },
              {
                "name": "hasChildNodes",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "insertBefore",
                "type": "<T extends Node>(node: T, child: Node) => T",
                "optional": false
              },
              {
                "name": "isDefaultNamespace",
                "type": "(namespace: string) => boolean",
                "optional": false
              },
              {
                "name": "isEqualNode",
                "type": "(otherNode: Node) => boolean",
                "optional": false
              },
              {
                "name": "isSameNode",
                "type": "(otherNode: Node) => boolean",
                "optional": false
              },
              {
                "name": "lookupNamespaceURI",
                "type": "(prefix: string) => string",
                "optional": false
              },
              {
                "name": "lookupPrefix",
                "type": "(namespace: string) => string",
                "optional": false
              },
              {
                "name": "normalize",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "removeChild",
                "type": "<T extends Node>(child: T) => T",
                "optional": false
              },
              {
                "name": "replaceChild",
                "type": "<T extends Node>(node: Node, child: T) => T",
                "optional": false
              },
              {
                "name": "ELEMENT_NODE",
                "type": "1",
                "optional": false
              },
              {
                "name": "ATTRIBUTE_NODE",
                "type": "2",
                "optional": false
              },
              {
                "name": "TEXT_NODE",
                "type": "3",
                "optional": false
              },
              {
                "name": "CDATA_SECTION_NODE",
                "type": "4",
                "optional": false
              },
              {
                "name": "ENTITY_REFERENCE_NODE",
                "type": "5",
                "optional": false
              },
              {
                "name": "ENTITY_NODE",
                "type": "6",
                "optional": false
              },
              {
                "name": "PROCESSING_INSTRUCTION_NODE",
                "type": "7",
                "optional": false
              },
              {
                "name": "COMMENT_NODE",
                "type": "8",
                "optional": false
              },
              {
                "name": "DOCUMENT_NODE",
                "type": "9",
                "optional": false
              },
              {
                "name": "DOCUMENT_TYPE_NODE",
                "type": "10",
                "optional": false
              },
              {
                "name": "DOCUMENT_FRAGMENT_NODE",
                "type": "11",
                "optional": false
              },
              {
                "name": "NOTATION_NODE",
                "type": "12",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_DISCONNECTED",
                "type": "1",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_PRECEDING",
                "type": "2",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_FOLLOWING",
                "type": "4",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_CONTAINS",
                "type": "8",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_CONTAINED_BY",
                "type": "16",
                "optional": false
              },
              {
                "name": "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC",
                "type": "32",
                "optional": false
              },
              {
                "name": "dispatchEvent",
                "type": "(event: Event) => boolean",
                "optional": false
              },
              {
                "name": "ariaAtomic",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaAutoComplete",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaBrailleLabel",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaBrailleRoleDescription",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaBusy",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaChecked",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaColCount",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaColIndex",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaColIndexText",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaColSpan",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaCurrent",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaDescription",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaDisabled",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaExpanded",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaHasPopup",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaHidden",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaInvalid",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaKeyShortcuts",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaLabel",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaLevel",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaLive",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaModal",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaMultiLine",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaMultiSelectable",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaOrientation",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaPlaceholder",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaPosInSet",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaPressed",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaReadOnly",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRelevant",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRequired",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRoleDescription",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRowCount",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRowIndex",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRowIndexText",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaRowSpan",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaSelected",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaSetSize",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaSort",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaValueMax",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaValueMin",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaValueNow",
                "type": "string",
                "optional": false
              },
              {
                "name": "ariaValueText",
                "type": "string",
                "optional": false
              },
              {
                "name": "role",
                "type": "string",
                "optional": false
              },
              {
                "name": "animate",
                "type": "(keyframes: Keyframe[] | PropertyIndexedKeyframes, options?: number | KeyframeAnimationOptions) => Animation",
                "optional": false
              },
              {
                "name": "getAnimations",
                "type": "(options?: GetAnimationsOptions) => Animation[]",
                "optional": false
              },
              {
                "name": "after",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "before",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "remove",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "replaceWith",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "nextElementSibling",
                "type": "Element",
                "optional": false
              },
              {
                "name": "previousElementSibling",
                "type": "Element",
                "optional": false
              },
              {
                "name": "childElementCount",
                "type": "number",
                "optional": false
              },
              {
                "name": "children",
                "type": "HTMLCollection",
                "optional": false
              },
              {
                "name": "firstElementChild",
                "type": "Element",
                "optional": false
              },
              {
                "name": "lastElementChild",
                "type": "Element",
                "optional": false
              },
              {
                "name": "append",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "prepend",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "querySelector",
                "type": "{ <K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K]; <K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K]; <K extends keyof MathMLElementTagNameMap>(selectors: K): MathMLElementTagNameMap[K]; <K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): HTMLE...",
                "optional": false
              },
              {
                "name": "querySelectorAll",
                "type": "{ <K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>; <K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<...>; <K extends keyof MathMLElementTagNameMap>(selectors: K): NodeListOf<...>; <K extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K): NodeListOf<....",
                "optional": false
              },
              {
                "name": "replaceChildren",
                "type": "(...nodes: (string | Node)[]) => void",
                "optional": false
              },
              {
                "name": "assignedSlot",
                "type": "HTMLSlotElement",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          }
        ],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "_",
      "contents": {
        "functions": [],
        "enums": [],
        "types": [
          {
            "name": "ThrottleSettings",
            "type": "ThrottleSettings",
            "properties": [
              {
                "name": "leading",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "trailing",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": {
              "description": "underscore.js _.throttle options.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "TemplateSettings",
            "type": "TemplateSettings",
            "properties": [
              {
                "name": "evaluate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "interpolate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "escape",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "variable",
                "type": "string",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": {
              "description": "underscore.js template settings, set templateSettings or pass as an argument\nto 'template()' to override defaults.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "CompiledTemplate",
            "type": "CompiledTemplate",
            "properties": [
              {
                "name": "source",
                "type": "string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Collection",
            "type": "Collection<T>",
            "properties": [
              {
                "name": "length",
                "type": "number | T",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CollectionKey",
            "type": "CollectionKey<V>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Predicate",
            "type": "Predicate<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CollectionIterator",
            "type": "CollectionIterator<T, TResult, V>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListIterator",
            "type": "ListIterator<T, TResult, V>",
            "properties": [],
            "extends": [
              "CollectionIterator<T, TResult, V>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectIterator",
            "type": "ObjectIterator<T, TResult, V>",
            "properties": [],
            "extends": [
              "CollectionIterator<T, TResult, V>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Iteratee",
            "type": "Iteratee<V, R, T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IterateeResult",
            "type": "IterateeResult<I, T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PropertyTypeOrAny",
            "type": "PropertyTypeOrAny<T, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoCollectionIterator",
            "type": "MemoCollectionIterator<T, TResult, V>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoIterator",
            "type": "MemoIterator<T, TResult, V>",
            "properties": [],
            "extends": [
              "MemoCollectionIterator<T, TResult, V>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoObjectIterator",
            "type": "MemoObjectIterator<T, TResult, V>",
            "properties": [],
            "extends": [
              "MemoCollectionIterator<T, TResult, V>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TypeOfList",
            "type": "TypeOfList<V>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TypeOfDictionary",
            "type": "TypeOfDictionary<V, TDefault>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TypeOfCollection",
            "type": "TypeOfCollection<V, TObjectDefault>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DeepTypeOfCollection",
            "type": "DeepTypeOfCollection<V, P>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListItemOrSelf",
            "type": "ListItemOrSelf<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DeepestListItemOrSelf",
            "type": "DeepestListItemOrSelf<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PairValue",
            "type": "PairValue<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "AnyFalsy",
            "type": "AnyFalsy",
            "properties": [
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => boolean)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Truthy",
            "type": "Truthy<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "_Pick",
            "type": "_Pick<V, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "_Omit",
            "type": "_Omit<V, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "_ChainSingle",
            "type": "_ChainSingle<V>",
            "properties": [
              {
                "name": "each",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<TypeOfCollection<V, never>, V>",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<TypeOfCollection<V, never>, V>",
                "optional": false
              },
              {
                "name": "map",
                "type": "<I extends Iteratee<V, any, TypeOfCollection<V, never>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, never>>, IterateeResult<...>[]>",
                "optional": false
              },
              {
                "name": "collect",
                "type": "<I extends Iteratee<V, any, TypeOfCollection<V, never>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, never>>, IterateeResult<...>[]>",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "inject",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "foldl",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "foldr",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "detect",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "select",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "where",
                "type": "(properties: Partial<TypeOfCollection<V, never>>) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "findWhere",
                "type": "(properties: Partial<TypeOfCollection<V, never>>) => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "all",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "any",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "contains",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "include",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(methodName: string, ...args: any[]) => _Chain<any, any[]>",
                "optional": false
              },
              {
                "name": "pluck",
                "type": "<K extends string | number>(propertyName: K) => _Chain<PropertyTypeOrAny<TypeOfCollection<V, never>, K>, PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]>",
                "optional": false
              },
              {
                "name": "max",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "min",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>[], Dictionary<...>>",
                "optional": false
              },
              {
                "name": "indexBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>, Dictionary<...>>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iterator?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<number, Dictionary<number>>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (): _ChainSingle<TypeOfCollection<V, never>>; }",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<TypeOfCollection<V, never>[], [TypeOfCollection<...>[], TypeOfCollection<...>[]]>",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
                "optional": false
              },
              {
                "name": "initial",
                "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "last",
                "type": "{ (): _ChainSingle<TypeOfCollection<V, never>>; (n: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; }",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "tail",
                "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(n?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "compact",
                "type": "() => _Chain<Exclude<TypeOfCollection<V, never>, AnyFalsy>, Exclude<TypeOfCollection<V, never>, AnyFalsy>[]>",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "{ (depth: true | 1): _Chain<ListItemOrSelf<TypeOfCollection<V, never>>, ListItemOrSelf<TypeOfCollection<V, never>>[]>; (depth?: number | false): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "(...values: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "union",
                "type": "(...lists: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "(...lists: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "difference",
                "type": "(...others: List<TypeOfCollection<V, never>>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; (iteratee?: Iteratee<...>, context?: any): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "unique",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; (iteratee?: Iteratee<...>, context?: any): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ (): V extends List<infer A> ? _Chain<[A], [A][]> : _Chain<never, []>; <A, B>(arrays_0: List<A>, arrays_1: List<B>): _Chain<[TypeOfCollection<V, never>, A, B], [...][]>; <A>(array: List<...>): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "() => TypeOfCollection<V, never> extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : TypeOfCollection<V, never> extends [...] ? _Chain<...> : TypeOfCollection<...> extends [...] ? _Chain<...> : TypeOfCollection<...> extends List<...> ? _Chain<...> : _Chain<...>",
                "optional": false
              },
              {
                "name": "transpose",
                "type": "() => TypeOfCollection<V, never> extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : TypeOfCollection<V, never> extends [...] ? _Chain<...> : TypeOfCollection<...> extends [...] ? _Chain<...> : TypeOfCollection<...> extends List<...> ? _Chain<...> : _Chain<...>",
                "optional": false
              },
              {
                "name": "object",
                "type": "{ <TValue>(values: List<TValue>): _Chain<TValue, Dictionary<TValue>>; (): _Chain<PairValue<TypeOfCollection<V, never>>, Dictionary<...>>; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(value: TypeOfCollection<V, never>, isSortedOrFromIndex?: number | boolean) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(value: TypeOfCollection<V, never>, fromIndex?: number) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "(value: TypeOfCollection<V, never>, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(stop?: number, step?: number) => _Chain<number, number[]>",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "(length: number) => _Chain<TypeOfCollection<V, never>[], TypeOfCollection<V, never>[][]>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(object: any, ...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: string[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "partial",
                "type": "(...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "(hashFn?: (n: any) => string) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "{ (wait: number, ...args: any[]): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (...args: any[]): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; }",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "(wait: number, options?: ThrottleSettings) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "(wait: number, immediate?: boolean) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "once",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "restArgs",
                "type": "(startIndex?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "after",
                "type": "(func: Function) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "before",
                "type": "(fn: Function) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "(wrapper: Function) => () => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "negate",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "compose",
                "type": "(...functions: Function[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => _Chain<string, string[]>",
                "optional": false
              },
              {
                "name": "allKeys",
                "type": "() => _Chain<string, string[]>",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => _Chain<any, any[]>",
                "optional": false
              },
              {
                "name": "mapObject",
                "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, any>>, { [K in keyof V]: IterateeResult<...>; }>",
                "optional": false
              },
              {
                "name": "pairs",
                "type": "() => _Chain<[Extract<keyof V, string>, TypeOfCollection<V, any>], [Extract<keyof V, string>, TypeOfCollection<V, any>][]>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "methods",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "extend",
                "type": "(...sources: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => _ChainSingle<Extract<keyof V, string>>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Pick<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Omit<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "(...defaults: any[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "create",
                "type": "(props?: object) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (...as: any[]) => any) => _Chain<TypeOfCollection<V, never>, V>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(key: string) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "matcher",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: string): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>>; <U>(path: string, defaultValue?: U): _Chain<...>; <P extends Array<string | number>, W = DeepTypeOfCollection<...>, U = undefined>(path: [......], defaultValue?: U): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "property",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(properties: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isDataView",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => _ChainSingle<V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never>",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "times",
                "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (): _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>; (max: number): _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>; }",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "(context?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "result",
                "type": "(property: string, defaultValue?: any) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(settings?: TemplateSettings) => _Chain<CompiledTemplate, CompiledTemplate[]>",
                "optional": false
              },
              {
                "name": "concat",
                "type": "(...arr: TypeOfCollection<V, never>[][]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: any) => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "pop",
                "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...item: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start: number, end?: number) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: TypeOfCollection<V, never>, b: TypeOfCollection<V, never>) => boolean) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<...>[]>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "(index: number, quantity: number, ...items: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => _ChainSingle<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: TypeOfCollection<V, never>[]) => _Chain<TypeOfCollection<V, never>, TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => _Chain<TypeOfCollection<V, never>, V>",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => V",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TypedArray",
            "type": "TypedArray",
            "properties": [
              {
                "name": "BYTES_PER_ELEMENT",
                "type": "number",
                "optional": false
              },
              {
                "name": "buffer",
                "type": "ArrayBufferLike",
                "optional": false
              },
              {
                "name": "byteLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "byteOffset",
                "type": "number",
                "optional": false
              },
              {
                "name": "copyWithin",
                "type": "((target: number, start: number, end?: number) => Int8Array<ArrayBufferLike>) | ((target: number, start: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((target: number, start: number, end?: number) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "every",
                "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean) | ((predicate: (value: number, index: number, array: Uint8Array<...>) => unknown, thisArg?: any) => boolean) | ... 6 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) =...",
                "optional": false
              },
              {
                "name": "fill",
                "type": "((value: number, start?: number, end?: number) => Int8Array<ArrayBufferLike>) | ((value: number, start?: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((value: number, start?: number, end?: number) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "filter",
                "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => any, thisArg?: any) => Int8Array<ArrayBuffer>) | ... 7 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) => any, thisArg?: any) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "find",
                "type": "((predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number) | ((predicate: (value: number, index: number, obj: Uint8Array<...>) => boolean, thisArg?: any) => number) | ... 6 more ... | ((predicate: (value: number, index: number, obj: Float64Array<...>) => boolea...",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "((predicate: (value: number, index: number, obj: Int8Array<ArrayBufferLike>) => boolean, thisArg?: any) => number) | ((predicate: (value: number, index: number, obj: Uint8Array<...>) => boolean, thisArg?: any) => number) | ... 6 more ... | ((predicate: (value: number, index: number, obj: Float64Array<...>) => boolea...",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "((callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => void, thisArg?: any) => void) | ((callbackfn: (value: number, index: number, array: Uint8Array<...>) => void, thisArg?: any) => void) | ... 6 more ... | ((callbackfn: (value: number, index: number, array: Float64Array<...>) => void, t...",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => number)",
                "optional": false
              },
              {
                "name": "join",
                "type": "((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string) | ((separator?: string) => string)",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ((searchElement: number, fromIndex?: number) => number) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => number)",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": false
              },
              {
                "name": "map",
                "type": "((callbackfn: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => number, thisArg?: any) => Int8Array<ArrayBuffer>) | ... 7 more ... | ((callbackfn: (value: number, index: number, array: Float64Array<...>) => number, thisArg?: any) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<...>) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<ArrayBufferLike>) => number): number; (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Int8Array<...>) => number, initialValue: number): number; <U>(callbackfn: (previousValue: U...",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "(() => Int8Array<ArrayBufferLike>) | (() => Uint8Array<ArrayBufferLike>) | (() => Int16Array<ArrayBufferLike>) | ... 5 more ... | (() => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "set",
                "type": "((array: ArrayLike<number>, offset?: number) => void) | ((array: ArrayLike<number>, offset?: number) => void) | ((array: ArrayLike<number>, offset?: number) => void) | ... 5 more ... | ((array: ArrayLike<...>, offset?: number) => void)",
                "optional": false
              },
              {
                "name": "slice",
                "type": "((start?: number, end?: number) => Int8Array<ArrayBuffer>) | ((start?: number, end?: number) => Uint8Array<ArrayBuffer>) | ((start?: number, end?: number) => Int16Array<...>) | ... 5 more ... | ((start?: number, end?: number) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "some",
                "type": "((predicate: (value: number, index: number, array: Int8Array<ArrayBufferLike>) => unknown, thisArg?: any) => boolean) | ((predicate: (value: number, index: number, array: Uint8Array<...>) => unknown, thisArg?: any) => boolean) | ... 6 more ... | ((predicate: (value: number, index: number, array: Float64Array<...>) =...",
                "optional": false
              },
              {
                "name": "sort",
                "type": "((compareFn?: (a: number, b: number) => number) => Int8Array<ArrayBufferLike>) | ((compareFn?: (a: number, b: number) => number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((compareFn?: (a: number, b: number) => number) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "subarray",
                "type": "((begin?: number, end?: number) => Int8Array<ArrayBufferLike>) | ((begin?: number, end?: number) => Uint8Array<ArrayBufferLike>) | ... 6 more ... | ((begin?: number, end?: number) => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions): string; } | { (): string; (locales: string | string[], options?: NumberFormatOptions): string; } | ... 6 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "toString",
                "type": "(() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => Int8Array<ArrayBufferLike>) | (() => Uint8Array<ArrayBufferLike>) | (() => Int16Array<ArrayBufferLike>) | ... 5 more ... | (() => Float64Array<...>)",
                "optional": false
              },
              {
                "name": "entries",
                "type": "(() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | (() => ArrayIterator<[number, number]>) | ... 4 more ... | (() => ArrayIterator<...>)",
                "optional": false
              },
              {
                "name": "keys",
                "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
                "optional": false
              },
              {
                "name": "values",
                "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
                "optional": false
              },
              {
                "name": "includes",
                "type": "((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ((searchElement: number, fromIndex?: number) => boolean) | ... 4 more ... | ((searchElement: number, fromIndex?: number) => boolean)",
                "optional": false
              },
              {
                "name": "__@iterator@33146",
                "type": "(() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | (() => ArrayIterator<number>) | ... 4 more ... | (() => ArrayIterator<...>)",
                "optional": false
              },
              {
                "name": "__@toStringTag@34581",
                "type": "\"Int8Array\" | \"Uint8Array\" | \"Int16Array\" | \"Uint16Array\" | \"Int32Array\" | \"Uint32Array\" | \"Uint8ClampedArray\" | \"Float32Array\" | \"Float64Array\"",
                "optional": false
              },
              {
                "name": "at",
                "type": "(index: number) => number",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Cancelable",
            "type": "Cancelable",
            "properties": [
              {
                "name": "cancel",
                "type": "() => void",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "UnderscoreStatic",
            "type": "UnderscoreStatic",
            "properties": [
              {
                "name": "each",
                "type": "<V extends Collection<any>>(collection: V, iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "<V extends Collection<any>>(collection: V, iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
                "optional": false
              },
              {
                "name": "map",
                "type": "<V extends Collection<any>, I extends Iteratee<V, any>>(collection: V, iteratee: I, context?: any) => IterateeResult<I, TypeOfCollection<V, never>>[]",
                "optional": false
              },
              {
                "name": "collect",
                "type": "<V extends Collection<any>, I extends Iteratee<V, any>>(collection: V, iteratee: I, context?: any) => IterateeResult<I, TypeOfCollection<V, never>>[]",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "inject",
                "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "foldl",
                "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "foldr",
                "type": "{ <V extends Collection<any>, TResult>(collection: V, iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <V extends Collection<any>, TResult = TypeOfCollection<...>>(collection: V, iteratee: MemoCollectionIterator<...>): TResult | TypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>",
                "optional": false
              },
              {
                "name": "detect",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "select",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "where",
                "type": "<V extends Collection<any>>(collection: V, properties: Partial<TypeOfCollection<V, never>>) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "findWhere",
                "type": "<V extends Collection<any>>(collection: V, properties: Partial<TypeOfCollection<V, never>>) => TypeOfCollection<V, never>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "every",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "all",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "some",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "any",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "contains",
                "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "include",
                "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "includes",
                "type": "<V extends Collection<any>>(collection: V, value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(list: Collection<any>, methodName: string, ...args: any[]) => any[]",
                "optional": false
              },
              {
                "name": "pluck",
                "type": "<V extends Collection<any>, K extends string | number>(collection: V, propertyName: K) => PropertyTypeOrAny<TypeOfCollection<V, never>, K>[]",
                "optional": false
              },
              {
                "name": "max",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | TypeOfCollection<V, never>",
                "optional": false
              },
              {
                "name": "min",
                "type": "<V extends Collection<any>>(list: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | TypeOfCollection<V, never>",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<TypeOfCollection<V, never>[]>",
                "optional": false
              },
              {
                "name": "indexBy",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<TypeOfCollection<V, never>>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "<V extends Collection<any>>(collection: V, iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<number>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "<V extends Collection<any>>(collection: V) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ <V extends Collection<any>>(collection: V, n: number): TypeOfCollection<V, never>[]; <V extends Collection<any>>(collection: V): TypeOfCollection<V, never>; }",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "<V extends Collection<any>>(collection: V) => TypeOfCollection<V, never>[]",
                "optional": false
              },
              {
                "name": "size",
                "type": "(collection: Collection<any>) => number",
                "optional": false
              },
              {
                "name": "partition",
                "type": "<V extends Collection<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => [TypeOfCollection<V, never>[], TypeOfCollection<...>[]]",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
                "optional": false
              },
              {
                "name": "initial",
                "type": "<V extends List<any>>(list: V, n?: number) => TypeOfList<V>[]",
                "optional": false
              },
              {
                "name": "last",
                "type": "{ <V extends List<any>>(list: V): TypeOfList<V>; <V extends List<any>>(list: V, n: number): TypeOfList<V>[]; }",
                "optional": false
              },
              {
                "name": "rest",
                "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
                "optional": false
              },
              {
                "name": "tail",
                "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
                "optional": false
              },
              {
                "name": "drop",
                "type": "<V extends List<any>>(list: V, index?: number) => TypeOfList<V>[]",
                "optional": false
              },
              {
                "name": "compact",
                "type": "<V extends List<any> | null | undefined>(list: V) => Exclude<TypeOfList<V>, AnyFalsy>[]",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "{ <V extends List<any>>(list: V, depth: true | 1): ListItemOrSelf<TypeOfList<V>>[]; <V extends List<any>>(list: V, depth?: number | false): DeepestListItemOrSelf<TypeOfList<V>>[]; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "<V extends List<any>>(list: V, ...values: TypeOfList<V>[]) => TypeOfList<V>[]",
                "optional": false
              },
              {
                "name": "union",
                "type": "<T>(...lists: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "<T>(...lists: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "difference",
                "type": "<T>(list: List<T>, ...others: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "{ <V extends List<any>>(list: V, isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): TypeOfList<V>[]; <V extends List<any>>(list: V, iteratee?: Iteratee<...>, context?: any): TypeOfList<...>[]; }",
                "optional": false
              },
              {
                "name": "unique",
                "type": "{ <V extends List<any>>(list: V, isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): TypeOfList<V>[]; <V extends List<any>>(list: V, iteratee?: Iteratee<...>, context?: any): TypeOfList<...>[]; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ (): []; <T, U, V>(lists_0: List<T>, lists_1: List<U>, lists_2: List<V>): [T, U, V][]; <T, U>(lists_0: List<T>, lists_1: List<U>): [T, U][]; <T>(lists_0: List<...>): [...][]; <T>(...lists: List<...>[]): T[][]; (...lists: List<...>[]): any[][]; }",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "{ <T, U, V>(lists: List<[T, U, V]>): [T[], U[], V[]]; <T, U>(lists: List<[T, U]>): [T[], U[]]; <T>(lists: List<[T]>): [T[]]; <T>(lists: List<List<T>>): T[][]; (lists: List<...>): any[][]; (): []; }",
                "optional": false
              },
              {
                "name": "transpose",
                "type": "{ <T, U, V>(lists: List<[T, U, V]>): [T[], U[], V[]]; <T, U>(lists: List<[T, U]>): [T[], U[]]; <T>(lists: List<[T]>): [T[]]; <T>(lists: List<List<T>>): T[][]; (lists: List<...>): any[][]; (): []; }",
                "optional": false
              },
              {
                "name": "object",
                "type": "{ <TList extends List<string | number>, TValue>(list: TList, values: List<TValue>): Dictionary<TValue>; <TList extends List<List<any>>>(list: TList): Dictionary<PairValue<TypeOfList<TList>>>; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, isSortedOrFromIndex?: number | boolean) => number",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "<V extends List<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "<V extends List<any>>(list: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "<V extends List<any>>(list: V, value: TypeOfList<V>, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "range",
                "type": "(startOrStop: number, stop?: number, step?: number) => number[]",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "<V extends List<any>>(list: V, length: number) => TypeOfList<V>[][]",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(func: Function, context: any, ...args: any[]) => () => any",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(object: any, ...methodNames: string[]) => any",
                "optional": false
              },
              {
                "name": "partial",
                "type": "{ <T1, T2>(fn: (p1: T1) => T2, p1: T1): () => T2; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, p1: T1): (p2: T2) => T3; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, p1: T1, p2: T2): () => T3; <T1, T2, T3>(fn: (p1: T1, p2: T2) => T3, stub1: UnderscoreStatic, p2: T2): (p1: T1) => T3; <T1, T2, T3, T4>(fn: (p1: T1, p2: T2, p3: ...",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "<T = Function>(fn: T, hashFn?: (...args: any[]) => string) => T",
                "optional": false
              },
              {
                "name": "delay",
                "type": "{ (func: Function, wait: number, ...args: any[]): any; (func: Function, ...args: any[]): any; }",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(fn: Function, ...args: any[]) => void",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "<T extends Function>(func: T, wait: number, options?: ThrottleSettings) => T & Cancelable",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "<T extends Function>(fn: T, wait: number, immediate?: boolean) => T & Cancelable",
                "optional": false
              },
              {
                "name": "once",
                "type": "<T extends Function>(fn: T) => T",
                "optional": false
              },
              {
                "name": "restArgs",
                "type": "(func: Function, starIndex?: number) => Function",
                "optional": false
              },
              {
                "name": "after",
                "type": "(count: number, fn: Function) => Function",
                "optional": false
              },
              {
                "name": "before",
                "type": "(count: number, fn: Function) => Function",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "(fn: Function, wrapper: (fn: Function, ...args: any[]) => any) => Function",
                "optional": false
              },
              {
                "name": "negate",
                "type": "(predicate: (...args: any[]) => boolean) => (...args: any[]) => boolean",
                "optional": false
              },
              {
                "name": "compose",
                "type": "(...functions: Function[]) => Function",
                "optional": false
              },
              {
                "name": "keys",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "allKeys",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "values",
                "type": "{ <T>(object: Dictionary<T>): T[]; (object: any): any[]; }",
                "optional": false
              },
              {
                "name": "mapObject",
                "type": "<V extends object, I extends Iteratee<V, any, TypeOfCollection<V, any>>>(object: V, iteratee: I, context?: any) => { [K in keyof V]: IterateeResult<I, V[K]>; }",
                "optional": false
              },
              {
                "name": "pairs",
                "type": "<V extends object>(object: V) => [Extract<keyof V, string>, TypeOfCollection<V, any>][]",
                "optional": false
              },
              {
                "name": "invert",
                "type": "(object: any) => any",
                "optional": false
              },
              {
                "name": "functions",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "methods",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "extend",
                "type": "(destination: any, ...sources: any[]) => any",
                "optional": false
              },
              {
                "name": "extendOwn",
                "type": "(destination: any, ...source: any[]) => any",
                "optional": false
              },
              {
                "name": "assign",
                "type": "(destination: any, ...source: any[]) => any",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "<V extends object>(object: V, iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => Extract<keyof V, string>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <V, K extends string>(object: V, ...keys: (K | K[])[]): _Pick<V, K>; <V>(object: V, iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<...>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <V, K extends string>(object: V, ...keys: (K | K[])[]): _Omit<V, K>; <V>(object: V, iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<...>; }",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "(object: any, ...defaults: any[]) => any",
                "optional": false
              },
              {
                "name": "create",
                "type": "(prototype: any, props?: object) => any",
                "optional": false
              },
              {
                "name": "clone",
                "type": "<T>(object: T) => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "<T>(object: T, intercepter: Function) => T",
                "optional": false
              },
              {
                "name": "has",
                "type": "(object: any, key: string) => boolean",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<T>(attrs: T) => Predicate<T>",
                "optional": false
              },
              {
                "name": "matcher",
                "type": "<T>(attrs: T) => Predicate<T>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (object: null, path: string | string[]): undefined; <U>(object: null, path: string | string[], defaultValue?: U): U; <V extends Collection<any>>(object: V, path: string): TypeOfCollection<V, never>; <V extends Collection<any>, U>(object: V, path: string, defaultValue?: U): U | TypeOfCollection<...>; <V extends Col...",
                "optional": false
              },
              {
                "name": "property",
                "type": "(key: string | number | (string | number)[]) => (object: any) => any",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "(object: object) => (key: string | number | (string | number)[]) => any",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(object: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "(collection: any) => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(object: any, properties: any) => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "(object: any) => object is Element",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "(object: any) => object is any[]",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "(object: any) => object is ArrayBuffer",
                "optional": false
              },
              {
                "name": "isDataView",
                "type": "(object: any) => object is DataView<ArrayBufferLike>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "(object: any) => object is TypedArray",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "(object: any) => object is symbol",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "(object: any) => object is Dictionary<any> & object",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "(object: any) => object is IArguments",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "(object: any) => object is Function",
                "optional": false
              },
              {
                "name": "isError",
                "type": "(object: any) => object is Error",
                "optional": false
              },
              {
                "name": "isString",
                "type": "(object: any) => object is string",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "(object: any) => object is number",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "(object: any) => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "(object: any) => object is boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "(object: any) => object is Date",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "(object: any) => object is RegExp",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "(object: any) => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "(object: any) => object is null",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "(object: any) => object is undefined",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "(object: any) => object is Set<any>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "(object: any) => object is WeakSet<any>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "(object: any) => object is Map<any, any>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "(object: any) => object is WeakMap<any, any>",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "<P>(path: P) => P extends readonly (string | number)[] ? P : P extends string | number ? [P] : never",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "identity",
                "type": "<T>(value: T) => T",
                "optional": false
              },
              {
                "name": "constant",
                "type": "<T>(value: T) => () => T",
                "optional": false
              },
              {
                "name": "noop",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "times",
                "type": "<TResult>(n: number, iterator: (n: number) => TResult, context?: any) => TResult[]",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (max: number): number; (min: number, max: number): number; }",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "(object: any) => void",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "{ (value: string): Function; (value: Function, context?: any): Function; (value: object): Function; }",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "(prefix?: string) => string",
                "optional": false
              },
              {
                "name": "escape",
                "type": "(str: string) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "(str: string) => string",
                "optional": false
              },
              {
                "name": "result",
                "type": "(object: any, property: string, defaultValue?: any) => any",
                "optional": false
              },
              {
                "name": "template",
                "type": "(templateString: string, settings?: TemplateSettings) => CompiledTemplate",
                "optional": false
              },
              {
                "name": "templateSettings",
                "type": "TemplateSettings",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "chain",
                "type": "<V>(value: V) => _Chain<TypeOfCollection<V, never>, V>",
                "optional": false
              },
              {
                "name": "VERSION",
                "type": "string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Underscore",
            "type": "Underscore<T, V>",
            "properties": [
              {
                "name": "each",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => V",
                "optional": false
              },
              {
                "name": "map",
                "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => IterateeResult<I, T>[]",
                "optional": false
              },
              {
                "name": "collect",
                "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => IterateeResult<I, T>[]",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
                "optional": false
              },
              {
                "name": "inject",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
                "optional": false
              },
              {
                "name": "foldl",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
                "optional": false
              },
              {
                "name": "foldr",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): TResult; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): TypeOfCollection<...> | TResult; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T",
                "optional": false
              },
              {
                "name": "detect",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
                "optional": false
              },
              {
                "name": "select",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
                "optional": false
              },
              {
                "name": "where",
                "type": "(properties: Partial<T>) => T[]",
                "optional": false
              },
              {
                "name": "findWhere",
                "type": "(properties: Partial<T>) => T",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => T[]",
                "optional": false
              },
              {
                "name": "every",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "all",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "some",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "any",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => boolean",
                "optional": false
              },
              {
                "name": "contains",
                "type": "(value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "include",
                "type": "(value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(value: any, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(methodName: string, ...args: any[]) => any[]",
                "optional": false
              },
              {
                "name": "pluck",
                "type": "<K extends string | number>(propertyName: K) => PropertyTypeOrAny<T, K>[]",
                "optional": false
              },
              {
                "name": "max",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | T",
                "optional": false
              },
              {
                "name": "min",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number | T",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => T[]",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<T[]>",
                "optional": false
              },
              {
                "name": "indexBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<T>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => Dictionary<number>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ (n: number): T[]; (): T; }",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => [T[], T[]]",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ (): T; (n: number): T[]; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ (): T; (n: number): T[]; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "{ (): T; (n: number): T[]; }",
                "optional": false
              },
              {
                "name": "initial",
                "type": "(n?: number) => T[]",
                "optional": false
              },
              {
                "name": "last",
                "type": "{ (): T; (n: number): T[]; }",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(n?: number) => T[]",
                "optional": false
              },
              {
                "name": "tail",
                "type": "(n?: number) => T[]",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(n?: number) => T[]",
                "optional": false
              },
              {
                "name": "compact",
                "type": "() => Exclude<T, AnyFalsy>[]",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "{ (depth: true | 1): ListItemOrSelf<T>[]; (depth?: number | false): DeepestListItemOrSelf<T>[]; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "(...values: T[]) => T[]",
                "optional": false
              },
              {
                "name": "union",
                "type": "(...lists: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "(...lists: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "difference",
                "type": "(...others: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, cotext?: any): T[]; (iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): T[]; }",
                "optional": false
              },
              {
                "name": "unique",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, cotext?: any): T[]; (iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): T[]; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ (): V extends List<infer A> ? [A][] : []; <A, B>(lists_0: List<A>, lists_1: List<B>): [T, A, B][]; <A>(list: List<A>): [T, A][]; (...lists: List<...>[]): T[][]; (...lists: List<...>[]): any[][]; }",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "() => T extends [infer A, infer B, infer C] ? [A[], B[], C[]] : T extends [infer A, infer B] ? [A[], B[]] : T extends [infer A] ? [A[]] : T extends List<...> ? A[][] : []",
                "optional": false
              },
              {
                "name": "transpose",
                "type": "() => T extends [infer A, infer B, infer C] ? [A[], B[], C[]] : T extends [infer A, infer B] ? [A[], B[]] : T extends [infer A] ? [A[]] : T extends List<...> ? A[][] : []",
                "optional": false
              },
              {
                "name": "object",
                "type": "{ <TValue>(values: List<TValue>): Dictionary<TValue>; (): Dictionary<PairValue<T>>; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(value: T, isSortedOrFromIndex?: number | boolean) => number",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(value: T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "(value: T, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => number",
                "optional": false
              },
              {
                "name": "range",
                "type": "(stop?: number, step?: number) => number[]",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "(length: number) => T[][]",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(object: any, ...args: any[]) => Function",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: string[]) => any",
                "optional": false
              },
              {
                "name": "partial",
                "type": "(...args: any[]) => Function",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "(hashFn?: (n: any) => string) => Function",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "delay",
                "type": "{ (wait: number, ...args: any[]): any; (...args: any[]): any; }",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "(wait: number, options?: ThrottleSettings) => Function & Cancelable",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "(wait: number, immediate?: boolean) => Function & Cancelable",
                "optional": false
              },
              {
                "name": "once",
                "type": "() => Function",
                "optional": false
              },
              {
                "name": "restArgs",
                "type": "(starIndex?: number) => Function",
                "optional": false
              },
              {
                "name": "after",
                "type": "(fn: Function) => Function",
                "optional": false
              },
              {
                "name": "before",
                "type": "(fn: Function) => Function",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "(wrapper: Function) => () => Function",
                "optional": false
              },
              {
                "name": "negate",
                "type": "() => (...args: any[]) => boolean",
                "optional": false
              },
              {
                "name": "compose",
                "type": "(...functions: Function[]) => Function",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "allKeys",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "mapObject",
                "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => { [K in keyof V]: IterateeResult<I, V[K]>; }",
                "optional": false
              },
              {
                "name": "pairs",
                "type": "() => [Extract<keyof V, string>, TypeOfCollection<V, any>][]",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "methods",
                "type": "() => string[]",
                "optional": false
              },
              {
                "name": "extend",
                "type": "(...sources: any[]) => any",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => Extract<keyof V, string>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _Pick<V, K>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<V>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _Omit<V, K>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): Partial<V>; }",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "(...defaults: any[]) => any",
                "optional": false
              },
              {
                "name": "create",
                "type": "(props?: object) => any",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (...as: any[]) => any) => any",
                "optional": false
              },
              {
                "name": "has",
                "type": "(key: string) => boolean",
                "optional": false
              },
              {
                "name": "matches",
                "type": "() => ListIterator<T, boolean, List<T>>",
                "optional": false
              },
              {
                "name": "matcher",
                "type": "() => ListIterator<T, boolean, List<T>>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: string): TypeOfCollection<V, never>; <U>(path: string, defaultValue?: U): TypeOfCollection<V, never> | U; <P extends Array<string | number>, U = undefined>(path: [......], defaultValue?: U): U | DeepTypeOfCollection<...>; }",
                "optional": false
              },
              {
                "name": "property",
                "type": "() => (object: any) => any",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => (key: string) => any",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(properties: any) => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDataView",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => () => T",
                "optional": false
              },
              {
                "name": "noop",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "times",
                "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => TResult[]",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (): number; (max: number): number; }",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "(context?: any) => Function",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "result",
                "type": "(property: string, defaultValue?: any) => any",
                "optional": false
              },
              {
                "name": "template",
                "type": "(settings?: TemplateSettings) => CompiledTemplate",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => _Chain<T, V>",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => V",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "_Chain",
            "type": "_Chain<T, V>",
            "properties": [
              {
                "name": "each",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<T, V>",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee: CollectionIterator<TypeOfCollection<V, never>, void, V>, context?: any) => _Chain<T, V>",
                "optional": false
              },
              {
                "name": "map",
                "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, T>, IterateeResult<I, T>[]>",
                "optional": false
              },
              {
                "name": "collect",
                "type": "<I extends Iteratee<V, any>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, T>, IterateeResult<I, T>[]>",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "inject",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "foldl",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "foldr",
                "type": "{ <TResult>(iteratee: MemoCollectionIterator<TypeOfCollection<V, never>, TResult, V>, memo: TResult, context?: any): _ChainSingle<...>; <TResult = TypeOfCollection<...>>(iteratee: MemoCollectionIterator<...>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "detect",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "select",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "where",
                "type": "(properties: Partial<T>) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "findWhere",
                "type": "(properties: Partial<T>) => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "all",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "any",
                "type": "(iterator?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "contains",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "include",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(value: any, fromIndex?: number) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(methodName: string, ...args: any[]) => _Chain<any, any[]>",
                "optional": false
              },
              {
                "name": "pluck",
                "type": "<K extends string | number>(propertyName: K) => _Chain<PropertyTypeOrAny<T, K>, PropertyTypeOrAny<T, K>[]>",
                "optional": false
              },
              {
                "name": "max",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | T>",
                "optional": false
              },
              {
                "name": "min",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number | T>",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<T[], Dictionary<T[]>>",
                "optional": false
              },
              {
                "name": "indexBy",
                "type": "(iteratee?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<T, Dictionary<T>>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iterator?: Iteratee<V, string | number, TypeOfCollection<V, never>>, context?: any) => _Chain<number, Dictionary<number>>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ (n: number): _Chain<T, T[]>; (): _ChainSingle<T>; }",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _Chain<T[], [T[], T[]]>",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "initial",
                "type": "(n?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "last",
                "type": "{ (): _ChainSingle<T>; (n: number): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(n?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "tail",
                "type": "(n?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(n?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "compact",
                "type": "() => _Chain<Exclude<T, AnyFalsy>, Exclude<T, AnyFalsy>[]>",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "{ (depth: true | 1): _Chain<ListItemOrSelf<T>, ListItemOrSelf<T>[]>; (depth?: number | false): _Chain<DeepestListItemOrSelf<T>, DeepestListItemOrSelf<...>[]>; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "(...values: T[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "union",
                "type": "(...lists: List<T>[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "(...lists: List<T>[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "difference",
                "type": "(...others: List<T>[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<T, T[]>; (iteratee?: Iteratee<V, any, TypeOfCollection<...>>, context?: any): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "unique",
                "type": "{ (isSorted?: boolean, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any): _Chain<T, T[]>; (iteratee?: Iteratee<V, any, TypeOfCollection<...>>, context?: any): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ (): V extends List<infer A> ? _Chain<[A], [A][]> : _Chain<never, []>; <A, B>(arrays_0: List<A>, arrays_1: List<B>): _Chain<[T, A, B], [...][]>; <A>(array: List<...>): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; (...arrays: List<...>[]): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "() => T extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : T extends [infer A, infer B] ? _Chain<A[] | B[], [A[], B[]]> : T extends [...] ? _Chain<...> : T extends List<...> ? _Chain<...> : _Chain<...>",
                "optional": false
              },
              {
                "name": "transpose",
                "type": "() => T extends [infer A, infer B, infer C] ? _Chain<A[] | B[] | C[], [A[], B[], C[]]> : T extends [infer A, infer B] ? _Chain<A[] | B[], [A[], B[]]> : T extends [...] ? _Chain<...> : T extends List<...> ? _Chain<...> : _Chain<...>",
                "optional": false
              },
              {
                "name": "object",
                "type": "{ <TValue>(values: List<TValue>): _Chain<TValue, Dictionary<TValue>>; (): _Chain<PairValue<T>, Dictionary<PairValue<T>>>; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(value: T, isSortedOrFromIndex?: number | boolean) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(value: T, fromIndex?: number) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "(value: T, iteratee?: Iteratee<V, any, TypeOfCollection<V, never>>, context?: any) => _ChainSingle<number>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(stop?: number, step?: number) => _Chain<number, number[]>",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "(length: number) => _Chain<T[], T[][]>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(object: any, ...args: any[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: string[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "partial",
                "type": "(...args: any[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "(hashFn?: (n: any) => string) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "{ (wait: number, ...args: any[]): _Chain<T, T[]>; (...args: any[]): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "(wait: number, options?: ThrottleSettings) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "(wait: number, immediate?: boolean) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "once",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "restArgs",
                "type": "(startIndex?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "after",
                "type": "(func: Function) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "before",
                "type": "(fn: Function) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "(wrapper: Function) => () => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "negate",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "compose",
                "type": "(...functions: Function[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => _Chain<string, string[]>",
                "optional": false
              },
              {
                "name": "allKeys",
                "type": "() => _Chain<string, string[]>",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => _Chain<any, any[]>",
                "optional": false
              },
              {
                "name": "mapObject",
                "type": "<I extends Iteratee<V, any, TypeOfCollection<V, any>>>(iteratee: I, context?: any) => _Chain<IterateeResult<I, TypeOfCollection<V, any>>, { [K in keyof V]: IterateeResult<...>; }>",
                "optional": false
              },
              {
                "name": "pairs",
                "type": "() => _Chain<[Extract<keyof V, string>, TypeOfCollection<V, any>], [Extract<keyof V, string>, TypeOfCollection<V, any>][]>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "methods",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "extend",
                "type": "(...sources: any[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(iteratee?: Iteratee<V, boolean, TypeOfCollection<V, any>>, context?: any) => _ChainSingle<Extract<keyof V, string>>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Pick<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <K extends string>(...keys: (K | K[])[]): _ChainSingle<_Omit<V, K>>; (iterator: ObjectIterator<TypeOfDictionary<V, any>, boolean, V>): _ChainSingle<...>; }",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "(...defaults: any[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "create",
                "type": "(props?: object) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (...as: any[]) => any) => _Chain<T, V>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(key: string) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "matcher",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: string): _Chain<TypeOfCollection<V, never>, T>; <U>(path: string, defaultValue?: U): _Chain<TypeOfCollection<V, never> | U, T | U>; <P extends Array<string | number>, W = DeepTypeOfCollection<...>, U = undefined>(path: [......], defaultValue?: U): _Chain<...>; }",
                "optional": false
              },
              {
                "name": "property",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(properties: any) => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isDataView",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => _ChainSingle<boolean>",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => _ChainSingle<V extends readonly (string | number)[] ? V : V extends string | number ? [V] : never>",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "times",
                "type": "<TResult>(iterator: (n: number) => TResult, context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (): _Chain<T, T[]>; (max: number): _Chain<T, T[]>; }",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "(context?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "result",
                "type": "(property: string, defaultValue?: any) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(settings?: TemplateSettings) => _Chain<CompiledTemplate, CompiledTemplate[]>",
                "optional": false
              },
              {
                "name": "concat",
                "type": "(...arr: T[][]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: any) => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "pop",
                "type": "() => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...item: T[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start: number, end?: number) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: T, b: T) => boolean) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "(index: number, quantity: number, ...items: T[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => _ChainSingle<T>",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: T[]) => _Chain<T, T[]>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => _Chain<T, V>",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => V",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          }
        ],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": false
    }
  ],
  "version": "1.13.6"
}