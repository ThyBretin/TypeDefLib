{
  "functions": [
    {
      "name": "_",
      "parameters": [
        {
          "name": "value",
          "type": "TrapAny",
          "optional": false
        }
      ],
      "returnType": "Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>",
      "jsdoc": null
    },
    {
      "name": "chunk",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[][]",
      "jsdoc": {
        "description": "Creates an array of elements split into groups the length of size. If collection canâ€™t be split evenly, the\nfinal chunk will be the remaining elements.",
        "params": [
          {
            "name": "array",
            "description": "The array to process."
          },
          {
            "name": "size",
            "description": "The length of each chunk."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "compact",
      "parameters": [
        {
          "name": "array",
          "type": "List<T | Falsey>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array with all falsey values removed. The values false, null, 0, 0n, \"\", undefined, and NaN are\nfalsey.",
        "params": [
          {
            "name": "array",
            "description": "The array to compact."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "concat",
      "parameters": [
        {
          "name": "values",
          "type": "Many<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a new array concatenating `array` with any additional arrays\nand/or values.",
        "params": [
          {
            "name": "values",
            "description": "The array values to concatenate."
          }
        ],
        "returns": "Returns the new concatenated array.",
        "deprecated": false
      }
    },
    {
      "name": "difference",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of `array` values not included in the other provided arrays using SameValueZero for\nequality comparisons. The order and references of result values are determined by the first array.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "values",
            "description": "The arrays of values to exclude."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "differenceBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T1 | T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like _.difference except that it accepts iteratee which is invoked for each element\nof array and values to generate the criterion by which they're compared. The order and references\nof result values are determined by the first array. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "values",
            "description": "The values to exclude."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "differenceWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator2<T1, T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like _.difference except that it accepts comparator which is invoked to compare elements\nof array to values. The order and references of result values are determined by the first array. The\ncomparator is invoked with two arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "values",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "drop",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements dropped from the beginning.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to drop."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "dropRight",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements dropped from the end.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to drop."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "dropRightWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "dropWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "fill",
      "parameters": [
        {
          "name": "array",
          "type": "any[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Fills elements of array with value from start up to, but not including, end.\n\nNote: This method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to fill."
          },
          {
            "name": "value",
            "description": "The value to fill array with."
          },
          {
            "name": "start",
            "description": "The start position."
          },
          {
            "name": "end",
            "description": "The end position."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "findIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like _.find except that it returns the index of the first element predicate returns truthy\nfor instead of the element itself.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "findLastIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like _.findIndex except that it iterates over elements of collection from right to left.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "first",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [T, ...unknown[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "flatten",
      "parameters": [
        {
          "name": "array",
          "type": "List<Many<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Flattens `array` a single level deep.",
        "params": [
          {
            "name": "array",
            "description": "The array to flatten."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flattenDeep",
      "parameters": [
        {
          "name": "array",
          "type": "ListOfRecursiveArraysOrValues<T>",
          "optional": false
        }
      ],
      "returnType": "Flat<T>[]",
      "jsdoc": {
        "description": "Recursively flattens a nested array.",
        "params": [
          {
            "name": "array",
            "description": "The array to recursively flatten."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flattenDepth",
      "parameters": [
        {
          "name": "array",
          "type": "ListOfRecursiveArraysOrValues<T>",
          "optional": false
        },
        {
          "name": "depth",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Recursively flatten array up to depth times.",
        "params": [
          {
            "name": "array",
            "description": "The array to recursively flatten."
          },
          {
            "name": "number",
            "description": "The maximum recursion depth."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "fromPairs",
      "parameters": [
        {
          "name": "pairs",
          "type": "List<[PropertyName, T]>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The inverse of `_.toPairs`; this method returns an object composed\nfrom key-value `pairs`.",
        "params": [
          {
            "name": "pairs",
            "description": "The key-value pairs."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "head",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [T, ...unknown[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the first element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "indexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Gets the index at which the first occurrence of `value` is found in `array`\nusing [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\nfor equality comparisons. If `fromIndex` is negative, it's used as the offset\nfrom the end of `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "returns": "Returns the index of the matched value, else `-1`.",
        "deprecated": false
      }
    },
    {
      "name": "initial",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Gets all but the last element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "intersection",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values that are included in all of the provided arrays using SameValueZero for\nequality comparisons.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "intersectionBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T1 | T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like `_.intersection` except that it accepts `iteratee`\nwhich is invoked for each element of each `arrays` to generate the criterion\nby which uniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of shared values.",
        "deprecated": false
      }
    },
    {
      "name": "intersectionWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator2<T1, T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "Creates an array of unique `array` values not included in the other\nprovided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\nfor equality comparisons.",
        "params": [
          {
            "name": "values",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "join",
      "parameters": [
        {
          "name": "array",
          "type": "List<any>",
          "optional": false
        },
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all elements in `array` into a string separated by `separator`.",
        "params": [
          {
            "name": "array",
            "description": "The array to convert."
          },
          {
            "name": "separator",
            "description": "The element separator."
          }
        ],
        "returns": "Returns the joined string.",
        "deprecated": false
      }
    },
    {
      "name": "last",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the last element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "lastIndexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number | true",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like _.indexOf except that it iterates over elements of array from right to left.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from or true to perform a binary search on a sorted array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "nth",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.",
        "params": [
          {
            "name": "array",
            "description": "array The array to query."
          },
          {
            "name": "value",
            "description": "The index of the element to return."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "pull",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "T[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes all provided values from array using SameValueZero for equality comparisons.\n\nNote: Unlike _.without, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "pullAll",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pull` except that it accepts an array of values to remove.\n\n**Note:** Unlike `_.difference`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "pullAllBy",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pullAll` except that it accepts `iteratee` which is\ninvoked for each element of `array` and `values` to to generate the criterion\nby which uniqueness is computed. The iteratee is invoked with one argument: (value).\n\n**Note:** Unlike `_.differenceBy`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "pullAllWith",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pullAll` except that it accepts `comparator` which is\ninvoked to compare elements of array to values. The comparator is invoked with\ntwo arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.differenceWith`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "pullAt",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "indexes",
          "type": "Many<number>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\nIndexes may be specified as an array of indexes or as individual arguments.\n\nNote: Unlike _.at, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "indexes",
            "description": "The indexes of elements to remove, specified as individual indexes or arrays of indexes."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "remove",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes all elements from array that predicate returns truthy for and returns an array of the removed\nelements. The predicate is invoked with three arguments: (value, index, array).\n\nNote: Unlike _.filter, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "reverse",
      "parameters": [
        {
          "name": "array",
          "type": "TList",
          "optional": false
        }
      ],
      "returnType": "TList",
      "jsdoc": {
        "description": "Reverses `array` so that the first element becomes the last, the second\nelement becomes the second to last, and so on.\n\n**Note:** This method mutates `array` and is based on\n[`Array#reverse`](https://mdn.io/Array/reverse).",
        "params": [],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "slice",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array from start up to, but not including, end.",
        "params": [
          {
            "name": "array",
            "description": "The array to slice."
          },
          {
            "name": "start",
            "description": "The start position."
          },
          {
            "name": "end",
            "description": "The end position."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "sortedIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Uses a binary search to determine the lowest index at which `value` should\nbe inserted into `array` in order to maintain its sort order.",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedIndexBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedIndexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.indexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          }
        ],
        "returns": "Returns the index of the matched value, else `-1`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedLastIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedIndex` except that it returns the highest\nindex at which `value` should be inserted into `array` in order to\nmaintain its sort order.",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedLastIndexBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedLastIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedLastIndexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.lastIndexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          }
        ],
        "returns": "Returns the index of the matched value, else `-1`.",
        "deprecated": false
      }
    },
    {
      "name": "sortedUniq",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it's designed and optimized\nfor sorted arrays.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "sortedUniqBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniqBy` except that it's designed and optimized\nfor sorted arrays.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "tail",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [unknown, ...T]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets all but the first element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "take",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements taken from the beginning.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to take."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "takeRight",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements taken from the end.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to take."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "takeRightWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with elements taken from the end. Elements are taken until predicate returns\nfalsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "takeWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns\nfalsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "union",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for\nequality comparisons.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unionBy",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.union` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unionWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.union` except that it accepts `comparator` which\nis invoked to compare elements of `arrays`. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of combined values.",
        "deprecated": false
      }
    },
    {
      "name": "uniq",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a duplicate-free version of an array, using\n[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\nfor equality comparisons, in which only the first occurrence of each element\nis kept.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "uniqBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "uniqWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it accepts `comparator` which\nis invoked to compare elements of `array`. The comparator is invoked with\ntwo arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "unzip",
      "parameters": [
        {
          "name": "array",
          "type": "T[][] | List<List<T>>",
          "optional": false
        }
      ],
      "returnType": "T[][]",
      "jsdoc": {
        "description": "This method is like _.zip except that it accepts an array of grouped elements and creates an array\nregrouping the elements to their pre-zip configuration.",
        "params": [
          {
            "name": "array",
            "description": "The array of grouped elements to process."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unzipWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<List<T>>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(...values: T[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be\ncombined. The iteratee is invoked with four arguments: (accumulator, value, index, group).",
        "params": [
          {
            "name": "array",
            "description": "The array of grouped elements to process."
          },
          {
            "name": "iteratee",
            "description": "The function to combine regrouped values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "without",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "values",
          "type": "T[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array excluding all provided values using SameValueZero for equality comparisons.",
        "params": [
          {
            "name": "array",
            "description": "The array to filter."
          },
          {
            "name": "values",
            "description": "The values to exclude."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "xor",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values that is the symmetric difference of the provided arrays.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "xorBy",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.xor` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of values.",
        "deprecated": false
      }
    },
    {
      "name": "xorWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.xor` except that it accepts `comparator` which is\ninvoked to compare elements of `arrays`. The comparator is invoked with\ntwo arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of values.",
        "deprecated": false
      }
    },
    {
      "name": "zip",
      "parameters": [
        {
          "name": "arrays1",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "arrays2",
          "type": "List<T2>",
          "optional": false
        }
      ],
      "returnType": "[T1, T2][]",
      "jsdoc": {
        "description": "Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\nthe second of which contains the second elements of the given arrays, and so on.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to process."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "zipObject",
      "parameters": [
        {
          "name": "props",
          "type": "List<PropertyName>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "This method is like _.fromPairs except that it accepts two arrays, one of property\nidentifiers and one of corresponding values.",
        "params": [
          {
            "name": "props",
            "description": "The property names."
          },
          {
            "name": "values",
            "description": "The property values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "zipObjectDeep",
      "parameters": [
        {
          "name": "paths",
          "type": "List<PropertyPath>",
          "optional": true
        },
        {
          "name": "values",
          "type": "List<any>",
          "optional": true
        }
      ],
      "returnType": "object",
      "jsdoc": {
        "description": "This method is like _.zipObject except that it supports property paths.",
        "params": [
          {
            "name": "paths",
            "description": "The property names."
          },
          {
            "name": "values",
            "description": "The property values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "zipWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(value1: T) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "This method is like _.zip except that it accepts an iteratee to specify how grouped values should be\ncombined. The iteratee is invoked with four arguments: (accumulator, value, index,\ngroup).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to process."
          },
          {
            "name": "iteratee",
            "description": "The function to combine grouped values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "countBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<number>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The\niteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "each",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "eachRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "every",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "filter",
      "parameters": [
        {
          "name": "collection",
          "type": "string",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "StringIterator<boolean>",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The\npredicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "find",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratorTypeGuard<T, S>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Iterates over elements of collection, returning the first element predicate returns truthy for.\nThe predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "findLast",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratorTypeGuard<T, S>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "This method is like _.find except that it iterates over elements of a collection from\nright to left.",
        "params": [
          {
            "name": "collection",
            "description": "Searches for a value in this list."
          },
          {
            "name": "predicate",
            "description": "The function called per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flatMap",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<Many<T>> | NumericDictionary<Many<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of flattened values by running each element in collection through iteratee\nand concating its result to the other mapped values. The iteratee is invoked with three arguments:\n(value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flatMapDeep",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.flatMap` except that it recursively flattens the\nmapped results.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "returns": "Returns the new flattened array.",
        "deprecated": false
      }
    },
    {
      "name": "flatMapDepth",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.flatMap` except that it recursively flattens the\nmapped results up to `depth` times.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          },
          {
            "name": "depth",
            "description": "The maximum recursion depth."
          }
        ],
        "returns": "Returns the new flattened array.",
        "deprecated": false
      }
    },
    {
      "name": "forEach",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Iterates over elements of collection invoking iteratee for each element. The iteratee is invoked with three arguments:\n(value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.\n\nNote: As with other \"Collections\" methods, objects with a \"length\" property are iterated like arrays. To\navoid this behavior _.forIn or _.forOwn may be used for object iteration.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "forEachRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like _.forEach except that it iterates over elements of collection from right to left.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function called per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "groupBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T[]>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is an array of the elements responsible for generating the\nkey. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "includes",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "target",
          "type": "T",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if target is in collection using SameValueZero for equality comparisons. If fromIndex is negative,\nitâ€™s used as the offset from the end of collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to search."
          },
          {
            "name": "target",
            "description": "The value to search for."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "invokeMap",
      "parameters": [
        {
          "name": "collection",
          "type": "object",
          "optional": false
        },
        {
          "name": "methodName",
          "type": "string",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any[]",
      "jsdoc": {
        "description": "Invokes the method named by methodName on each element in the collection returning\nan array of the results of each invoked method. Additional arguments will be provided\nto each invoked method. If methodName is a function it will be invoked for, and this\nbound to, each element in the collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "methodName",
            "description": "The name of the method to invoke."
          },
          {
            "name": "args",
            "description": "Arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "keyBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIterateeCustom<T, PropertyName>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is the last element responsible for generating the key. The\niteratee function is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "map",
      "parameters": [
        {
          "name": "collection",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "TupleIterator<T, TResult>",
          "optional": false
        }
      ],
      "returnType": "{ [K in keyof T]: TResult; }",
      "jsdoc": {
        "description": "Creates an array of values by running each element in collection through iteratee. The iteratee is\ninvoked with three arguments: (value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,\n_.reject, and _.some.\n\nThe guarded methods are:\nary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,\nmin, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,\nsample, some, sum, uniq, and words",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "orderBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratees",
          "type": "Many<ListIterator<T, unknown>>",
          "optional": true
        },
        {
          "name": "orders",
          "type": "Many<boolean | \"asc\" | \"desc\">",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.sortBy` except that it allows specifying the sort\norders of the iteratees to sort by. If `orders` is unspecified, all values\nare sorted in ascending order. Otherwise, specify an order of \"desc\" for\ndescending or \"asc\" for ascending sort order of corresponding values.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratees",
            "description": "The iteratees to sort by."
          },
          {
            "name": "orders",
            "description": "The sort orders of `iteratees`."
          },
          {
            "name": "guard",
            "description": "Enables use as an iteratee for functions like `_.reduce`."
          }
        ],
        "returns": "Returns the new sorted array.",
        "deprecated": false
      }
    },
    {
      "name": "partition",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "ValueIteratorTypeGuard<T, U>",
          "optional": false
        }
      ],
      "returnType": "[U[], Exclude<T, U>[]]",
      "jsdoc": {
        "description": "Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,\nwhile the second of which contains elements predicate returns falsey for.\nThe predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "reduce",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "MemoListIterator<T, TResult, T[]>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "Reduces a collection to a value which is the accumulated result of running each\nelement in the collection through the callback, where each successive callback execution\nconsumes the return value of the previous execution. If accumulator is not provided the\nfirst element of the collection will be used as the initial accumulator value. The callback\nis invoked with four arguments: (accumulator, value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          },
          {
            "name": "accumulator",
            "description": "Initial value of the accumulator."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "reduceRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "MemoListIterator<T, TResult, T[]>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.reduce except that it iterates over elements of a collection from\nright to left.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          },
          {
            "name": "accumulator",
            "description": "Initial value of the accumulator."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "reject",
      "parameters": [
        {
          "name": "collection",
          "type": "string",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "StringIterator<boolean>",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "The opposite of _.filter; this method returns the elements of collection that predicate does not return\ntruthy for.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "sample",
      "parameters": [
        {
          "name": "collection",
          "type": "readonly [T, ...T[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets a random element from collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "sampleSize",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Gets n random elements at unique keys from collection up to the size of collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          },
          {
            "name": "n",
            "description": "The number of elements to sample."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "shuffle",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to shuffle."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "size",
      "parameters": [
        {
          "name": "collection",
          "type": "string | object",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Gets the size of collection by returning its length for array-like values or the number of own enumerable\nproperties for objects.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "some",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate\nreturns truthy. The predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "sortBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratees",
          "type": "Many<ListIteratee<T>>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of elements, sorted in ascending order by the results of\nrunning each element in a collection through each iteratee. This method\nperforms a stable sort, that is, it preserves the original sort order of\nequal elements. The iteratees are invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratees",
            "description": "The iteratees to sort by, specified individually or in arrays."
          }
        ],
        "returns": "Returns the new sorted array.",
        "deprecated": false
      }
    },
    {
      "name": "now",
      "parameters": [],
      "returnType": "number",
      "jsdoc": null
    },
    {
      "name": "after",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "func",
          "type": "TFunc",
          "optional": false
        }
      ],
      "returnType": "TFunc",
      "jsdoc": {
        "description": "The opposite of _.before; this method creates a function that invokes func once itâ€™s called n or more times.",
        "params": [
          {
            "name": "n",
            "description": "The number of calls before func is invoked."
          },
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "ary",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that accepts up to n arguments ignoring any additional arguments.",
        "params": [
          {
            "name": "func",
            "description": "The function to cap arguments for."
          },
          {
            "name": "n",
            "description": "The arity cap."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "before",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "func",
          "type": "TFunc",
          "optional": false
        }
      ],
      "returnType": "TFunc",
      "jsdoc": {
        "description": "Creates a function that invokes func, with the this binding and arguments of the created function, while\nitâ€™s called less than n times. Subsequent calls to the created function return the result of the last func\ninvocation.",
        "params": [
          {
            "name": "n",
            "description": "The number of calls at which func is no longer invoked."
          },
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "bind",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": false
        },
        {
          "name": "partials",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind\narguments to those provided to the bound function.\n\nThe _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for\npartially applied arguments.\n\nNote: Unlike native Function#bind this method does not set the \"length\" property of bound functions.",
        "params": [
          {
            "name": "func",
            "description": "The function to bind."
          },
          {
            "name": "thisArg",
            "description": "The this binding of func."
          },
          {
            "name": "partials",
            "description": "The arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "bindKey",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "key",
          "type": "string",
          "optional": false
        },
        {
          "name": "partials",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments\nto those provided to the bound function.\n\nThis method differs from _.bind by allowing bound functions to reference methods that may be redefined\nor donâ€™t yet exist. See Peter Michauxâ€™s article for more details.\n\nThe _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder\nfor partially applied arguments.",
        "params": [
          {
            "name": "object",
            "description": "The object the method belongs to."
          },
          {
            "name": "key",
            "description": "The key of the method."
          },
          {
            "name": "partials",
            "description": "The arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "curry",
      "parameters": [
        {
          "name": "func",
          "type": "(t1: T1) => R",
          "optional": false
        },
        {
          "name": "arity",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "CurriedFunction1<T1, R>",
      "jsdoc": null
    },
    {
      "name": "curryRight",
      "parameters": [
        {
          "name": "func",
          "type": "(t1: T1) => R",
          "optional": false
        },
        {
          "name": "arity",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "RightCurriedFunction1<T1, R>",
      "jsdoc": null
    },
    {
      "name": "debounce",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "DebounceSettingsLeading",
          "optional": false
        }
      ],
      "returnType": "DebouncedFuncLeading<T>",
      "jsdoc": {
        "description": "Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\nthe last time the debounced function was invoked. The debounced function comes with a cancel method to\ncancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\nindicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\ncalls to the debounced function return the result of the last func invocation.\n\nNote: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\nif the the debounced function is invoked more than once during the wait timeout.\n\nSee David Corbachoâ€™s article for details over the differences between _.debounce and _.throttle.",
        "params": [
          {
            "name": "func",
            "description": "The function to debounce."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to delay."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify invoking on the leading edge of the timeout."
          },
          {
            "description": "The maximum time func is allowed to be delayed before itâ€™s invoked."
          },
          {
            "description": "Specify invoking on the trailing edge of the timeout."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "defer",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to\nfunc when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to defer."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the function with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "delay",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Invokes func after wait milliseconds. Any additional arguments are provided to func when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to delay."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to delay invocation."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the function with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flip",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a function that invokes `func` with arguments reversed.",
        "params": [
          {
            "name": "func",
            "description": "The function to flip arguments for."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "memoize",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "resolver",
          "type": "(...args: Parameters<T>) => any",
          "optional": true
        }
      ],
      "returnType": "T & MemoizedFunction",
      "jsdoc": {
        "description": "Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\nstoring the result based on the arguments provided to the memoized function. By default, the first argument\nprovided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\nthe this binding of the memoized function.",
        "params": [
          {
            "name": "func",
            "description": "The function to have its output memoized."
          },
          {
            "name": "resolver",
            "description": "The function to resolve the cache key."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "negate",
      "parameters": [
        {
          "name": "predicate",
          "type": "(...args: T) => boolean",
          "optional": false
        }
      ],
      "returnType": "(...args: T) => boolean",
      "jsdoc": {
        "description": "Creates a function that negates the result of the predicate func. The func predicate is invoked with\nthe this binding and arguments of the created function.",
        "params": [
          {
            "name": "predicate",
            "description": "The predicate to negate."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "once",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a function that is restricted to invoking func once. Repeat calls to the function return the value\nof the first call. The func is invoked with the this binding and arguments of the created function.",
        "params": [
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "overArgs",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "transforms",
          "type": "Many<(...args: any[]) => any>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that runs each argument through a corresponding transform function.",
        "params": [
          {
            "name": "func",
            "description": "The function to wrap."
          },
          {
            "name": "transforms",
            "description": "The functions to transform arguments, specified as individual functions or arrays\nof functions."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "partial",
      "parameters": [
        {
          "name": "func",
          "type": "Function2<T1, T2, R>",
          "optional": false
        },
        {
          "name": "plc1",
          "type": "LoDashStatic",
          "optional": false
        },
        {
          "name": "arg2",
          "type": "T2",
          "optional": false
        }
      ],
      "returnType": "Function1<T1, R>",
      "jsdoc": {
        "description": "Creates a function that, when called, invokes func with any additional partial arguments\nprepended to those provided to the new function. This method is similar to _.bind except\nit does not alter the this binding.",
        "params": [
          {
            "name": "func",
            "description": "The function to partially apply arguments to."
          },
          {
            "name": "args",
            "description": "Arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "partialRight",
      "parameters": [
        {
          "name": "func",
          "type": "Function0<R>",
          "optional": false
        }
      ],
      "returnType": "Function0<R>",
      "jsdoc": {
        "description": "This method is like _.partial except that partial arguments are appended to those provided\nto the new function.",
        "params": [
          {
            "name": "func",
            "description": "The function to partially apply arguments to."
          },
          {
            "name": "args",
            "description": "Arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "rearg",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "indexes",
          "type": "Many<number>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with arguments arranged according to the specified indexes where the\nargument value at the first index is provided as the first argument, the argument value at the second index\nis provided as the second argument, and so on.",
        "params": [
          {
            "name": "func",
            "description": "The function to rearrange arguments for."
          },
          {
            "name": "indexes",
            "description": "The arranged argument indexes, specified as individual indexes or arrays of indexes."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "rest",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of the created function and arguments from start\nand beyond provided as an array.\n\nNote: This method is based on the rest parameter.",
        "params": [
          {
            "name": "func",
            "description": "The function to apply a rest parameter to."
          },
          {
            "name": "start",
            "description": "The start position of the rest parameter."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "spread",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => TResult",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of the created function and an array of arguments\nmuch like Function#apply.\n\nNote: This method is based on the spread operator.",
        "params": [
          {
            "name": "func",
            "description": "The function to spread arguments over."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "throttle",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": true
        },
        {
          "name": "options",
          "type": "ThrottleSettingsLeading",
          "optional": true
        }
      ],
      "returnType": "DebouncedFuncLeading<T>",
      "jsdoc": {
        "description": "Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled\nfunction comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke\nthem. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge\nof the wait timeout. Subsequent calls to the throttled function return the result of the last func call.\n\nNote: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if\nthe the throttled function is invoked more than once during the wait timeout.",
        "params": [
          {
            "name": "func",
            "description": "The function to throttle."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to throttle invocations to."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify invoking on the leading edge of the timeout."
          },
          {
            "description": "Specify invoking on the trailing edge of the timeout."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unary",
      "parameters": [
        {
          "name": "func",
          "type": "(arg1: T, ...args: any[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "(arg1: T) => TResult",
      "jsdoc": {
        "description": "Creates a function that accepts up to one argument, ignoring any\nadditional arguments.",
        "params": [
          {
            "name": "func",
            "description": "The function to cap arguments for."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "wrap",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "wrapper",
          "type": "(value: T, ...args: TArgs[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "(...args: TArgs[]) => TResult",
      "jsdoc": {
        "description": "Creates a function that provides value to the wrapper function as its first argument. Any additional\narguments provided to the function are appended to those provided to the wrapper function. The wrapper is\ninvoked with the this binding of the created function.",
        "params": [
          {
            "name": "value",
            "description": "The value to wrap."
          },
          {
            "name": "wrapper",
            "description": "The wrapper function."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "castArray",
      "parameters": [
        {
          "name": "value",
          "type": "Many<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Casts value as an array if itâ€™s not one.",
        "params": [
          {
            "name": "value",
            "description": "The value to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "clone",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a shallow clone of value.\n\nNote: This method is loosely based on the structured clone algorithm and supports cloning arrays,\narray buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\nand typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\nobject is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.",
        "params": [
          {
            "name": "value",
            "description": "The value to clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cloneDeep",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.clone except that it recursively clones value.",
        "params": [
          {
            "name": "value",
            "description": "The value to recursively clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cloneDeepWith",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "CloneDeepWithCustomizer<T>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.cloneWith except that it recursively clones value.",
        "params": [
          {
            "name": "value",
            "description": "The value to recursively clone."
          },
          {
            "name": "customizer",
            "description": "The function to customize cloning."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cloneWith",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "CloneWithCustomizer<T, TResult>",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.\nIf customizer returns undefined cloning is handled by the method instead.",
        "params": [
          {
            "name": "value",
            "description": "The value to clone."
          },
          {
            "name": "customizer",
            "description": "The function to customize cloning."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "conformsTo",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "source",
          "type": "ConformsPredicateObject<T>",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if object conforms to source by invoking the predicate properties of source with the\ncorresponding property values of object.\n\nNote: This method is equivalent to _.conforms when source is partially applied.",
        "deprecated": false
      }
    },
    {
      "name": "eq",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\ncomparison between two values to determine if they are equivalent.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "gt",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is greater than other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "gte",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is greater than or equal to other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isArguments",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an arguments object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isArray",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an Array object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isArrayBuffer",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an ArrayBuffer object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isArrayLike",
      "parameters": [
        {
          "name": "t",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is array-like. A value is considered array-like if it's\nnot a function and has a `value.length` that's an integer greater than or\nequal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is array-like, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isArrayLikeObject",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isArrayLike` except that it also checks if `value`\nis an object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is an array-like object, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isBoolean",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a boolean primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isBuffer",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a buffer.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isDate",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Date object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isElement",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a DOM element.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isEmpty",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is empty. A value is considered empty unless itâ€™s an arguments object, array, string, or\njQuery-like collection with a length greater than 0 or an object with own enumerable properties.",
        "params": [
          {
            "name": "value",
            "description": "The value to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isEqual",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a deep comparison between two values to determine if they are\nequivalent.\n\n**Note:** This method supports comparing arrays, array buffers, booleans,\ndate objects, error objects, maps, numbers, `Object` objects, regexes,\nsets, strings, symbols, and typed arrays. `Object` objects are compared\nby their own, not inherited, enumerable properties. Functions and DOM\nnodes are **not** supported.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isEqualWith",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "IsEqualCustomizer",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isEqual` except that it accepts `customizer` which is\ninvoked to compare values. If `customizer` returns `undefined` comparisons are\nhandled by the method instead. The `customizer` is invoked with up to seven arguments:\n(objValue, othValue [, index|key, object, other, stack]).",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          },
          {
            "name": "customizer",
            "description": "The function to customize comparisons."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isError",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError\nobject.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isFinite",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a finite primitive number.\n\nNote: This method is based on Number.isFinite.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isFunction",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a callable function.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is an integer.\n\n**Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is an integer, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isLength",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is a valid array-like length.\n\n**Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is a valid length, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isMap",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Map object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "isMatch",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "source",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a deep comparison between `object` and `source` to determine if\n`object` contains equivalent property values.\n\n**Note:** This method supports comparing the same values as `_.isEqual`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          },
          {
            "name": "source",
            "description": "The object of property values to match."
          }
        ],
        "returns": "Returns `true` if `object` is a match, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isMatchWith",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "source",
          "type": "object",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "isMatchWithCustomizer",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isMatch` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined` comparisons\nare handled by the method instead. The `customizer` is invoked with three\narguments: (objValue, srcValue, index|key, object, source).",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          },
          {
            "name": "source",
            "description": "The object of property values to match."
          },
          {
            "name": "customizer",
            "description": "The function to customize comparisons."
          }
        ],
        "returns": "Returns `true` if `object` is a match, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isNaN",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is NaN.\n\nNote: This method is not the same as isNaN which returns true for undefined and other non-numeric values.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isNative",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a native function.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isNil",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is `null` or `undefined`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is nullish, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isNull",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is null.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isNumber",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Number primitive or object.\n\nNote: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),\nand new String(''))",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isObjectLike",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is object-like. A value is object-like if it's not `null`\nand has a `typeof` result of \"object\".",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is object-like, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isPlainObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a plain object, that is, an object created by the Object constructor or one with a\n[[Prototype]] of null.\n\nNote: This method assumes objects created by the Object constructor have no inherited enumerable properties.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isRegExp",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a RegExp object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isSafeInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\ndouble precision number which isn't the result of a rounded unsafe integer.\n\n**Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is a safe integer, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isSet",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Set object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "isString",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a String primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isSymbol",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is classified as a `Symbol` primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is correctly classified, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "isTypedArray",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a typed array.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isUndefined",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is undefined.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "isWeakMap",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a WeakMap object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "isWeakSet",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a WeakSet object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "lt",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is less than other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "lte",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is less than or equal to other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toArray",
      "parameters": [
        {
          "name": "value",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Converts value to an array.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toFinite",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a finite number.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted number.",
        "deprecated": false
      }
    },
    {
      "name": "toInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to an integer.\n\n**Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted integer.",
        "deprecated": false
      }
    },
    {
      "name": "toLength",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to an integer suitable for use as the length of an\narray-like object.\n\n**Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toNumber",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a number.",
        "params": [
          {
            "name": "value",
            "description": "The value to process."
          }
        ],
        "returns": "Returns the number.",
        "deprecated": false
      }
    },
    {
      "name": "toPlainObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Converts value to a plain object flattening inherited enumerable properties of value to own properties\nof the plain object.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toSafeInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a safe integer. A safe integer can be compared and\nrepresented correctly.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted integer.",
        "deprecated": false
      }
    },
    {
      "name": "toString",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts `value` to a string if it's not one. An empty string is returned\nfor `null` and `undefined` values. The sign of `-0` is preserved.",
        "params": [
          {
            "name": "value",
            "description": "The value to process."
          }
        ],
        "returns": "Returns the string.",
        "deprecated": false
      }
    },
    {
      "name": "add",
      "parameters": [
        {
          "name": "augend",
          "type": "number",
          "optional": false
        },
        {
          "name": "addend",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Adds two numbers.",
        "params": [
          {
            "name": "augend",
            "description": "The first number to add."
          },
          {
            "name": "addend",
            "description": "The second number to add."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "ceil",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded up to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round up."
          },
          {
            "name": "precision",
            "description": "The precision to round up to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "divide",
      "parameters": [
        {
          "name": "dividend",
          "type": "number",
          "optional": false
        },
        {
          "name": "divisor",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Divide two numbers.",
        "params": [
          {
            "name": "dividend",
            "description": "The first number in a division."
          },
          {
            "name": "divisor",
            "description": "The second number in a division."
          }
        ],
        "returns": "Returns the quotient.",
        "deprecated": false
      }
    },
    {
      "name": "floor",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded down to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round down."
          },
          {
            "name": "precision",
            "description": "The precision to round down to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "max",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Computes the maximum value of `array`. If `array` is empty or falsey\n`undefined` is returned.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the maximum value.",
        "deprecated": false
      }
    },
    {
      "name": "maxBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.max` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the maximum value.",
        "deprecated": false
      }
    },
    {
      "name": "mean",
      "parameters": [
        {
          "name": "collection",
          "type": "List<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the mean of the values in `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the mean.",
        "deprecated": false
      }
    },
    {
      "name": "meanBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the mean of the provided properties of the objects in the `array`",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the mean.",
        "deprecated": false
      }
    },
    {
      "name": "min",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Computes the minimum value of `array`. If `array` is empty or falsey\n`undefined` is returned.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the minimum value.",
        "deprecated": false
      }
    },
    {
      "name": "minBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.min` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the minimum value.",
        "deprecated": false
      }
    },
    {
      "name": "multiply",
      "parameters": [
        {
          "name": "multiplier",
          "type": "number",
          "optional": false
        },
        {
          "name": "multiplicand",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Multiply two numbers.",
        "params": [
          {
            "name": "multiplier",
            "description": "The first number in a multiplication."
          },
          {
            "name": "multiplicand",
            "description": "The second number in a multiplication."
          }
        ],
        "returns": "Returns the product.",
        "deprecated": false
      }
    },
    {
      "name": "round",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round."
          },
          {
            "name": "precision",
            "description": "The precision to round to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "subtract",
      "parameters": [
        {
          "name": "minuend",
          "type": "number",
          "optional": false
        },
        {
          "name": "subtrahend",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Subtract two numbers.",
        "params": [
          {
            "name": "minuend",
            "description": "The first number in a subtraction."
          },
          {
            "name": "subtrahend",
            "description": "The second number in a subtraction."
          }
        ],
        "returns": "Returns the difference.",
        "deprecated": false
      }
    },
    {
      "name": "sum",
      "parameters": [
        {
          "name": "collection",
          "type": "List<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the sum of the values in `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the sum.",
        "deprecated": false
      }
    },
    {
      "name": "sumBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "string | ((value: T) => number)",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sum` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be summed.\nThe iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the sum.",
        "deprecated": false
      }
    },
    {
      "name": "clamp",
      "parameters": [
        {
          "name": "number",
          "type": "number",
          "optional": false
        },
        {
          "name": "lower",
          "type": "number",
          "optional": false
        },
        {
          "name": "upper",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Clamps `number` within the inclusive `lower` and `upper` bounds.",
        "params": [
          {
            "name": "number",
            "description": "The number to clamp."
          },
          {
            "name": "lower",
            "description": "The lower bound."
          },
          {
            "name": "upper",
            "description": "The upper bound."
          },
          {
            "name": "number",
            "description": "The number to clamp."
          },
          {
            "name": "lower",
            "description": "The lower bound."
          },
          {
            "name": "upper",
            "description": "The upper bound."
          }
        ],
        "returns": "Returns the clamped number.",
        "deprecated": false
      }
    },
    {
      "name": "inRange",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if n is between start and up to but not including, end. If end is not specified itâ€™s set to start\nwith start then set to 0.",
        "params": [
          {
            "name": "n",
            "description": "The number to check."
          },
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "random",
      "parameters": [
        {
          "name": "floating",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Produces a random number between min and max (inclusive). If only one argument is provided a number between\n0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\nnumber is returned instead of an integer.",
        "params": [
          {
            "name": "min",
            "description": "The minimum possible value."
          },
          {
            "name": "max",
            "description": "The maximum possible value."
          },
          {
            "name": "floating",
            "description": "Specify returning a floating-point number."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "assign",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "Assigns own enumerable properties of source objects to the destination\nobject. Source objects are applied from left to right. Subsequent sources\noverwrite property assignments of previous sources.\n\n**Note:** This method mutates `object` and is loosely based on\n[`Object.assign`](https://mdn.io/Object/assign).",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "assignIn",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assign` except that it iterates over own and\ninherited source properties.\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "assignInWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assignIn` except that it accepts `customizer` which\nis invoked to produce the assigned values. If `customizer` returns `undefined`\nassignment is handled by the method instead. The `customizer` is invoked\nwith five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "assignWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assign` except that it accepts `customizer` which\nis invoked to produce the assigned values. If `customizer` returns `undefined`\nassignment is handled by the method instead. The `customizer` is invoked\nwith five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "at",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "props",
          "type": "PropertyPath[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be\nspecified as individual arguments or as arrays of keys.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "props",
            "description": "The property names or indexes of elements to pick, specified individually or in arrays."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "create",
      "parameters": [
        {
          "name": "prototype",
          "type": "T",
          "optional": false
        },
        {
          "name": "properties",
          "type": "U",
          "optional": true
        }
      ],
      "returnType": "T & U",
      "jsdoc": {
        "description": "Creates an object that inherits from the given prototype object. If a properties object is provided its own\nenumerable properties are assigned to the created object.",
        "params": [
          {
            "name": "prototype",
            "description": "The object to inherit from."
          },
          {
            "name": "properties",
            "description": "The properties to assign to the object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "defaults",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "NonNullable<TSource & TObject>",
      "jsdoc": {
        "description": "Assigns own enumerable properties of source object(s) to the destination object for all destination\nproperties that resolve to undefined. Once a property is set, additional values of the same property are\nignored.\n\nNote: This method mutates object.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "defaultsDeep",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "sources",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.defaults except that it recursively assigns default properties.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "entries",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "entriesIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "extend",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "extendWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "findKey",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ObjectIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "This method is like _.find except that it returns the key of the first element predicate returns truthy for\ninstead of the element itself.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "findLastKey",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ObjectIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "This method is like _.findKey except that it iterates over elements of a collection in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "forIn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The\niteratee is invoked with three arguments: (value, key, object). Iteratee functions may\nexit iteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "forInRight",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.forIn except that it iterates over properties of object in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "forOwn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is\ninvoked with three arguments: (value, key, object). Iteratee functions may exit\niteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "forOwnRight",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.forOwn except that it iterates over properties of object in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "functions",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of function property names from own enumerable properties\nof `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          }
        ],
        "returns": "Returns the new array of property names.",
        "deprecated": false
      }
    },
    {
      "name": "functionsIn",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of function property names from own and inherited\nenumerable properties of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          }
        ],
        "returns": "Returns the new array of property names.",
        "deprecated": false
      }
    },
    {
      "name": "get",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "path",
          "type": "TKey | [TKey]",
          "optional": false
        }
      ],
      "returnType": "TObject[TKey]",
      "jsdoc": {
        "description": "Gets the property value at path of object. If the resolved value is undefined the defaultValue is used\nin its place.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the property to get."
          },
          {
            "name": "defaultValue",
            "description": "The value returned if the resolved value is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "has",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `path` is a direct property of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path to check."
          }
        ],
        "returns": "Returns `true` if `path` exists, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "hasIn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `path` is a direct or inherited property of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path to check."
          }
        ],
        "returns": "Returns `true` if `path` exists, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "invert",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "Dictionary<string>",
      "jsdoc": {
        "description": "Creates an object composed of the inverted keys and values of object. If object contains duplicate values,\nsubsequent values overwrite property assignments of previous values unless multiValue is true.",
        "params": [
          {
            "name": "object",
            "description": "The object to invert."
          },
          {
            "name": "multiValue",
            "description": "Allow multiple values per key."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "invertBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "interatee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<string[]>",
      "jsdoc": {
        "description": "This method is like _.invert except that the inverted object is generated from the results of running each\nelement of object through iteratee. The corresponding inverted value of each inverted key is an array of\nkeys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "object",
            "description": "The object to invert."
          },
          {
            "name": "interatee",
            "description": "The iteratee invoked per element."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "invoke",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Invokes the method at path of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the method to invoke."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "keys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of the own enumerable property names of object.\n\nNote: Non-object values are coerced to objects. See the ES spec for more details.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "keysIn",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of the own and inherited enumerable property names of object.\n\nNote: Non-object values are coerced to objects.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "mapKeys",
      "parameters": [
        {
          "name": "object",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The opposite of _.mapValues; this method creates an object with the same values as object and keys generated\nby running each own enumerable property of object through iteratee.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "mapValues",
      "parameters": [
        {
          "name": "obj",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "StringIterator<TResult>",
          "optional": false
        }
      ],
      "returnType": "NumericDictionary<TResult>",
      "jsdoc": {
        "description": "Creates an object with the same keys as object and values generated by running each own\nenumerable property of object through iteratee. The iteratee function is\ninvoked with three arguments: (value, key, object).",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "merge",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "Recursively merges own and inherited enumerable properties of source\nobjects into the destination object, skipping source properties that resolve\nto `undefined`. Array and plain object properties are merged recursively.\nOther objects and value types are overridden by assignment. Source objects\nare applied from left to right. Subsequent sources overwrite property\nassignments of previous sources.\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "mergeWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "(value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.merge` except that it accepts `customizer` which\nis invoked to produce the merged values of the destination and source\nproperties. If `customizer` returns `undefined` merging is handled by the\nmethod instead. The `customizer` is invoked with six arguments:\n(objValue, srcValue, key, object, source, stack).",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "omit",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "paths",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "Pick<T, Exclude<keyof T, K[number]>>",
      "jsdoc": {
        "description": "The opposite of `_.pick`; this method creates an object composed of the\nown and inherited enumerable properties of `object` that are not omitted.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "paths",
            "description": "The property names to omit, specified\nindividually or in arrays.."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "omitBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ValueKeyIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The opposite of `_.pickBy`; this method creates an object composed of the\nown and inherited enumerable properties of `object` that `predicate`\ndoesn't return truthy for.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "predicate",
            "description": "The function invoked per property."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "pick",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "props",
          "type": "Many<U>[]",
          "optional": false
        }
      ],
      "returnType": "Pick<T, U>",
      "jsdoc": {
        "description": "Creates an object composed of the picked `object` properties.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "props",
            "description": "The property names to pick, specified\nindividually or in arrays."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "pickBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ValueKeyIterateeTypeGuard<T, S>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<S>",
      "jsdoc": {
        "description": "Creates an object composed of the `object` properties `predicate` returns\ntruthy for. The predicate is invoked with two arguments: (value, key).",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "predicate",
            "description": "The function invoked per property."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "result",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "TResult | ((...args: any[]) => TResult)",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.get except that if the resolved value is a function itâ€™s invoked with the this binding\nof its parent object and its result is returned.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the property to resolve."
          },
          {
            "name": "defaultValue",
            "description": "The value returned if the resolved value is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "set",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Sets the value at path of object. If a portion of path doesnâ€™t exist itâ€™s created. Arrays are created for\nmissing index properties while objects are created for all other missing properties. Use _.setWith to\ncustomize path creation.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "value",
            "description": "The value to set."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setWith",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "SetWithCustomizer<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.set except that it accepts customizer which is invoked to produce the objects of\npath. If customizer returns undefined path creation is handled by the method instead. The customizer is\ninvoked with three arguments: (nsValue, key, nsObject).",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "value",
            "description": "The value to set."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toPairs",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "Creates an array of own enumerable key-value pairs for object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toPairsIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "Creates an array of own and inherited enumerable key-value pairs for object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "transform",
      "parameters": [
        {
          "name": "object",
          "type": "readonly T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoVoidArrayIterator<T, TResult>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of\nrunning each of its own enumerable properties through iteratee, with each invocation potentially mutating\nthe accumulator object. The iteratee is invoked with four arguments: (accumulator,\nvalue, key, object). Iteratee functions may exit iteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          },
          {
            "name": "accumulator",
            "description": "The custom accumulator value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unset",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Removes the property at path of object.\n\nNote: This method mutates object.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to unset."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "update",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "updater",
          "type": "(value: any) => any",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to\ncustomize path creation. The updater is invoked with one argument: (value).",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "updater",
            "description": "The function to produce the updated value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "updateWith",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "updater",
          "type": "(oldValue: any) => any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "SetWithCustomizer<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.update` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "updater",
            "description": "The function to produce the updated value."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "values",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T> | List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of the own enumerable property values of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "valuesIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T> | List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of the own and inherited enumerable property values of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "chain",
      "parameters": [
        {
          "name": "value",
          "type": "TrapAny",
          "optional": false
        }
      ],
      "returnType": "CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>",
      "jsdoc": {
        "description": "Creates a lodash object that wraps value with explicit method chaining enabled.",
        "params": [
          {
            "name": "value",
            "description": "The value to wrap."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "tap",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "interceptor",
          "type": "(value: T) => void",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method invokes interceptor and returns value. The interceptor is invoked with one\nargument; (value). The purpose of this method is to \"tap into\" a method chain in order to perform operations\non intermediate results within the chain.",
        "params": [
          {
            "name": "value",
            "description": "The value to provide to interceptor."
          },
          {
            "name": "interceptor",
            "description": "The function to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "thru",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "interceptor",
          "type": "(value: T) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.tap except that it returns the result of interceptor.",
        "params": [
          {
            "name": "value",
            "description": "The value to provide to interceptor."
          },
          {
            "name": "interceptor",
            "description": "The function to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "camelCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to camel case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "capitalize",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "string extends T ? string : Capitalize<Lowercase<T>>",
      "jsdoc": {
        "description": "Converts the first character of string to upper case and the remaining to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to capitalize."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "deburr",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining\ndiacritical marks.",
        "params": [
          {
            "name": "string",
            "description": "The string to deburr."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "endsWith",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "target",
          "type": "string",
          "optional": true
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if string ends with the given target string.",
        "params": [
          {
            "name": "string",
            "description": "The string to search."
          },
          {
            "name": "target",
            "description": "The string to search for."
          },
          {
            "name": "position",
            "description": "The position to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "escape",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"`\" in string to their corresponding HTML entities.\n\nNote: No other characters are escaped. To escape additional characters use a third-party library like he.\n\nThough the \">\" character is escaped for symmetry, characters like \">\" and \"/\" donâ€™t need escaping in HTML\nand have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynensâ€™s\narticle (under \"semi-related fun fact\") for more details.\n\nBackticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,\n#102, #108, and #133 of the HTML5 Security Cheatsheet for more details.\n\nWhen working with HTML you should always quote attribute values to reduce XSS vectors.",
        "params": [
          {
            "name": "string",
            "description": "The string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "escapeRegExp",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Escapes the RegExp special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\",\n\"{\", \"}\", and \"|\" in string.",
        "params": [
          {
            "name": "string",
            "description": "The string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "kebabCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to kebab case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "lowerCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts `string`, as space separated words, to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "lowerFirst",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Uncapitalize<T>",
      "jsdoc": {
        "description": "Converts the first character of `string` to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "pad",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads string on the left and right sides if itâ€™s shorter than length. Padding characters are truncated if\nthey canâ€™t be evenly divided by length.",
        "params": [
          {
            "name": "string",
            "description": "The string to pad."
          },
          {
            "name": "length",
            "description": "The padding length."
          },
          {
            "name": "chars",
            "description": "The string used as padding."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "padEnd",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads string on the right side if itâ€™s shorter than length. Padding characters are truncated if they exceed\nlength.",
        "params": [
          {
            "name": "string",
            "description": "The string to pad."
          },
          {
            "name": "length",
            "description": "The padding length."
          },
          {
            "name": "chars",
            "description": "The string used as padding."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "padStart",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads string on the left side if itâ€™s shorter than length. Padding characters are truncated if they exceed\nlength.",
        "params": [
          {
            "name": "string",
            "description": "The string to pad."
          },
          {
            "name": "length",
            "description": "The padding length."
          },
          {
            "name": "chars",
            "description": "The string used as padding."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "parseInt",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": false
        },
        {
          "name": "radix",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used\nunless value is a hexadecimal, in which case a radix of 16 is used.\n\nNote: This method aligns with the ES5 implementation of parseInt.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          },
          {
            "name": "radix",
            "description": "The radix to interpret value by."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "repeat",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Repeats the given string n times.",
        "params": [
          {
            "name": "string",
            "description": "The string to repeat."
          },
          {
            "name": "n",
            "description": "The number of times to repeat the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "replace",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": false
        },
        {
          "name": "pattern",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replacement",
          "type": "string | ReplaceFunction",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces matches for pattern in string with replacement.\n\nNote: This method is based on String#replace.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "snakeCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to snake case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "split",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": false
        },
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": true
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Splits string by separator.\n\nNote: This method is based on String#split.",
        "params": [
          {
            "name": "string",
            "description": "The string to split."
          },
          {
            "name": "separator",
            "description": "The separator pattern to split by."
          },
          {
            "name": "limit",
            "description": "The length to truncate results to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "startCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to start case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "startsWith",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "target",
          "type": "string",
          "optional": true
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if string starts with the given target string.",
        "params": [
          {
            "name": "string",
            "description": "The string to search."
          },
          {
            "name": "target",
            "description": "The string to search for."
          },
          {
            "name": "position",
            "description": "The position to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "template",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "options",
          "type": "TemplateOptions",
          "optional": true
        }
      ],
      "returnType": "TemplateExecutor",
      "jsdoc": {
        "description": "Creates a compiled template function that can interpolate data properties in \"interpolate\" delimiters,\nHTML-escape interpolated data properties in \"escape\" delimiters, and execute JavaScript in \"evaluate\"\ndelimiters. Data properties may be accessed as free variables in the template. If a setting object is\nprovided it takes precedence over _.templateSettings values.\n\nNote: In the development build _.template utilizes\n[sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier\ndebugging.\n\nFor more information on precompiling templates see\n[lodash's custom builds documentation](https://lodash.com/custom-builds).\n\nFor more information on Chrome extension sandboxes see\n[Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).",
        "params": [
          {
            "name": "string",
            "description": "The template string."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "The HTML \"escape\" delimiter."
          },
          {
            "description": "The \"evaluate\" delimiter."
          },
          {
            "description": "An object to import into the template as free variables."
          },
          {
            "description": "The \"interpolate\" delimiter."
          },
          {
            "description": "The sourceURL of the template's compiled source."
          },
          {
            "description": "The data object variable name."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toLower",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Lowercase<T>",
      "jsdoc": {
        "description": "Converts `string`, as a whole, to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toUpper",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Uppercase<T>",
      "jsdoc": {
        "description": "Converts `string`, as a whole, to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "trim",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes leading and trailing whitespace or specified characters from string.",
        "params": [
          {
            "name": "string",
            "description": "The string to trim."
          },
          {
            "name": "chars",
            "description": "The characters to trim."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "trimEnd",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes trailing whitespace or specified characters from string.",
        "params": [
          {
            "name": "string",
            "description": "The string to trim."
          },
          {
            "name": "chars",
            "description": "The characters to trim."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "trimStart",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes leading whitespace or specified characters from string.",
        "params": [
          {
            "name": "string",
            "description": "The string to trim."
          },
          {
            "name": "chars",
            "description": "The characters to trim."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "truncate",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "options",
          "type": "TruncateOptions",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Truncates string if itâ€™s longer than the given maximum string length. The last characters of the truncated\nstring are replaced with the omission string which defaults to \"â€¦\".",
        "params": [
          {
            "name": "string",
            "description": "The string to truncate."
          },
          {
            "name": "options",
            "description": "The options object or maximum string length."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unescape",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;\nin string to their corresponding characters.\n\nNote: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library\nlike he.",
        "params": [
          {
            "name": "string",
            "description": "The string to unescape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "upperCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts `string`, as space separated words, to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "upperFirst",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Capitalize<T>",
      "jsdoc": {
        "description": "Converts the first character of `string` to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "words",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "pattern",
          "type": "string | RegExp",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Splits `string` into an array of its words.",
        "params": [
          {
            "name": "string",
            "description": "The string to inspect."
          },
          {
            "name": "pattern",
            "description": "The pattern to match words."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "attempt",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "Error | TResult",
      "jsdoc": {
        "description": "Attempts to invoke func, returning either the result or the caught error object. Any additional arguments\nare provided to func when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to attempt."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "bindAll",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "methodNames",
          "type": "Many<string>[]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Binds methods of an object to the object itself, overwriting the existing method. Method names may be\nspecified as individual arguments or as arrays of method names. If no method names are provided all\nenumerable function properties, own and inherited, of object are bound.\n\nNote: This method does not set the \"length\" property of bound functions.",
        "params": [
          {
            "name": "object",
            "description": "The object to bind and assign the bound methods to."
          },
          {
            "name": "methodNames",
            "description": "The object method names to bind, specified as individual method names or arrays of\nmethod names."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cond",
      "parameters": [
        {
          "name": "pairs",
          "type": "CondPairNullary<R>[]",
          "optional": false
        }
      ],
      "returnType": "() => R",
      "jsdoc": {
        "description": "Creates a function that iterates over `pairs` and invokes the corresponding\nfunction of the first predicate to return truthy. The predicate-function\npairs are invoked with the `this` binding and arguments of the created\nfunction.",
        "params": [
          {
            "name": "pairs",
            "description": "The predicate-function pairs."
          }
        ],
        "returns": "Returns the new composite function.",
        "deprecated": false
      }
    },
    {
      "name": "conforms",
      "parameters": [
        {
          "name": "source",
          "type": "ConformsPredicateObject<T>",
          "optional": false
        }
      ],
      "returnType": "(value: T) => boolean",
      "jsdoc": {
        "description": "Creates a function that invokes the predicate properties of `source` with the corresponding\nproperty values of a given object, returning true if all predicates return truthy, else false.",
        "deprecated": false
      }
    },
    {
      "name": "constant",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "() => T",
      "jsdoc": {
        "description": "Creates a function that returns value.",
        "params": [
          {
            "name": "value",
            "description": "The value to return from the new function."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "defaultTo",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Checks `value` to determine whether a default value should be returned in\nits place. The `defaultValue` is returned if `value` is `NaN`, `null`,\nor `undefined`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          },
          {
            "name": "defaultValue",
            "description": "The default value."
          }
        ],
        "returns": "Returns the resolved value.",
        "deprecated": false
      }
    },
    {
      "name": "flow",
      "parameters": [
        {
          "name": "f1",
          "type": "(...args: A) => R1",
          "optional": false
        },
        {
          "name": "f2",
          "type": "(a: R1) => R2",
          "optional": false
        },
        {
          "name": "f3",
          "type": "(a: R2) => R3",
          "optional": false
        },
        {
          "name": "f4",
          "type": "(a: R3) => R4",
          "optional": false
        },
        {
          "name": "f5",
          "type": "(a: R4) => R5",
          "optional": false
        },
        {
          "name": "f6",
          "type": "(a: R5) => R6",
          "optional": false
        },
        {
          "name": "f7",
          "type": "(a: R6) => R7",
          "optional": false
        }
      ],
      "returnType": "(...args: A) => R7",
      "jsdoc": {
        "description": "Creates a function that returns the result of invoking the provided functions with the this binding of the\ncreated function, where each successive invocation is supplied the return value of the previous.",
        "params": [
          {
            "name": "funcs",
            "description": "Functions to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "flowRight",
      "parameters": [
        {
          "name": "f7",
          "type": "(a: R6) => R7",
          "optional": false
        },
        {
          "name": "f6",
          "type": "(a: R5) => R6",
          "optional": false
        },
        {
          "name": "f5",
          "type": "(a: R4) => R5",
          "optional": false
        },
        {
          "name": "f4",
          "type": "(a: R3) => R4",
          "optional": false
        },
        {
          "name": "f3",
          "type": "(a: R2) => R3",
          "optional": false
        },
        {
          "name": "f2",
          "type": "(a: R1) => R2",
          "optional": false
        },
        {
          "name": "f1",
          "type": "(...args: A) => R1",
          "optional": false
        }
      ],
      "returnType": "(...args: A) => R7",
      "jsdoc": {
        "description": "This method is like _.flow except that it creates a function that invokes the provided functions from right\nto left.",
        "params": [
          {
            "name": "funcs",
            "description": "Functions to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "identity",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method returns the first argument provided to it.",
        "params": [
          {
            "name": "value",
            "description": "Any value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "iteratee",
      "parameters": [
        {
          "name": "func",
          "type": "TFunction",
          "optional": false
        }
      ],
      "returnType": "TFunction",
      "jsdoc": {
        "description": "Creates a function that invokes `func` with the arguments of the created\nfunction. If `func` is a property name the created callback returns the\nproperty value for a given element. If `func` is an object the created\ncallback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.",
        "params": [
          {
            "name": "func",
            "description": "The value to convert to a callback."
          }
        ],
        "returns": "Returns the callback.",
        "deprecated": false
      }
    },
    {
      "name": "matches",
      "parameters": [
        {
          "name": "source",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(value: any) => boolean",
      "jsdoc": {
        "description": "Creates a function that performs a deep comparison between a given object and source, returning true if the\ngiven object has equivalent property values, else false.\n\nNote: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\nstrings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own\nor inherited property value see _.matchesProperty.",
        "params": [
          {
            "name": "source",
            "description": "The object of property values to match."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "matchesProperty",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "srcValue",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(value: any) => boolean",
      "jsdoc": {
        "description": "Creates a function that compares the property value of path on a given object to value.\n\nNote: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\nstrings. Objects are compared by their own, not inherited, enumerable properties.",
        "params": [
          {
            "name": "path",
            "description": "The path of the property to get."
          },
          {
            "name": "srcValue",
            "description": "The value to match."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "method",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(object: any) => any",
      "jsdoc": {
        "description": "Creates a function that invokes the method at path on a given object. Any additional arguments are provided\nto the invoked method.",
        "params": [
          {
            "name": "path",
            "description": "The path of the method to invoke."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "methodOf",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(path: PropertyPath) => any",
      "jsdoc": {
        "description": "The opposite of _.method; this method creates a function that invokes the method at a given path on object.\nAny additional arguments are provided to the invoked method.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "mixin",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "Dictionary<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "options",
          "type": "MixinOptions",
          "optional": true
        }
      ],
      "returnType": "TObject",
      "jsdoc": {
        "description": "Adds all own enumerable function properties of a source object to the destination object. If object is a\nfunction then methods are added to its prototype as well.\n\nNote: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying\nthe original.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The object of functions to add."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify whether the functions added are chainable."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "noConflict",
      "parameters": [],
      "returnType": "LoDashStatic",
      "jsdoc": {
        "description": "Reverts the _ variable to its previous value and returns a reference to the lodash function.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "noop",
      "parameters": [
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "A no-operation function that returns undefined regardless of the arguments it receives.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "nthArg",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that returns its nth argument.",
        "params": [
          {
            "name": "n",
            "description": "The index of the argument to return."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "over",
      "parameters": [
        {
          "name": "iteratees",
          "type": "Many<(...args: any[]) => TResult>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => TResult[]",
      "jsdoc": {
        "description": "Creates a function that invokes iteratees with the arguments provided to the created function and returns\ntheir results.",
        "params": [
          {
            "name": "iteratees",
            "description": "The iteratees to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "overEvery",
      "parameters": [
        {
          "name": "predicates",
          "type": "[(arg: T) => arg is Result1, (arg: T) => arg is Result2]",
          "optional": false
        }
      ],
      "returnType": "(arg: T) => arg is Result1 & Result2",
      "jsdoc": {
        "description": "Creates a function that checks if all of the predicates return truthy when invoked with the arguments\nprovided to the created function.",
        "params": [
          {
            "name": "predicates",
            "description": "The predicates to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "overSome",
      "parameters": [
        {
          "name": "predicates",
          "type": "[(arg: T) => arg is Result1, (arg: T) => arg is Result2]",
          "optional": false
        }
      ],
      "returnType": "(arg: T) => arg is Result1 | Result2",
      "jsdoc": {
        "description": "Creates a function that checks if any of the predicates return truthy when invoked with the arguments\nprovided to the created function.",
        "params": [
          {
            "name": "predicates",
            "description": "The predicates to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "property",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "(obj: TObj) => TResult",
      "jsdoc": {
        "description": "Creates a function that returns the property value at path on a given object.",
        "params": [
          {
            "name": "path",
            "description": "The path of the property to get."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "propertyOf",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(path: PropertyPath) => any",
      "jsdoc": {
        "description": "The opposite of _.property; this method creates a function that returns the property value at a given path\non object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "range",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\nIf end is not specified itâ€™s set to start with start then set to 0. If end is less than start a zero-length\nrange is created unless a negative step is specified.",
        "params": [
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          },
          {
            "name": "step",
            "description": "The value to increment or decrement by."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "rangeRight",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "This method is like `_.range` except that it populates values in\ndescending order.",
        "params": [
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          },
          {
            "name": "step",
            "description": "The value to increment or decrement by."
          }
        ],
        "returns": "Returns the new array of numbers.",
        "deprecated": false
      }
    },
    {
      "name": "runInContext",
      "parameters": [
        {
          "name": "context",
          "type": "object",
          "optional": true
        }
      ],
      "returnType": "LoDashStatic",
      "jsdoc": {
        "description": "Create a new pristine lodash function using the given context object.",
        "params": [
          {
            "name": "context",
            "description": "The context object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "stubArray",
      "parameters": [],
      "returnType": "any[]",
      "jsdoc": {
        "description": "This method returns a new empty array.",
        "params": [],
        "returns": "Returns the new empty array.",
        "deprecated": false
      }
    },
    {
      "name": "stubFalse",
      "parameters": [],
      "returnType": "false",
      "jsdoc": {
        "description": "This method returns `false`.",
        "params": [],
        "returns": "Returns `false`.",
        "deprecated": false
      }
    },
    {
      "name": "stubObject",
      "parameters": [],
      "returnType": "any",
      "jsdoc": {
        "description": "This method returns a new empty object.",
        "params": [],
        "returns": "Returns the new empty object.",
        "deprecated": false
      }
    },
    {
      "name": "stubString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "This method returns an empty string.",
        "params": [],
        "returns": "Returns the empty string.",
        "deprecated": false
      }
    },
    {
      "name": "stubTrue",
      "parameters": [],
      "returnType": "true",
      "jsdoc": {
        "description": "This method returns `true`.",
        "params": [],
        "returns": "Returns `true`.",
        "deprecated": false
      }
    },
    {
      "name": "times",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(num: number) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee\nis invoked with one argument; (index).",
        "params": [
          {
            "name": "n",
            "description": "The number of times to invoke iteratee."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "toPath",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Converts `value` to a property path array.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the new property path array.",
        "deprecated": false
      }
    },
    {
      "name": "uniqueId",
      "parameters": [
        {
          "name": "prefix",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Generates a unique ID. If prefix is provided the ID is appended to it.",
        "params": [
          {
            "name": "prefix",
            "description": "The value to prefix the ID with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string that contains the concatenation of two or more strings.",
        "params": [
          {
            "name": "strings",
            "description": "The strings to append to the end of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.indexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the position of the first occurrence of a substring.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for in the string"
          },
          {
            "name": "position",
            "description": "The index at which to begin searching the String object. If omitted, search starts at the beginning of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.lastIndexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the last occurrence of a substring in the string.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for."
          },
          {
            "name": "position",
            "description": "The index at which to begin searching. If omitted, the search begins at the end of the string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a section of a string.",
        "params": [
          {
            "name": "start",
            "description": "The index to the beginning of the specified portion of stringObj."
          },
          {
            "name": "end",
            "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false
      }
    },
    {
      "name": "_.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "_.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false
      }
    },
    {
      "name": "_.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "_.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "_.valueOf",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false
      }
    },
    {
      "name": "_.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false
      }
    },
    {
      "name": "_.includes",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if searchString appears as a substring of the result of converting this\nobject to a String, at one or more positions that are\ngreater than or equal to position; otherwise, returns false.",
        "params": [
          {
            "name": "searchString",
            "description": "search string"
          },
          {
            "name": "position",
            "description": "If position is undefined, 0 is assumed, so as to search all of the String."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition â€“ length(this). Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "_.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "_.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "_.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "_.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "_.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.__@iterator@4630",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "_.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": null
    },
    {
      "name": "_.chunk",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[][]",
      "jsdoc": {
        "description": "Creates an array of elements split into groups the length of size. If collection canâ€™t be split evenly, the\nfinal chunk will be the remaining elements.",
        "params": [
          {
            "name": "array",
            "description": "The array to process."
          },
          {
            "name": "size",
            "description": "The length of each chunk."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.compact",
      "parameters": [
        {
          "name": "array",
          "type": "List<T | Falsey>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array with all falsey values removed. The values false, null, 0, 0n, \"\", undefined, and NaN are\nfalsey.",
        "params": [
          {
            "name": "array",
            "description": "The array to compact."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.difference",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of `array` values not included in the other provided arrays using SameValueZero for\nequality comparisons. The order and references of result values are determined by the first array.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "values",
            "description": "The arrays of values to exclude."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.differenceBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T1 | T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like _.difference except that it accepts iteratee which is invoked for each element\nof array and values to generate the criterion by which they're compared. The order and references\nof result values are determined by the first array. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "values",
            "description": "The values to exclude."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "_.differenceWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator2<T1, T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like _.difference except that it accepts comparator which is invoked to compare elements\nof array to values. The order and references of result values are determined by the first array. The\ncomparator is invoked with two arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "values",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "_.drop",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements dropped from the beginning.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to drop."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.dropRight",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements dropped from the end.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to drop."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.dropRightWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.dropWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.fill",
      "parameters": [
        {
          "name": "array",
          "type": "any[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Fills elements of array with value from start up to, but not including, end.\n\nNote: This method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to fill."
          },
          {
            "name": "value",
            "description": "The value to fill array with."
          },
          {
            "name": "start",
            "description": "The start position."
          },
          {
            "name": "end",
            "description": "The end position."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.findIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like _.find except that it returns the index of the first element predicate returns truthy\nfor instead of the element itself.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.findLastIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like _.findIndex except that it iterates over elements of collection from right to left.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.first",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [T, ...unknown[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.flatten",
      "parameters": [
        {
          "name": "array",
          "type": "List<Many<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Flattens `array` a single level deep.",
        "params": [
          {
            "name": "array",
            "description": "The array to flatten."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flattenDeep",
      "parameters": [
        {
          "name": "array",
          "type": "ListOfRecursiveArraysOrValues<T>",
          "optional": false
        }
      ],
      "returnType": "Flat<T>[]",
      "jsdoc": {
        "description": "Recursively flattens a nested array.",
        "params": [
          {
            "name": "array",
            "description": "The array to recursively flatten."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flattenDepth",
      "parameters": [
        {
          "name": "array",
          "type": "ListOfRecursiveArraysOrValues<T>",
          "optional": false
        },
        {
          "name": "depth",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Recursively flatten array up to depth times.",
        "params": [
          {
            "name": "array",
            "description": "The array to recursively flatten."
          },
          {
            "name": "number",
            "description": "The maximum recursion depth."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.fromPairs",
      "parameters": [
        {
          "name": "pairs",
          "type": "List<[PropertyName, T]>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The inverse of `_.toPairs`; this method returns an object composed\nfrom key-value `pairs`.",
        "params": [
          {
            "name": "pairs",
            "description": "The key-value pairs."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "_.head",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [T, ...unknown[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the first element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.initial",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Gets all but the last element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.intersection",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values that are included in all of the provided arrays using SameValueZero for\nequality comparisons.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.intersectionBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T1 | T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "This method is like `_.intersection` except that it accepts `iteratee`\nwhich is invoked for each element of each `arrays` to generate the criterion\nby which uniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of shared values.",
        "deprecated": false
      }
    },
    {
      "name": "_.intersectionWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T2>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator2<T1, T2>",
          "optional": false
        }
      ],
      "returnType": "T1[]",
      "jsdoc": {
        "description": "Creates an array of unique `array` values not included in the other\nprovided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\nfor equality comparisons.",
        "params": [
          {
            "name": "values",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of filtered values.",
        "deprecated": false
      }
    },
    {
      "name": "_.join",
      "parameters": [
        {
          "name": "array",
          "type": "List<any>",
          "optional": false
        },
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all elements in `array` into a string separated by `separator`.",
        "params": [
          {
            "name": "array",
            "description": "The array to convert."
          },
          {
            "name": "separator",
            "description": "The element separator."
          }
        ],
        "returns": "Returns the joined string.",
        "deprecated": false
      }
    },
    {
      "name": "_.last",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the last element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.nth",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.",
        "params": [
          {
            "name": "array",
            "description": "array The array to query."
          },
          {
            "name": "value",
            "description": "The index of the element to return."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.pull",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "T[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes all provided values from array using SameValueZero for equality comparisons.\n\nNote: Unlike _.without, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.pullAll",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pull` except that it accepts an array of values to remove.\n\n**Note:** Unlike `_.difference`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.pullAllBy",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pullAll` except that it accepts `iteratee` which is\ninvoked for each element of `array` and `values` to to generate the criterion\nby which uniqueness is computed. The iteratee is invoked with one argument: (value).\n\n**Note:** Unlike `_.differenceBy`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.pullAllWith",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": true
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.pullAll` except that it accepts `comparator` which is\ninvoked to compare elements of array to values. The comparator is invoked with\ntwo arguments: (arrVal, othVal).\n\n**Note:** Unlike `_.differenceWith`, this method mutates `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "values",
            "description": "The values to remove."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.pullAt",
      "parameters": [
        {
          "name": "array",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "indexes",
          "type": "Many<number>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\nIndexes may be specified as an array of indexes or as individual arguments.\n\nNote: Unlike _.at, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "indexes",
            "description": "The indexes of elements to remove, specified as individual indexes or arrays of indexes."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.remove",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Removes all elements from array that predicate returns truthy for and returns an array of the removed\nelements. The predicate is invoked with three arguments: (value, index, array).\n\nNote: Unlike _.filter, this method mutates array.",
        "params": [
          {
            "name": "array",
            "description": "The array to modify."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.reverse",
      "parameters": [
        {
          "name": "array",
          "type": "TList",
          "optional": false
        }
      ],
      "returnType": "TList",
      "jsdoc": {
        "description": "Reverses `array` so that the first element becomes the last, the second\nelement becomes the second to last, and so on.\n\n**Note:** This method mutates `array` and is based on\n[`Array#reverse`](https://mdn.io/Array/reverse).",
        "params": [],
        "returns": "Returns `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Uses a binary search to determine the lowest index at which `value` should\nbe inserted into `array` in order to maintain its sort order.",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedIndexBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedIndexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.indexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          }
        ],
        "returns": "Returns the index of the matched value, else `-1`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedLastIndex",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedIndex` except that it returns the highest\nindex at which `value` should be inserted into `array` in order to\nmaintain its sort order.",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedLastIndexBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sortedLastIndex` except that it accepts `iteratee`\nwhich is invoked for `value` and each element of `array` to compute their\nsort ranking. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The sorted array to inspect."
          },
          {
            "name": "value",
            "description": "The value to evaluate."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the index at which `value` should be inserted into `array`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedLastIndexOf",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.lastIndexOf` except that it performs a binary\nsearch on a sorted `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to search."
          },
          {
            "name": "value",
            "description": "The value to search for."
          }
        ],
        "returns": "Returns the index of the matched value, else `-1`.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedUniq",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it's designed and optimized\nfor sorted arrays.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "_.sortedUniqBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniqBy` except that it's designed and optimized\nfor sorted arrays.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "_.tail",
      "parameters": [
        {
          "name": "array",
          "type": "readonly [unknown, ...T]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets all but the first element of array.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.take",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements taken from the beginning.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to take."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.takeRight",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with n elements taken from the end.",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "n",
            "description": "The number of elements to take."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.takeRightWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with elements taken from the end. Elements are taken until predicate returns\nfalsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.takeWhile",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns\nfalsey. The predicate is invoked with three arguments: (value, index, array).",
        "params": [
          {
            "name": "array",
            "description": "The array to query."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.union",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for\nequality comparisons.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unionBy",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.union` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unionWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.union` except that it accepts `comparator` which\nis invoked to compare elements of `arrays`. The comparator is invoked\nwith two arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of combined values.",
        "deprecated": false
      }
    },
    {
      "name": "_.uniq",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates a duplicate-free version of an array, using\n[`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\nfor equality comparisons, in which only the first occurrence of each element\nis kept.",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "_.uniqBy",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "_.uniqWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.uniq` except that it accepts `comparator` which\nis invoked to compare elements of `array`. The comparator is invoked with\ntwo arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "array",
            "description": "The array to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new duplicate free array.",
        "deprecated": false
      }
    },
    {
      "name": "_.unzip",
      "parameters": [
        {
          "name": "array",
          "type": "T[][] | List<List<T>>",
          "optional": false
        }
      ],
      "returnType": "T[][]",
      "jsdoc": {
        "description": "This method is like _.zip except that it accepts an array of grouped elements and creates an array\nregrouping the elements to their pre-zip configuration.",
        "params": [
          {
            "name": "array",
            "description": "The array of grouped elements to process."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unzipWith",
      "parameters": [
        {
          "name": "array",
          "type": "List<List<T>>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(...values: T[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be\ncombined. The iteratee is invoked with four arguments: (accumulator, value, index, group).",
        "params": [
          {
            "name": "array",
            "description": "The array of grouped elements to process."
          },
          {
            "name": "iteratee",
            "description": "The function to combine regrouped values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.without",
      "parameters": [
        {
          "name": "array",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "values",
          "type": "T[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array excluding all provided values using SameValueZero for equality comparisons.",
        "params": [
          {
            "name": "array",
            "description": "The array to filter."
          },
          {
            "name": "values",
            "description": "The values to exclude."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.xor",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of unique values that is the symmetric difference of the provided arrays.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.xorBy",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.xor` except that it accepts `iteratee` which is\ninvoked for each element of each `arrays` to generate the criterion by which\nuniqueness is computed. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the new array of values.",
        "deprecated": false
      }
    },
    {
      "name": "_.xorWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "comparator",
          "type": "Comparator<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.xor` except that it accepts `comparator` which is\ninvoked to compare elements of `arrays`. The comparator is invoked with\ntwo arguments: (arrVal, othVal).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to inspect."
          },
          {
            "name": "comparator",
            "description": "The comparator invoked per element."
          }
        ],
        "returns": "Returns the new array of values.",
        "deprecated": false
      }
    },
    {
      "name": "_.zip",
      "parameters": [
        {
          "name": "arrays1",
          "type": "List<T1>",
          "optional": false
        },
        {
          "name": "arrays2",
          "type": "List<T2>",
          "optional": false
        }
      ],
      "returnType": "[T1, T2][]",
      "jsdoc": {
        "description": "Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\nthe second of which contains the second elements of the given arrays, and so on.",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to process."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.zipObject",
      "parameters": [
        {
          "name": "props",
          "type": "List<PropertyName>",
          "optional": false
        },
        {
          "name": "values",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "This method is like _.fromPairs except that it accepts two arrays, one of property\nidentifiers and one of corresponding values.",
        "params": [
          {
            "name": "props",
            "description": "The property names."
          },
          {
            "name": "values",
            "description": "The property values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.zipObjectDeep",
      "parameters": [
        {
          "name": "paths",
          "type": "List<PropertyPath>",
          "optional": true
        },
        {
          "name": "values",
          "type": "List<any>",
          "optional": true
        }
      ],
      "returnType": "object",
      "jsdoc": {
        "description": "This method is like _.zipObject except that it supports property paths.",
        "params": [
          {
            "name": "paths",
            "description": "The property names."
          },
          {
            "name": "values",
            "description": "The property values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.zipWith",
      "parameters": [
        {
          "name": "arrays",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(value1: T) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "This method is like _.zip except that it accepts an iteratee to specify how grouped values should be\ncombined. The iteratee is invoked with four arguments: (accumulator, value, index,\ngroup).",
        "params": [
          {
            "name": "arrays",
            "description": "The arrays to process."
          },
          {
            "name": "iteratee",
            "description": "The function to combine grouped values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.countBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<number>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is the number of times the key was returned by iteratee. The\niteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.each",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.eachRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.every",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if predicate returns truthy for all elements of collection. Iteration is stopped once predicate\nreturns falsey. The predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.filter",
      "parameters": [
        {
          "name": "collection",
          "type": "string",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "StringIterator<boolean>",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Iterates over elements of collection, returning an array of all elements predicate returns truthy for. The\npredicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.find",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratorTypeGuard<T, S>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Iterates over elements of collection, returning the first element predicate returns truthy for.\nThe predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.findLast",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIteratorTypeGuard<T, S>",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "This method is like _.find except that it iterates over elements of a collection from\nright to left.",
        "params": [
          {
            "name": "collection",
            "description": "Searches for a value in this list."
          },
          {
            "name": "predicate",
            "description": "The function called per iteration."
          },
          {
            "name": "fromIndex",
            "description": "The index to search from."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flatMap",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<Many<T>> | NumericDictionary<Many<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of flattened values by running each element in collection through iteratee\nand concating its result to the other mapped values. The iteratee is invoked with three arguments:\n(value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flatMapDeep",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.flatMap` except that it recursively flattens the\nmapped results.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "returns": "Returns the new flattened array.",
        "deprecated": false
      }
    },
    {
      "name": "_.flatMapDepth",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.flatMap` except that it recursively flattens the\nmapped results up to `depth` times.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          },
          {
            "name": "depth",
            "description": "The maximum recursion depth."
          }
        ],
        "returns": "Returns the new flattened array.",
        "deprecated": false
      }
    },
    {
      "name": "_.forEach",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Iterates over elements of collection invoking iteratee for each element. The iteratee is invoked with three arguments:\n(value, index|key, collection). Iteratee functions may exit iteration early by explicitly returning false.\n\nNote: As with other \"Collections\" methods, objects with a \"length\" property are iterated like arrays. To\navoid this behavior _.forIn or _.forOwn may be used for object iteration.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.forEachRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ArrayIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like _.forEach except that it iterates over elements of collection from right to left.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function called per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.groupBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T[]>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is an array of the elements responsible for generating the\nkey. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.invokeMap",
      "parameters": [
        {
          "name": "collection",
          "type": "object",
          "optional": false
        },
        {
          "name": "methodName",
          "type": "string",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any[]",
      "jsdoc": {
        "description": "Invokes the method named by methodName on each element in the collection returning\nan array of the results of each invoked method. Additional arguments will be provided\nto each invoked method. If methodName is a function it will be invoked for, and this\nbound to, each element in the collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "methodName",
            "description": "The name of the method to invoke."
          },
          {
            "name": "args",
            "description": "Arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.keyBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIterateeCustom<T, PropertyName>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "Creates an object composed of keys generated from the results of running each element of collection through\niteratee. The corresponding value of each key is the last element responsible for generating the key. The\niteratee function is invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.map",
      "parameters": [
        {
          "name": "collection",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "TupleIterator<T, TResult>",
          "optional": false
        }
      ],
      "returnType": "{ [K in keyof T]: TResult; }",
      "jsdoc": {
        "description": "Creates an array of values by running each element in collection through iteratee. The iteratee is\ninvoked with three arguments: (value, index|key, collection).\n\nMany lodash methods are guarded to work as iteratees for methods like _.every, _.filter, _.map, _.mapValues,\n_.reject, and _.some.\n\nThe guarded methods are:\nary, callback, chunk, clone, create, curry, curryRight, drop, dropRight, every, fill, flatten, invert, max,\nmin, parseInt, slice, sortBy, take, takeRight, template, trim, trimLeft, trimRight, trunc, random, range,\nsample, some, sum, uniq, and words",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.orderBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratees",
          "type": "Many<ListIterator<T, unknown>>",
          "optional": true
        },
        {
          "name": "orders",
          "type": "Many<boolean | \"asc\" | \"desc\">",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "This method is like `_.sortBy` except that it allows specifying the sort\norders of the iteratees to sort by. If `orders` is unspecified, all values\nare sorted in ascending order. Otherwise, specify an order of \"desc\" for\ndescending or \"asc\" for ascending sort order of corresponding values.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratees",
            "description": "The iteratees to sort by."
          },
          {
            "name": "orders",
            "description": "The sort orders of `iteratees`."
          },
          {
            "name": "guard",
            "description": "Enables use as an iteratee for functions like `_.reduce`."
          }
        ],
        "returns": "Returns the new sorted array.",
        "deprecated": false
      }
    },
    {
      "name": "_.partition",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "ValueIteratorTypeGuard<T, U>",
          "optional": false
        }
      ],
      "returnType": "[U[], Exclude<T, U>[]]",
      "jsdoc": {
        "description": "Creates an array of elements split into two groups, the first of which contains elements predicate returns truthy for,\nwhile the second of which contains elements predicate returns falsey for.\nThe predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.reduce",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "MemoListIterator<T, TResult, T[]>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "Reduces a collection to a value which is the accumulated result of running each\nelement in the collection through the callback, where each successive callback execution\nconsumes the return value of the previous execution. If accumulator is not provided the\nfirst element of the collection will be used as the initial accumulator value. The callback\nis invoked with four arguments: (accumulator, value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          },
          {
            "name": "accumulator",
            "description": "Initial value of the accumulator."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.reduceRight",
      "parameters": [
        {
          "name": "collection",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "MemoListIterator<T, TResult, T[]>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.reduce except that it iterates over elements of a collection from\nright to left.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "callback",
            "description": "The function called per iteration."
          },
          {
            "name": "accumulator",
            "description": "Initial value of the accumulator."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.reject",
      "parameters": [
        {
          "name": "collection",
          "type": "string",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "StringIterator<boolean>",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "The opposite of _.filter; this method returns the elements of collection that predicate does not return\ntruthy for.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.sample",
      "parameters": [
        {
          "name": "collection",
          "type": "readonly [T, ...T[]]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Gets a random element from collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.sampleSize",
      "parameters": [
        {
          "name": "collection",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Gets n random elements at unique keys from collection up to the size of collection.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to sample."
          },
          {
            "name": "n",
            "description": "The number of elements to sample."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.shuffle",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to shuffle."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.size",
      "parameters": [
        {
          "name": "collection",
          "type": "string | object",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Gets the size of collection by returning its length for array-like values or the number of own enumerable\nproperties for objects.",
        "params": [
          {
            "name": "collection",
            "description": "The collection to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.some",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ListIterateeCustom<T, boolean>",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if predicate returns truthy for any element of collection. Iteration is stopped once predicate\nreturns truthy. The predicate is invoked with three arguments: (value, index|key, collection).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.sortBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratees",
          "type": "Many<ListIteratee<T>>[]",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of elements, sorted in ascending order by the results of\nrunning each element in a collection through each iteratee. This method\nperforms a stable sort, that is, it preserves the original sort order of\nequal elements. The iteratees are invoked with one argument: (value).",
        "params": [
          {
            "name": "collection",
            "description": "The collection to iterate over."
          },
          {
            "name": "iteratees",
            "description": "The iteratees to sort by, specified individually or in arrays."
          }
        ],
        "returns": "Returns the new sorted array.",
        "deprecated": false
      }
    },
    {
      "name": "_.now",
      "parameters": [],
      "returnType": "number",
      "jsdoc": null
    },
    {
      "name": "_.after",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "func",
          "type": "TFunc",
          "optional": false
        }
      ],
      "returnType": "TFunc",
      "jsdoc": {
        "description": "The opposite of _.before; this method creates a function that invokes func once itâ€™s called n or more times.",
        "params": [
          {
            "name": "n",
            "description": "The number of calls before func is invoked."
          },
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.ary",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that accepts up to n arguments ignoring any additional arguments.",
        "params": [
          {
            "name": "func",
            "description": "The function to cap arguments for."
          },
          {
            "name": "n",
            "description": "The arity cap."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "_.before",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "func",
          "type": "TFunc",
          "optional": false
        }
      ],
      "returnType": "TFunc",
      "jsdoc": {
        "description": "Creates a function that invokes func, with the this binding and arguments of the created function, while\nitâ€™s called less than n times. Subsequent calls to the created function return the result of the last func\ninvocation.",
        "params": [
          {
            "name": "n",
            "description": "The number of calls at which func is no longer invoked."
          },
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.bind",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": false
        },
        {
          "name": "partials",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind\narguments to those provided to the bound function.\n\nThe _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for\npartially applied arguments.\n\nNote: Unlike native Function#bind this method does not set the \"length\" property of bound functions.",
        "params": [
          {
            "name": "func",
            "description": "The function to bind."
          },
          {
            "name": "thisArg",
            "description": "The this binding of func."
          },
          {
            "name": "partials",
            "description": "The arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.placeholder",
      "parameters": [
        {
          "name": "value",
          "type": "TrapAny",
          "optional": false
        }
      ],
      "returnType": "Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.bindKey",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "key",
          "type": "string",
          "optional": false
        },
        {
          "name": "partials",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments\nto those provided to the bound function.\n\nThis method differs from _.bind by allowing bound functions to reference methods that may be redefined\nor donâ€™t yet exist. See Peter Michauxâ€™s article for more details.\n\nThe _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder\nfor partially applied arguments.",
        "params": [
          {
            "name": "object",
            "description": "The object the method belongs to."
          },
          {
            "name": "key",
            "description": "The key of the method."
          },
          {
            "name": "partials",
            "description": "The arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.curry",
      "parameters": [
        {
          "name": "func",
          "type": "(t1: T1) => R",
          "optional": false
        },
        {
          "name": "arity",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "CurriedFunction1<T1, R>",
      "jsdoc": null
    },
    {
      "name": "_.curryRight",
      "parameters": [
        {
          "name": "func",
          "type": "(t1: T1) => R",
          "optional": false
        },
        {
          "name": "arity",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "RightCurriedFunction1<T1, R>",
      "jsdoc": null
    },
    {
      "name": "_.debounce",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "DebounceSettingsLeading",
          "optional": false
        }
      ],
      "returnType": "DebouncedFuncLeading<T>",
      "jsdoc": {
        "description": "Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\nthe last time the debounced function was invoked. The debounced function comes with a cancel method to\ncancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\nindicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\ncalls to the debounced function return the result of the last func invocation.\n\nNote: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\nif the the debounced function is invoked more than once during the wait timeout.\n\nSee David Corbachoâ€™s article for details over the differences between _.debounce and _.throttle.",
        "params": [
          {
            "name": "func",
            "description": "The function to debounce."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to delay."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify invoking on the leading edge of the timeout."
          },
          {
            "description": "The maximum time func is allowed to be delayed before itâ€™s invoked."
          },
          {
            "description": "Specify invoking on the trailing edge of the timeout."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.defer",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to\nfunc when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to defer."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the function with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.delay",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Invokes func after wait milliseconds. Any additional arguments are provided to func when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to delay."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to delay invocation."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the function with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flip",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a function that invokes `func` with arguments reversed.",
        "params": [
          {
            "name": "func",
            "description": "The function to flip arguments for."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "_.memoize",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "resolver",
          "type": "(...args: Parameters<T>) => any",
          "optional": true
        }
      ],
      "returnType": "T & MemoizedFunction",
      "jsdoc": {
        "description": "Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\nstoring the result based on the arguments provided to the memoized function. By default, the first argument\nprovided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\nthe this binding of the memoized function.",
        "params": [
          {
            "name": "func",
            "description": "The function to have its output memoized."
          },
          {
            "name": "resolver",
            "description": "The function to resolve the cache key."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.negate",
      "parameters": [
        {
          "name": "predicate",
          "type": "(...args: T) => boolean",
          "optional": false
        }
      ],
      "returnType": "(...args: T) => boolean",
      "jsdoc": {
        "description": "Creates a function that negates the result of the predicate func. The func predicate is invoked with\nthe this binding and arguments of the created function.",
        "params": [
          {
            "name": "predicate",
            "description": "The predicate to negate."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.once",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a function that is restricted to invoking func once. Repeat calls to the function return the value\nof the first call. The func is invoked with the this binding and arguments of the created function.",
        "params": [
          {
            "name": "func",
            "description": "The function to restrict."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.overArgs",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "transforms",
          "type": "Many<(...args: any[]) => any>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that runs each argument through a corresponding transform function.",
        "params": [
          {
            "name": "func",
            "description": "The function to wrap."
          },
          {
            "name": "transforms",
            "description": "The functions to transform arguments, specified as individual functions or arrays\nof functions."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.partial",
      "parameters": [
        {
          "name": "func",
          "type": "Function2<T1, T2, R>",
          "optional": false
        },
        {
          "name": "plc1",
          "type": "LoDashStatic",
          "optional": false
        },
        {
          "name": "arg2",
          "type": "T2",
          "optional": false
        }
      ],
      "returnType": "Function1<T1, R>",
      "jsdoc": {
        "description": "Creates a function that, when called, invokes func with any additional partial arguments\nprepended to those provided to the new function. This method is similar to _.bind except\nit does not alter the this binding.",
        "params": [
          {
            "name": "func",
            "description": "The function to partially apply arguments to."
          },
          {
            "name": "args",
            "description": "Arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.partialRight",
      "parameters": [
        {
          "name": "func",
          "type": "Function0<R>",
          "optional": false
        }
      ],
      "returnType": "Function0<R>",
      "jsdoc": {
        "description": "This method is like _.partial except that partial arguments are appended to those provided\nto the new function.",
        "params": [
          {
            "name": "func",
            "description": "The function to partially apply arguments to."
          },
          {
            "name": "args",
            "description": "Arguments to be partially applied."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.rearg",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "indexes",
          "type": "Many<number>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with arguments arranged according to the specified indexes where the\nargument value at the first index is provided as the first argument, the argument value at the second index\nis provided as the second argument, and so on.",
        "params": [
          {
            "name": "func",
            "description": "The function to rearrange arguments for."
          },
          {
            "name": "indexes",
            "description": "The arranged argument indexes, specified as individual indexes or arrays of indexes."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.rest",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => any",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of the created function and arguments from start\nand beyond provided as an array.\n\nNote: This method is based on the rest parameter.",
        "params": [
          {
            "name": "func",
            "description": "The function to apply a rest parameter to."
          },
          {
            "name": "start",
            "description": "The start position of the rest parameter."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.spread",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => TResult",
      "jsdoc": {
        "description": "Creates a function that invokes func with the this binding of the created function and an array of arguments\nmuch like Function#apply.\n\nNote: This method is based on the spread operator.",
        "params": [
          {
            "name": "func",
            "description": "The function to spread arguments over."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.throttle",
      "parameters": [
        {
          "name": "func",
          "type": "T",
          "optional": false
        },
        {
          "name": "wait",
          "type": "number",
          "optional": true
        },
        {
          "name": "options",
          "type": "ThrottleSettingsLeading",
          "optional": true
        }
      ],
      "returnType": "DebouncedFuncLeading<T>",
      "jsdoc": {
        "description": "Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled\nfunction comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke\nthem. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge\nof the wait timeout. Subsequent calls to the throttled function return the result of the last func call.\n\nNote: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if\nthe the throttled function is invoked more than once during the wait timeout.",
        "params": [
          {
            "name": "func",
            "description": "The function to throttle."
          },
          {
            "name": "wait",
            "description": "The number of milliseconds to throttle invocations to."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify invoking on the leading edge of the timeout."
          },
          {
            "description": "Specify invoking on the trailing edge of the timeout."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unary",
      "parameters": [
        {
          "name": "func",
          "type": "(arg1: T, ...args: any[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "(arg1: T) => TResult",
      "jsdoc": {
        "description": "Creates a function that accepts up to one argument, ignoring any\nadditional arguments.",
        "params": [
          {
            "name": "func",
            "description": "The function to cap arguments for."
          }
        ],
        "returns": "Returns the new function.",
        "deprecated": false
      }
    },
    {
      "name": "_.wrap",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "wrapper",
          "type": "(value: T, ...args: TArgs[]) => TResult",
          "optional": false
        }
      ],
      "returnType": "(...args: TArgs[]) => TResult",
      "jsdoc": {
        "description": "Creates a function that provides value to the wrapper function as its first argument. Any additional\narguments provided to the function are appended to those provided to the wrapper function. The wrapper is\ninvoked with the this binding of the created function.",
        "params": [
          {
            "name": "value",
            "description": "The value to wrap."
          },
          {
            "name": "wrapper",
            "description": "The wrapper function."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.castArray",
      "parameters": [
        {
          "name": "value",
          "type": "Many<T>",
          "optional": true
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Casts value as an array if itâ€™s not one.",
        "params": [
          {
            "name": "value",
            "description": "The value to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.clone",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Creates a shallow clone of value.\n\nNote: This method is loosely based on the structured clone algorithm and supports cloning arrays,\narray buffers, booleans, date objects, maps, numbers, Object objects, regexes, sets, strings, symbols,\nand typed arrays. The own enumerable properties of arguments objects are cloned as plain objects. An empty\nobject is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.",
        "params": [
          {
            "name": "value",
            "description": "The value to clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.cloneDeep",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.clone except that it recursively clones value.",
        "params": [
          {
            "name": "value",
            "description": "The value to recursively clone."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.cloneDeepWith",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "CloneDeepWithCustomizer<T>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.cloneWith except that it recursively clones value.",
        "params": [
          {
            "name": "value",
            "description": "The value to recursively clone."
          },
          {
            "name": "customizer",
            "description": "The function to customize cloning."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.cloneWith",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "CloneWithCustomizer<T, TResult>",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.clone except that it accepts customizer which is invoked to produce the cloned value.\nIf customizer returns undefined cloning is handled by the method instead.",
        "params": [
          {
            "name": "value",
            "description": "The value to clone."
          },
          {
            "name": "customizer",
            "description": "The function to customize cloning."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.conformsTo",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "source",
          "type": "ConformsPredicateObject<T>",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if object conforms to source by invoking the predicate properties of source with the\ncorresponding property values of object.\n\nNote: This method is equivalent to _.conforms when source is partially applied.",
        "deprecated": false
      }
    },
    {
      "name": "_.eq",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\ncomparison between two values to determine if they are equivalent.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.gt",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is greater than other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.gte",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is greater than or equal to other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isArguments",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an arguments object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isArray",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an Array object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isArrayBuffer",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as an ArrayBuffer object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isArrayLike",
      "parameters": [
        {
          "name": "t",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is array-like. A value is considered array-like if it's\nnot a function and has a `value.length` that's an integer greater than or\nequal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is array-like, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isArrayLikeObject",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isArrayLike` except that it also checks if `value`\nis an object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is an array-like object, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isBoolean",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a boolean primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isBuffer",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a buffer.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isDate",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Date object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isElement",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a DOM element.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isEmpty",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is empty. A value is considered empty unless itâ€™s an arguments object, array, string, or\njQuery-like collection with a length greater than 0 or an object with own enumerable properties.",
        "params": [
          {
            "name": "value",
            "description": "The value to inspect."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isEqual",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a deep comparison between two values to determine if they are\nequivalent.\n\n**Note:** This method supports comparing arrays, array buffers, booleans,\ndate objects, error objects, maps, numbers, `Object` objects, regexes,\nsets, strings, symbols, and typed arrays. `Object` objects are compared\nby their own, not inherited, enumerable properties. Functions and DOM\nnodes are **not** supported.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isEqualWith",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "IsEqualCustomizer",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isEqual` except that it accepts `customizer` which is\ninvoked to compare values. If `customizer` returns `undefined` comparisons are\nhandled by the method instead. The `customizer` is invoked with up to seven arguments:\n(objValue, othValue [, index|key, object, other, stack]).",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          },
          {
            "name": "customizer",
            "description": "The function to customize comparisons."
          }
        ],
        "returns": "Returns `true` if the values are equivalent, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isError",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is an Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, or URIError\nobject.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isFinite",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a finite primitive number.\n\nNote: This method is based on Number.isFinite.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isFunction",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a callable function.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is an integer.\n\n**Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is an integer, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isLength",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is a valid array-like length.\n\n**Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is a valid length, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isMap",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Map object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isMatch",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "source",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Performs a deep comparison between `object` and `source` to determine if\n`object` contains equivalent property values.\n\n**Note:** This method supports comparing the same values as `_.isEqual`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          },
          {
            "name": "source",
            "description": "The object of property values to match."
          }
        ],
        "returns": "Returns `true` if `object` is a match, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isMatchWith",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "source",
          "type": "object",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "isMatchWithCustomizer",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "This method is like `_.isMatch` except that it accepts `customizer` which\nis invoked to compare values. If `customizer` returns `undefined` comparisons\nare handled by the method instead. The `customizer` is invoked with three\narguments: (objValue, srcValue, index|key, object, source).",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          },
          {
            "name": "source",
            "description": "The object of property values to match."
          },
          {
            "name": "customizer",
            "description": "The function to customize comparisons."
          }
        ],
        "returns": "Returns `true` if `object` is a match, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isNaN",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is NaN.\n\nNote: This method is not the same as isNaN which returns true for undefined and other non-numeric values.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isNative",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a native function.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isNil",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is `null` or `undefined`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is nullish, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isNull",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is null.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isNumber",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Number primitive or object.\n\nNote: To exclude Infinity, -Infinity, and NaN, which are classified as numbers, use the _.isFinite method.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is the language type of Object. (e.g. arrays, functions, objects, regexes, new Number(0),\nand new String(''))",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isObjectLike",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is object-like. A value is object-like if it's not `null`\nand has a `typeof` result of \"object\".",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is object-like, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isPlainObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is a plain object, that is, an object created by the Object constructor or one with a\n[[Prototype]] of null.\n\nNote: This method assumes objects created by the Object constructor have no inherited enumerable properties.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isRegExp",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a RegExp object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isSafeInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\ndouble precision number which isn't the result of a rounded unsafe integer.\n\n**Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is a safe integer, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isSet",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a Set object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isString",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a String primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isSymbol",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `value` is classified as a `Symbol` primitive or object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns `true` if `value` is correctly classified, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.isTypedArray",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a typed array.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isUndefined",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is undefined.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.isWeakMap",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a WeakMap object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "_.isWeakSet",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is classified as a WeakSet object.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          }
        ],
        "returns": "Returns true if value is correctly classified, else false.",
        "deprecated": false
      }
    },
    {
      "name": "_.lt",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is less than other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.lte",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "other",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if value is less than or equal to other.",
        "params": [
          {
            "name": "value",
            "description": "The value to compare."
          },
          {
            "name": "other",
            "description": "The other value to compare."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toArray",
      "parameters": [
        {
          "name": "value",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Converts value to an array.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toFinite",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a finite number.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted number.",
        "deprecated": false
      }
    },
    {
      "name": "_.toInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to an integer.\n\n**Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted integer.",
        "deprecated": false
      }
    },
    {
      "name": "_.toLength",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to an integer suitable for use as the length of an\narray-like object.\n\n**Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toNumber",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a number.",
        "params": [
          {
            "name": "value",
            "description": "The value to process."
          }
        ],
        "returns": "Returns the number.",
        "deprecated": false
      }
    },
    {
      "name": "_.toPlainObject",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Converts value to a plain object flattening inherited enumerable properties of value to own properties\nof the plain object.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toSafeInteger",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts `value` to a safe integer. A safe integer can be compared and\nrepresented correctly.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the converted integer.",
        "deprecated": false
      }
    },
    {
      "name": "_.add",
      "parameters": [
        {
          "name": "augend",
          "type": "number",
          "optional": false
        },
        {
          "name": "addend",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Adds two numbers.",
        "params": [
          {
            "name": "augend",
            "description": "The first number to add."
          },
          {
            "name": "addend",
            "description": "The second number to add."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.ceil",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded up to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round up."
          },
          {
            "name": "precision",
            "description": "The precision to round up to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.divide",
      "parameters": [
        {
          "name": "dividend",
          "type": "number",
          "optional": false
        },
        {
          "name": "divisor",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Divide two numbers.",
        "params": [
          {
            "name": "dividend",
            "description": "The first number in a division."
          },
          {
            "name": "divisor",
            "description": "The second number in a division."
          }
        ],
        "returns": "Returns the quotient.",
        "deprecated": false
      }
    },
    {
      "name": "_.floor",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded down to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round down."
          },
          {
            "name": "precision",
            "description": "The precision to round down to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.max",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Computes the maximum value of `array`. If `array` is empty or falsey\n`undefined` is returned.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the maximum value.",
        "deprecated": false
      }
    },
    {
      "name": "_.maxBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.max` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the maximum value.",
        "deprecated": false
      }
    },
    {
      "name": "_.mean",
      "parameters": [
        {
          "name": "collection",
          "type": "List<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the mean of the values in `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the mean.",
        "deprecated": false
      }
    },
    {
      "name": "_.meanBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the mean of the provided properties of the objects in the `array`",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the mean.",
        "deprecated": false
      }
    },
    {
      "name": "_.min",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Computes the minimum value of `array`. If `array` is empty or falsey\n`undefined` is returned.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the minimum value.",
        "deprecated": false
      }
    },
    {
      "name": "_.minBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.min` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the criterion by which\nthe value is ranked. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the minimum value.",
        "deprecated": false
      }
    },
    {
      "name": "_.multiply",
      "parameters": [
        {
          "name": "multiplier",
          "type": "number",
          "optional": false
        },
        {
          "name": "multiplicand",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Multiply two numbers.",
        "params": [
          {
            "name": "multiplier",
            "description": "The first number in a multiplication."
          },
          {
            "name": "multiplicand",
            "description": "The second number in a multiplication."
          }
        ],
        "returns": "Returns the product.",
        "deprecated": false
      }
    },
    {
      "name": "_.round",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Calculates n rounded to precision.",
        "params": [
          {
            "name": "n",
            "description": "The number to round."
          },
          {
            "name": "precision",
            "description": "The precision to round to."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.subtract",
      "parameters": [
        {
          "name": "minuend",
          "type": "number",
          "optional": false
        },
        {
          "name": "subtrahend",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Subtract two numbers.",
        "params": [
          {
            "name": "minuend",
            "description": "The first number in a subtraction."
          },
          {
            "name": "subtrahend",
            "description": "The second number in a subtraction."
          }
        ],
        "returns": "Returns the difference.",
        "deprecated": false
      }
    },
    {
      "name": "_.sum",
      "parameters": [
        {
          "name": "collection",
          "type": "List<any>",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Computes the sum of the values in `array`.",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          }
        ],
        "returns": "Returns the sum.",
        "deprecated": false
      }
    },
    {
      "name": "_.sumBy",
      "parameters": [
        {
          "name": "collection",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "string | ((value: T) => number)",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "This method is like `_.sum` except that it accepts `iteratee` which is\ninvoked for each element in `array` to generate the value to be summed.\nThe iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "array",
            "description": "The array to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The iteratee invoked per element."
          }
        ],
        "returns": "Returns the sum.",
        "deprecated": false
      }
    },
    {
      "name": "_.clamp",
      "parameters": [
        {
          "name": "number",
          "type": "number",
          "optional": false
        },
        {
          "name": "lower",
          "type": "number",
          "optional": false
        },
        {
          "name": "upper",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Clamps `number` within the inclusive `lower` and `upper` bounds.",
        "params": [
          {
            "name": "number",
            "description": "The number to clamp."
          },
          {
            "name": "lower",
            "description": "The lower bound."
          },
          {
            "name": "upper",
            "description": "The upper bound."
          },
          {
            "name": "number",
            "description": "The number to clamp."
          },
          {
            "name": "lower",
            "description": "The lower bound."
          },
          {
            "name": "upper",
            "description": "The upper bound."
          }
        ],
        "returns": "Returns the clamped number.",
        "deprecated": false
      }
    },
    {
      "name": "_.inRange",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if n is between start and up to but not including, end. If end is not specified itâ€™s set to start\nwith start then set to 0.",
        "params": [
          {
            "name": "n",
            "description": "The number to check."
          },
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.random",
      "parameters": [
        {
          "name": "floating",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Produces a random number between min and max (inclusive). If only one argument is provided a number between\n0 and the given number is returned. If floating is true, or either min or max are floats, a floating-point\nnumber is returned instead of an integer.",
        "params": [
          {
            "name": "min",
            "description": "The minimum possible value."
          },
          {
            "name": "max",
            "description": "The maximum possible value."
          },
          {
            "name": "floating",
            "description": "Specify returning a floating-point number."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.assign",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "Assigns own enumerable properties of source objects to the destination\nobject. Source objects are applied from left to right. Subsequent sources\noverwrite property assignments of previous sources.\n\n**Note:** This method mutates `object` and is loosely based on\n[`Object.assign`](https://mdn.io/Object/assign).",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.assignIn",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assign` except that it iterates over own and\ninherited source properties.\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.assignInWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assignIn` except that it accepts `customizer` which\nis invoked to produce the assigned values. If `customizer` returns `undefined`\nassignment is handled by the method instead. The `customizer` is invoked\nwith five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.assignWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.assign` except that it accepts `customizer` which\nis invoked to produce the assigned values. If `customizer` returns `undefined`\nassignment is handled by the method instead. The `customizer` is invoked\nwith five arguments: (objValue, srcValue, key, object, source).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.create",
      "parameters": [
        {
          "name": "prototype",
          "type": "T",
          "optional": false
        },
        {
          "name": "properties",
          "type": "U",
          "optional": true
        }
      ],
      "returnType": "T & U",
      "jsdoc": {
        "description": "Creates an object that inherits from the given prototype object. If a properties object is provided its own\nenumerable properties are assigned to the created object.",
        "params": [
          {
            "name": "prototype",
            "description": "The object to inherit from."
          },
          {
            "name": "properties",
            "description": "The properties to assign to the object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.defaults",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "NonNullable<TSource & TObject>",
      "jsdoc": {
        "description": "Assigns own enumerable properties of source object(s) to the destination object for all destination\nproperties that resolve to undefined. Once a property is set, additional values of the same property are\nignored.\n\nNote: This method mutates object.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.defaultsDeep",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "sources",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.defaults except that it recursively assigns default properties.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "sources",
            "description": "The source objects."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.entries",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.entriesIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.extend",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.extendWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "AssignCustomizer",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.findKey",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ObjectIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "This method is like _.find except that it returns the key of the first element predicate returns truthy for\ninstead of the element itself.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.findLastKey",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ObjectIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "This method is like _.findKey except that it iterates over elements of a collection in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to search."
          },
          {
            "name": "predicate",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.forIn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The\niteratee is invoked with three arguments: (value, key, object). Iteratee functions may\nexit iteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.forInRight",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.forIn except that it iterates over properties of object in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.forOwn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is\ninvoked with three arguments: (value, key, object). Iteratee functions may exit\niteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.forOwnRight",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ObjectIterator<T, any>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.forOwn except that it iterates over properties of object in the opposite order.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.functions",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of function property names from own enumerable properties\nof `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          }
        ],
        "returns": "Returns the new array of property names.",
        "deprecated": false
      }
    },
    {
      "name": "_.functionsIn",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of function property names from own and inherited\nenumerable properties of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to inspect."
          }
        ],
        "returns": "Returns the new array of property names.",
        "deprecated": false
      }
    },
    {
      "name": "_.get",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "path",
          "type": "TKey | [TKey]",
          "optional": false
        }
      ],
      "returnType": "TObject[TKey]",
      "jsdoc": {
        "description": "Gets the property value at path of object. If the resolved value is undefined the defaultValue is used\nin its place.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the property to get."
          },
          {
            "name": "defaultValue",
            "description": "The value returned if the resolved value is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.has",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `path` is a direct property of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path to check."
          }
        ],
        "returns": "Returns `true` if `path` exists, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.hasIn",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if `path` is a direct or inherited property of `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path to check."
          }
        ],
        "returns": "Returns `true` if `path` exists, else `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.invert",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "Dictionary<string>",
      "jsdoc": {
        "description": "Creates an object composed of the inverted keys and values of object. If object contains duplicate values,\nsubsequent values overwrite property assignments of previous values unless multiValue is true.",
        "params": [
          {
            "name": "object",
            "description": "The object to invert."
          },
          {
            "name": "multiValue",
            "description": "Allow multiple values per key."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.invertBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": false
        },
        {
          "name": "interatee",
          "type": "ValueIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<string[]>",
      "jsdoc": {
        "description": "This method is like _.invert except that the inverted object is generated from the results of running each\nelement of object through iteratee. The corresponding inverted value of each inverted key is an array of\nkeys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).",
        "params": [
          {
            "name": "object",
            "description": "The object to invert."
          },
          {
            "name": "interatee",
            "description": "The iteratee invoked per element."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.invoke",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "Invokes the method at path of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the method to invoke."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.keys",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of the own enumerable property names of object.\n\nNote: Non-object values are coerced to objects. See the ES spec for more details.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.keysIn",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Creates an array of the own and inherited enumerable property names of object.\n\nNote: Non-object values are coerced to objects.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.mapKeys",
      "parameters": [
        {
          "name": "object",
          "type": "List<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "ListIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The opposite of _.mapValues; this method creates an object with the same values as object and keys generated\nby running each own enumerable property of object through iteratee.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.mapValues",
      "parameters": [
        {
          "name": "obj",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "StringIterator<TResult>",
          "optional": false
        }
      ],
      "returnType": "NumericDictionary<TResult>",
      "jsdoc": {
        "description": "Creates an object with the same keys as object and values generated by running each own\nenumerable property of object through iteratee. The iteratee function is\ninvoked with three arguments: (value, key, object).",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.merge",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "Recursively merges own and inherited enumerable properties of source\nobjects into the destination object, skipping source properties that resolve\nto `undefined`. Array and plain object properties are merged recursively.\nOther objects and value types are overridden by assignment. Source objects\nare applied from left to right. Subsequent sources overwrite property\nassignments of previous sources.\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The source objects."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.mergeWith",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "TSource",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "(value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any",
          "optional": false
        }
      ],
      "returnType": "TObject & TSource",
      "jsdoc": {
        "description": "This method is like `_.merge` except that it accepts `customizer` which\nis invoked to produce the merged values of the destination and source\nproperties. If `customizer` returns `undefined` merging is handled by the\nmethod instead. The `customizer` is invoked with six arguments:\n(objValue, srcValue, key, object, source, stack).",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The source objects."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.omit",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "paths",
          "type": "K",
          "optional": false
        }
      ],
      "returnType": "Pick<T, Exclude<keyof T, K[number]>>",
      "jsdoc": {
        "description": "The opposite of `_.pick`; this method creates an object composed of the\nown and inherited enumerable properties of `object` that are not omitted.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "paths",
            "description": "The property names to omit, specified\nindividually or in arrays.."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "_.omitBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ValueKeyIteratee<T>",
          "optional": true
        }
      ],
      "returnType": "Dictionary<T>",
      "jsdoc": {
        "description": "The opposite of `_.pickBy`; this method creates an object composed of the\nown and inherited enumerable properties of `object` that `predicate`\ndoesn't return truthy for.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "predicate",
            "description": "The function invoked per property."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "_.pick",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "props",
          "type": "Many<U>[]",
          "optional": false
        }
      ],
      "returnType": "Pick<T, U>",
      "jsdoc": {
        "description": "Creates an object composed of the picked `object` properties.",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "props",
            "description": "The property names to pick, specified\nindividually or in arrays."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "_.pickBy",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "ValueKeyIterateeTypeGuard<T, S>",
          "optional": false
        }
      ],
      "returnType": "Dictionary<S>",
      "jsdoc": {
        "description": "Creates an object composed of the `object` properties `predicate` returns\ntruthy for. The predicate is invoked with two arguments: (value, key).",
        "params": [
          {
            "name": "object",
            "description": "The source object."
          },
          {
            "name": "predicate",
            "description": "The function invoked per property."
          }
        ],
        "returns": "Returns the new object.",
        "deprecated": false
      }
    },
    {
      "name": "_.result",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "TResult | ((...args: any[]) => TResult)",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.get except that if the resolved value is a function itâ€™s invoked with the this binding\nof its parent object and its result is returned.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "path",
            "description": "The path of the property to resolve."
          },
          {
            "name": "defaultValue",
            "description": "The value returned if the resolved value is undefined."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.set",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Sets the value at path of object. If a portion of path doesnâ€™t exist itâ€™s created. Arrays are created for\nmissing index properties while objects are created for all other missing properties. Use _.setWith to\ncustomize path creation.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "value",
            "description": "The value to set."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.setWith",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "value",
          "type": "any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "SetWithCustomizer<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like _.set except that it accepts customizer which is invoked to produce the objects of\npath. If customizer returns undefined path creation is handled by the method instead. The customizer is\ninvoked with three arguments: (nsValue, key, nsObject).",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "value",
            "description": "The value to set."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toPairs",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "Creates an array of own enumerable key-value pairs for object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toPairsIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T>",
          "optional": true
        }
      ],
      "returnType": "[string, T][]",
      "jsdoc": {
        "description": "Creates an array of own and inherited enumerable key-value pairs for object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.transform",
      "parameters": [
        {
          "name": "object",
          "type": "readonly T[]",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "MemoVoidArrayIterator<T, TResult>",
          "optional": false
        },
        {
          "name": "accumulator",
          "type": "TResult",
          "optional": true
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of\nrunning each of its own enumerable properties through iteratee, with each invocation potentially mutating\nthe accumulator object. The iteratee is invoked with four arguments: (accumulator,\nvalue, key, object). Iteratee functions may exit iteration early by explicitly returning false.",
        "params": [
          {
            "name": "object",
            "description": "The object to iterate over."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          },
          {
            "name": "accumulator",
            "description": "The custom accumulator value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unset",
      "parameters": [
        {
          "name": "object",
          "type": "any",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Removes the property at path of object.\n\nNote: This method mutates object.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to unset."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.update",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "updater",
          "type": "(value: any) => any",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to\ncustomize path creation. The updater is invoked with one argument: (value).",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "updater",
            "description": "The function to produce the updated value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.updateWith",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "updater",
          "type": "(oldValue: any) => any",
          "optional": false
        },
        {
          "name": "customizer",
          "type": "SetWithCustomizer<T>",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method is like `_.update` except that it accepts `customizer` which is\ninvoked to produce the objects of `path`.  If `customizer` returns `undefined`\npath creation is handled by the method instead. The `customizer` is invoked\nwith three arguments: (nsValue, key, nsObject).\n\n**Note:** This method mutates `object`.",
        "params": [
          {
            "name": "object",
            "description": "The object to modify."
          },
          {
            "name": "path",
            "description": "The path of the property to set."
          },
          {
            "name": "updater",
            "description": "The function to produce the updated value."
          },
          {
            "name": "customizer",
            "description": "The function to customize assigned values."
          }
        ],
        "returns": "Returns `object`.",
        "deprecated": false
      }
    },
    {
      "name": "_.values",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T> | List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of the own enumerable property values of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.valuesIn",
      "parameters": [
        {
          "name": "object",
          "type": "Dictionary<T> | NumericDictionary<T> | List<T>",
          "optional": false
        }
      ],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Creates an array of the own and inherited enumerable property values of object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.chain",
      "parameters": [
        {
          "name": "value",
          "type": "TrapAny",
          "optional": false
        }
      ],
      "returnType": "CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>",
      "jsdoc": {
        "description": "Creates a lodash object that wraps value with explicit method chaining enabled.",
        "params": [
          {
            "name": "value",
            "description": "The value to wrap."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.tap",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "interceptor",
          "type": "(value: T) => void",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method invokes interceptor and returns value. The interceptor is invoked with one\nargument; (value). The purpose of this method is to \"tap into\" a method chain in order to perform operations\non intermediate results within the chain.",
        "params": [
          {
            "name": "value",
            "description": "The value to provide to interceptor."
          },
          {
            "name": "interceptor",
            "description": "The function to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.thru",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "interceptor",
          "type": "(value: T) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult",
      "jsdoc": {
        "description": "This method is like _.tap except that it returns the result of interceptor.",
        "params": [
          {
            "name": "value",
            "description": "The value to provide to interceptor."
          },
          {
            "name": "interceptor",
            "description": "The function to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.camelCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to camel case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.capitalize",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "string extends T ? string : Capitalize<Lowercase<T>>",
      "jsdoc": {
        "description": "Converts the first character of string to upper case and the remaining to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to capitalize."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.deburr",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Deburrs string by converting latin-1 supplementary letters to basic latin letters and removing combining\ndiacritical marks.",
        "params": [
          {
            "name": "string",
            "description": "The string to deburr."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.escape",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"`\" in string to their corresponding HTML entities.\n\nNote: No other characters are escaped. To escape additional characters use a third-party library like he.\n\nThough the \">\" character is escaped for symmetry, characters like \">\" and \"/\" donâ€™t need escaping in HTML\nand have no special meaning unless they're part of a tag or unquoted attribute value. See Mathias Bynensâ€™s\narticle (under \"semi-related fun fact\") for more details.\n\nBackticks are escaped because in IE < 9, they can break out of attribute values or HTML comments. See #59,\n#102, #108, and #133 of the HTML5 Security Cheatsheet for more details.\n\nWhen working with HTML you should always quote attribute values to reduce XSS vectors.",
        "params": [
          {
            "name": "string",
            "description": "The string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.escapeRegExp",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Escapes the RegExp special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\",\n\"{\", \"}\", and \"|\" in string.",
        "params": [
          {
            "name": "string",
            "description": "The string to escape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.kebabCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to kebab case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.lowerCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts `string`, as space separated words, to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.lowerFirst",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Uncapitalize<T>",
      "jsdoc": {
        "description": "Converts the first character of `string` to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.pad",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        },
        {
          "name": "chars",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads string on the left and right sides if itâ€™s shorter than length. Padding characters are truncated if\nthey canâ€™t be evenly divided by length.",
        "params": [
          {
            "name": "string",
            "description": "The string to pad."
          },
          {
            "name": "length",
            "description": "The padding length."
          },
          {
            "name": "chars",
            "description": "The string used as padding."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.parseInt",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": false
        },
        {
          "name": "radix",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Converts string to an integer of the specified radix. If radix is undefined or 0, a radix of 10 is used\nunless value is a hexadecimal, in which case a radix of 16 is used.\n\nNote: This method aligns with the ES5 implementation of parseInt.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          },
          {
            "name": "radix",
            "description": "The radix to interpret value by."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.snakeCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to snake case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.startCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts string to start case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.template",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "options",
          "type": "TemplateOptions",
          "optional": true
        }
      ],
      "returnType": "TemplateExecutor",
      "jsdoc": {
        "description": "Creates a compiled template function that can interpolate data properties in \"interpolate\" delimiters,\nHTML-escape interpolated data properties in \"escape\" delimiters, and execute JavaScript in \"evaluate\"\ndelimiters. Data properties may be accessed as free variables in the template. If a setting object is\nprovided it takes precedence over _.templateSettings values.\n\nNote: In the development build _.template utilizes\n[sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) for easier\ndebugging.\n\nFor more information on precompiling templates see\n[lodash's custom builds documentation](https://lodash.com/custom-builds).\n\nFor more information on Chrome extension sandboxes see\n[Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).",
        "params": [
          {
            "name": "string",
            "description": "The template string."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "The HTML \"escape\" delimiter."
          },
          {
            "description": "The \"evaluate\" delimiter."
          },
          {
            "description": "An object to import into the template as free variables."
          },
          {
            "description": "The \"interpolate\" delimiter."
          },
          {
            "description": "The sourceURL of the template's compiled source."
          },
          {
            "description": "The data object variable name."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toLower",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Lowercase<T>",
      "jsdoc": {
        "description": "Converts `string`, as a whole, to lower case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toUpper",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Uppercase<T>",
      "jsdoc": {
        "description": "Converts `string`, as a whole, to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.truncate",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "options",
          "type": "TruncateOptions",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Truncates string if itâ€™s longer than the given maximum string length. The last characters of the truncated\nstring are replaced with the omission string which defaults to \"â€¦\".",
        "params": [
          {
            "name": "string",
            "description": "The string to truncate."
          },
          {
            "name": "options",
            "description": "The options object or maximum string length."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.unescape",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "The inverse of _.escape; this method converts the HTML entities &amp;, &lt;, &gt;, &quot;, &#39;, and &#96;\nin string to their corresponding characters.\n\nNote: No other HTML entities are unescaped. To unescape additional HTML entities use a third-party library\nlike he.",
        "params": [
          {
            "name": "string",
            "description": "The string to unescape."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.upperCase",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts `string`, as space separated words, to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.upperFirst",
      "parameters": [
        {
          "name": "string",
          "type": "T",
          "optional": true
        }
      ],
      "returnType": "Capitalize<T>",
      "jsdoc": {
        "description": "Converts the first character of `string` to upper case.",
        "params": [
          {
            "name": "string",
            "description": "The string to convert."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.words",
      "parameters": [
        {
          "name": "string",
          "type": "string",
          "optional": true
        },
        {
          "name": "pattern",
          "type": "string | RegExp",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Splits `string` into an array of its words.",
        "params": [
          {
            "name": "string",
            "description": "The string to inspect."
          },
          {
            "name": "pattern",
            "description": "The pattern to match words."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.attempt",
      "parameters": [
        {
          "name": "func",
          "type": "(...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "Error | TResult",
      "jsdoc": {
        "description": "Attempts to invoke func, returning either the result or the caught error object. Any additional arguments\nare provided to func when itâ€™s invoked.",
        "params": [
          {
            "name": "func",
            "description": "The function to attempt."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.bindAll",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        },
        {
          "name": "methodNames",
          "type": "Many<string>[]",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Binds methods of an object to the object itself, overwriting the existing method. Method names may be\nspecified as individual arguments or as arrays of method names. If no method names are provided all\nenumerable function properties, own and inherited, of object are bound.\n\nNote: This method does not set the \"length\" property of bound functions.",
        "params": [
          {
            "name": "object",
            "description": "The object to bind and assign the bound methods to."
          },
          {
            "name": "methodNames",
            "description": "The object method names to bind, specified as individual method names or arrays of\nmethod names."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.cond",
      "parameters": [
        {
          "name": "pairs",
          "type": "CondPairNullary<R>[]",
          "optional": false
        }
      ],
      "returnType": "() => R",
      "jsdoc": {
        "description": "Creates a function that iterates over `pairs` and invokes the corresponding\nfunction of the first predicate to return truthy. The predicate-function\npairs are invoked with the `this` binding and arguments of the created\nfunction.",
        "params": [
          {
            "name": "pairs",
            "description": "The predicate-function pairs."
          }
        ],
        "returns": "Returns the new composite function.",
        "deprecated": false
      }
    },
    {
      "name": "_.conforms",
      "parameters": [
        {
          "name": "source",
          "type": "ConformsPredicateObject<T>",
          "optional": false
        }
      ],
      "returnType": "(value: T) => boolean",
      "jsdoc": {
        "description": "Creates a function that invokes the predicate properties of `source` with the corresponding\nproperty values of a given object, returning true if all predicates return truthy, else false.",
        "deprecated": false
      }
    },
    {
      "name": "_.constant",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "() => T",
      "jsdoc": {
        "description": "Creates a function that returns value.",
        "params": [
          {
            "name": "value",
            "description": "The value to return from the new function."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.defaultTo",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        },
        {
          "name": "defaultValue",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Checks `value` to determine whether a default value should be returned in\nits place. The `defaultValue` is returned if `value` is `NaN`, `null`,\nor `undefined`.",
        "params": [
          {
            "name": "value",
            "description": "The value to check."
          },
          {
            "name": "defaultValue",
            "description": "The default value."
          }
        ],
        "returns": "Returns the resolved value.",
        "deprecated": false
      }
    },
    {
      "name": "_.flow",
      "parameters": [
        {
          "name": "f1",
          "type": "(...args: A) => R1",
          "optional": false
        },
        {
          "name": "f2",
          "type": "(a: R1) => R2",
          "optional": false
        },
        {
          "name": "f3",
          "type": "(a: R2) => R3",
          "optional": false
        },
        {
          "name": "f4",
          "type": "(a: R3) => R4",
          "optional": false
        },
        {
          "name": "f5",
          "type": "(a: R4) => R5",
          "optional": false
        },
        {
          "name": "f6",
          "type": "(a: R5) => R6",
          "optional": false
        },
        {
          "name": "f7",
          "type": "(a: R6) => R7",
          "optional": false
        }
      ],
      "returnType": "(...args: A) => R7",
      "jsdoc": {
        "description": "Creates a function that returns the result of invoking the provided functions with the this binding of the\ncreated function, where each successive invocation is supplied the return value of the previous.",
        "params": [
          {
            "name": "funcs",
            "description": "Functions to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.flowRight",
      "parameters": [
        {
          "name": "f7",
          "type": "(a: R6) => R7",
          "optional": false
        },
        {
          "name": "f6",
          "type": "(a: R5) => R6",
          "optional": false
        },
        {
          "name": "f5",
          "type": "(a: R4) => R5",
          "optional": false
        },
        {
          "name": "f4",
          "type": "(a: R3) => R4",
          "optional": false
        },
        {
          "name": "f3",
          "type": "(a: R2) => R3",
          "optional": false
        },
        {
          "name": "f2",
          "type": "(a: R1) => R2",
          "optional": false
        },
        {
          "name": "f1",
          "type": "(...args: A) => R1",
          "optional": false
        }
      ],
      "returnType": "(...args: A) => R7",
      "jsdoc": {
        "description": "This method is like _.flow except that it creates a function that invokes the provided functions from right\nto left.",
        "params": [
          {
            "name": "funcs",
            "description": "Functions to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.identity",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "This method returns the first argument provided to it.",
        "params": [
          {
            "name": "value",
            "description": "Any value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.iteratee",
      "parameters": [
        {
          "name": "func",
          "type": "TFunction",
          "optional": false
        }
      ],
      "returnType": "TFunction",
      "jsdoc": {
        "description": "Creates a function that invokes `func` with the arguments of the created\nfunction. If `func` is a property name the created callback returns the\nproperty value for a given element. If `func` is an object the created\ncallback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.",
        "params": [
          {
            "name": "func",
            "description": "The value to convert to a callback."
          }
        ],
        "returns": "Returns the callback.",
        "deprecated": false
      }
    },
    {
      "name": "_.matches",
      "parameters": [
        {
          "name": "source",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(value: any) => boolean",
      "jsdoc": {
        "description": "Creates a function that performs a deep comparison between a given object and source, returning true if the\ngiven object has equivalent property values, else false.\n\nNote: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\nstrings. Objects are compared by their own, not inherited, enumerable properties. For comparing a single own\nor inherited property value see _.matchesProperty.",
        "params": [
          {
            "name": "source",
            "description": "The object of property values to match."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.matchesProperty",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "srcValue",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(value: any) => boolean",
      "jsdoc": {
        "description": "Creates a function that compares the property value of path on a given object to value.\n\nNote: This method supports comparing arrays, booleans, Date objects, numbers, Object objects, regexes, and\nstrings. Objects are compared by their own, not inherited, enumerable properties.",
        "params": [
          {
            "name": "path",
            "description": "The path of the property to get."
          },
          {
            "name": "srcValue",
            "description": "The value to match."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.method",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(object: any) => any",
      "jsdoc": {
        "description": "Creates a function that invokes the method at path on a given object. Any additional arguments are provided\nto the invoked method.",
        "params": [
          {
            "name": "path",
            "description": "The path of the method to invoke."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.methodOf",
      "parameters": [
        {
          "name": "object",
          "type": "object",
          "optional": false
        },
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "(path: PropertyPath) => any",
      "jsdoc": {
        "description": "The opposite of _.method; this method creates a function that invokes the method at a given path on object.\nAny additional arguments are provided to the invoked method.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          },
          {
            "name": "args",
            "description": "The arguments to invoke the method with."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.mixin",
      "parameters": [
        {
          "name": "object",
          "type": "TObject",
          "optional": false
        },
        {
          "name": "source",
          "type": "Dictionary<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "options",
          "type": "MixinOptions",
          "optional": true
        }
      ],
      "returnType": "TObject",
      "jsdoc": {
        "description": "Adds all own enumerable function properties of a source object to the destination object. If object is a\nfunction then methods are added to its prototype as well.\n\nNote: Use _.runInContext to create a pristine lodash function to avoid conflicts caused by modifying\nthe original.",
        "params": [
          {
            "name": "object",
            "description": "The destination object."
          },
          {
            "name": "source",
            "description": "The object of functions to add."
          },
          {
            "name": "options",
            "description": "The options object."
          },
          {
            "description": "Specify whether the functions added are chainable."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.noConflict",
      "parameters": [],
      "returnType": "LoDashStatic",
      "jsdoc": {
        "description": "Reverts the _ variable to its previous value and returns a reference to the lodash function.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.noop",
      "parameters": [
        {
          "name": "args",
          "type": "any[]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "A no-operation function that returns undefined regardless of the arguments it receives.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_.nthArg",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "(...args: any[]) => any",
      "jsdoc": {
        "description": "Creates a function that returns its nth argument.",
        "params": [
          {
            "name": "n",
            "description": "The index of the argument to return."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.over",
      "parameters": [
        {
          "name": "iteratees",
          "type": "Many<(...args: any[]) => TResult>[]",
          "optional": false
        }
      ],
      "returnType": "(...args: any[]) => TResult[]",
      "jsdoc": {
        "description": "Creates a function that invokes iteratees with the arguments provided to the created function and returns\ntheir results.",
        "params": [
          {
            "name": "iteratees",
            "description": "The iteratees to invoke."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.overEvery",
      "parameters": [
        {
          "name": "predicates",
          "type": "[(arg: T) => arg is Result1, (arg: T) => arg is Result2]",
          "optional": false
        }
      ],
      "returnType": "(arg: T) => arg is Result1 & Result2",
      "jsdoc": {
        "description": "Creates a function that checks if all of the predicates return truthy when invoked with the arguments\nprovided to the created function.",
        "params": [
          {
            "name": "predicates",
            "description": "The predicates to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.overSome",
      "parameters": [
        {
          "name": "predicates",
          "type": "[(arg: T) => arg is Result1, (arg: T) => arg is Result2]",
          "optional": false
        }
      ],
      "returnType": "(arg: T) => arg is Result1 | Result2",
      "jsdoc": {
        "description": "Creates a function that checks if any of the predicates return truthy when invoked with the arguments\nprovided to the created function.",
        "params": [
          {
            "name": "predicates",
            "description": "The predicates to check."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.property",
      "parameters": [
        {
          "name": "path",
          "type": "PropertyPath",
          "optional": false
        }
      ],
      "returnType": "(obj: TObj) => TResult",
      "jsdoc": {
        "description": "Creates a function that returns the property value at path on a given object.",
        "params": [
          {
            "name": "path",
            "description": "The path of the property to get."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.propertyOf",
      "parameters": [
        {
          "name": "object",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "(path: PropertyPath) => any",
      "jsdoc": {
        "description": "The opposite of _.property; this method creates a function that returns the property value at a given path\non object.",
        "params": [
          {
            "name": "object",
            "description": "The object to query."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.range",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end.\nIf end is not specified itâ€™s set to start with start then set to 0. If end is less than start a zero-length\nrange is created unless a negative step is specified.",
        "params": [
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          },
          {
            "name": "step",
            "description": "The value to increment or decrement by."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.rangeRight",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        },
        {
          "name": "step",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number[]",
      "jsdoc": {
        "description": "This method is like `_.range` except that it populates values in\ndescending order.",
        "params": [
          {
            "name": "start",
            "description": "The start of the range."
          },
          {
            "name": "end",
            "description": "The end of the range."
          },
          {
            "name": "step",
            "description": "The value to increment or decrement by."
          }
        ],
        "returns": "Returns the new array of numbers.",
        "deprecated": false
      }
    },
    {
      "name": "_.runInContext",
      "parameters": [
        {
          "name": "context",
          "type": "object",
          "optional": true
        }
      ],
      "returnType": "LoDashStatic",
      "jsdoc": {
        "description": "Create a new pristine lodash function using the given context object.",
        "params": [
          {
            "name": "context",
            "description": "The context object."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.stubArray",
      "parameters": [],
      "returnType": "any[]",
      "jsdoc": {
        "description": "This method returns a new empty array.",
        "params": [],
        "returns": "Returns the new empty array.",
        "deprecated": false
      }
    },
    {
      "name": "_.stubFalse",
      "parameters": [],
      "returnType": "false",
      "jsdoc": {
        "description": "This method returns `false`.",
        "params": [],
        "returns": "Returns `false`.",
        "deprecated": false
      }
    },
    {
      "name": "_.stubObject",
      "parameters": [],
      "returnType": "any",
      "jsdoc": {
        "description": "This method returns a new empty object.",
        "params": [],
        "returns": "Returns the new empty object.",
        "deprecated": false
      }
    },
    {
      "name": "_.stubString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "This method returns an empty string.",
        "params": [],
        "returns": "Returns the empty string.",
        "deprecated": false
      }
    },
    {
      "name": "_.stubTrue",
      "parameters": [],
      "returnType": "true",
      "jsdoc": {
        "description": "This method returns `true`.",
        "params": [],
        "returns": "Returns `true`.",
        "deprecated": false
      }
    },
    {
      "name": "_.times",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "(num: number) => TResult",
          "optional": false
        }
      ],
      "returnType": "TResult[]",
      "jsdoc": {
        "description": "Invokes the iteratee function n times, returning an array of the results of each invocation. The iteratee\nis invoked with one argument; (index).",
        "params": [
          {
            "name": "n",
            "description": "The number of times to invoke iteratee."
          },
          {
            "name": "iteratee",
            "description": "The function invoked per iteration."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "_.toPath",
      "parameters": [
        {
          "name": "value",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Converts `value` to a property path array.",
        "params": [
          {
            "name": "value",
            "description": "The value to convert."
          }
        ],
        "returns": "Returns the new property path array.",
        "deprecated": false
      }
    },
    {
      "name": "_.uniqueId",
      "parameters": [
        {
          "name": "prefix",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Generates a unique ID. If prefix is provided the ID is appended to it.",
        "params": [
          {
            "name": "prefix",
            "description": "The value to prefix the ID with."
          }
        ],
        "deprecated": false
      }
    }
  ],
  "enums": [],
  "types": [
    {
      "name": "LoDashStatic",
      "type": "LoDashStatic",
      "properties": [
        {
          "name": "VERSION",
          "type": "string",
          "optional": false
        },
        {
          "name": "templateSettings",
          "type": "TemplateSettings",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "<T>(array: List<T>, size?: number) => T[][]",
          "optional": false
        },
        {
          "name": "compact",
          "type": "<T>(array: List<T | Falsey>) => T[]",
          "optional": false
        },
        {
          "name": "concat",
          "type": "<T>(...values: Many<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "difference",
          "type": "<T>(array: List<T>, ...values: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "differenceBy",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, values3: List<...>, iteratee: ValueIteratee<...>)...",
          "optional": false
        },
        {
          "name": "differenceWith",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
          "optional": false
        },
        {
          "name": "drop",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "dropRight",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "dropRightWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "dropWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "fill",
          "type": "{ <T>(array: any[], value: T): T[]; <T>(array: List<any>, value: T): List<T>; <T, U>(array: U[], value: T, start?: number, end?: number): (T | U)[]; <T, U>(array: List<U>, value: T, start?: number, end?: number): List<...>; }",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "<T>(array: List<Many<T>>) => T[]",
          "optional": false
        },
        {
          "name": "flattenDeep",
          "type": "<T>(array: ListOfRecursiveArraysOrValues<T>) => Flat<T>[]",
          "optional": false
        },
        {
          "name": "flattenDepth",
          "type": "<T>(array: ListOfRecursiveArraysOrValues<T>, depth?: number) => T[]",
          "optional": false
        },
        {
          "name": "fromPairs",
          "type": "{ <T>(pairs: List<[PropertyName, T]>): Dictionary<T>; (pairs: List<any[]>): Dictionary<any>; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "<T>(array: List<T>, value: T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "initial",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "intersectionBy",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | ValueIteratee<...>)[]): T...",
          "optional": false
        },
        {
          "name": "intersectionWith",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
          "optional": false
        },
        {
          "name": "join",
          "type": "(array: List<any>, separator?: string) => string",
          "optional": false
        },
        {
          "name": "last",
          "type": "<T>(array: List<T>) => T",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "<T>(array: List<T>, value: T, fromIndex?: number | true) => number",
          "optional": false
        },
        {
          "name": "nth",
          "type": "<T>(array: List<T>, n?: number) => T",
          "optional": false
        },
        {
          "name": "pull",
          "type": "{ <T>(array: T[], ...values: T[]): T[]; <T>(array: List<T>, ...values: T[]): List<T>; }",
          "optional": false
        },
        {
          "name": "pullAll",
          "type": "{ <T>(array: T[], values?: List<T>): T[]; <T>(array: List<T>, values?: List<T>): List<T>; }",
          "optional": false
        },
        {
          "name": "pullAllBy",
          "type": "{ <T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, iteratee: ValueIteratee<...>): List<...>; }",
          "optional": false
        },
        {
          "name": "pullAllWith",
          "type": "{ <T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[]; <T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, comparator: Comparator2<...>): List<...>; }",
          "optional": false
        },
        {
          "name": "pullAt",
          "type": "{ <T>(array: T[], ...indexes: Many<number>[]): T[]; <T>(array: List<T>, ...indexes: Many<number>[]): List<T>; }",
          "optional": false
        },
        {
          "name": "remove",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "<TList extends List<any>>(array: TList) => TList",
          "optional": false
        },
        {
          "name": "slice",
          "type": "<T>(array: List<T>, start?: number, end?: number) => T[]",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "{ <T>(array: List<T>, value: T): number; <T>(array: List<T>, value: T): number; }",
          "optional": false
        },
        {
          "name": "sortedIndexBy",
          "type": "<T>(array: List<T>, value: T, iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedIndexOf",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndex",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexBy",
          "type": "<T>(array: List<T>, value: T, iteratee: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexOf",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedUniq",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "sortedUniqBy",
          "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "tail",
          "type": "{ <T extends unknown[]>(array: readonly [unknown, ...T]): T; <T>(array: List<T>): T[]; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "takeRight",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "takeRightWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "takeWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "union",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "unionBy",
          "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee?: ValueIteratee<...>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>,...",
          "optional": false
        },
        {
          "name": "unionWith",
          "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "uniqBy",
          "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "uniqWith",
          "type": "<T>(array: List<T>, comparator?: Comparator<T>) => T[]",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "<T>(array: T[][] | List<List<T>>) => T[][]",
          "optional": false
        },
        {
          "name": "unzipWith",
          "type": "{ <T, TResult>(array: List<List<T>>, iteratee: (...values: T[]) => TResult): TResult[]; <T>(array: List<List<T>>): T[][]; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "<T>(array: List<T>, ...values: T[]) => T[]",
          "optional": false
        },
        {
          "name": "xor",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "xorBy",
          "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...iteratee: (ValueIteratee<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "xorWith",
          "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ <T1, T2>(arrays1: List<T1>, arrays2: List<T2>): [T1, T2][]; <T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): [...][]; <T1, T2, T3, T4>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>): [...][]; <T1, T2, T3, T4, T5>(arrays1: List<...>, arrays2: List<...>, arrays3...",
          "optional": false
        },
        {
          "name": "zipObject",
          "type": "{ <T>(props: List<PropertyName>, values: List<T>): Dictionary<T>; (props?: List<PropertyName>): Dictionary<undefined>; }",
          "optional": false
        },
        {
          "name": "zipObjectDeep",
          "type": "(paths?: List<PropertyPath>, values?: List<any>) => object",
          "optional": false
        },
        {
          "name": "zipWith",
          "type": "{ <T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[]; <T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[]; <T1, T2, T3, TResult>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee: (value1: T1, value2: T2, value3:...",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<number>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "each",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "every",
          "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>): S[]; <T>(collection: List<...>, predicate?: ListIterateeCustom<...>): T[]; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<....",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <T>(collection: Dictionary<Many<T>> | NumericDictionary<Many<T>>): T[]; (collection: object): any[]; <T, TResult>(collection: List<T>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, iteratee: string): any[]; (colle...",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, i...",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>, depth?: number): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>, depth?: number): T...",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<T[]>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "includes",
          "type": "<T>(collection: Dictionary<T> | NumericDictionary<T>, target: T, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (collection: object, methodName: string, ...args: any[]): any[]; <TResult>(collection: object, method: (...args: any[]) => TResult, ...args: any[]): TResult[]; }",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>; <T extends object>(collection: T, iteratee?: ValueIterateeCustom<...>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <T extends readonly [unknown, ...unknown[]], TResult>(collection: T, iteratee: TupleIterator<T, TResult>): { [K in keyof T]: TResult; }; <T, TResult>(collection: T[], iteratee: ArrayIterator<...>): TResult[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T>(collection: Dictionary<.....",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "{ <T>(collection: List<T>, iteratees?: Many<ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">): T[]; <T>(collection: List<T>, iteratees?: Many<...>, orders?: Many<...>): T[]; <T extends object>(collection: T, iteratees?: Many<...>, orders?: Many<...>): T[keyof T][]; <T extends object>(collection: T,...",
          "optional": false
        },
        {
          "name": "partition",
          "type": "{ <T, U extends T>(collection: List<T>, callback: ValueIteratorTypeGuard<T, U>): [U[], Exclude<T, U>[]]; <T>(collection: List<T>, callback: ValueIteratee<...>): [...]; <T extends object>(collection: T, callback: ValueIteratee<...>): [...]; }",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
          "optional": false
        },
        {
          "name": "reject",
          "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): T[]; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<...>): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ <T>(collection: readonly [T, ...T[]]): T; <T>(collection: Dictionary<T> | NumericDictionary<T>): T; <T extends object>(collection: T): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "{ <T>(collection: Dictionary<T> | NumericDictionary<T>, n?: number): T[]; <T extends object>(collection: T, n?: number): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "{ <T>(collection: List<T>): T[]; <T extends object>(collection: T): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "(collection: string | object) => number",
          "optional": false
        },
        {
          "name": "some",
          "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "{ <T>(collection: List<T>, ...iteratees: Many<ListIteratee<T>>[]): T[]; <T extends object>(collection: T, ...iteratees: Many<ObjectIteratee<T>>[]): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "after",
          "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
          "optional": false
        },
        {
          "name": "ary",
          "type": "(func: (...args: any[]) => any, n?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "before",
          "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
          "optional": false
        },
        {
          "name": "bind",
          "type": "FunctionBind",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "FunctionBindKey",
          "optional": false
        },
        {
          "name": "curry",
          "type": "Curry",
          "optional": false
        },
        {
          "name": "curryRight",
          "type": "CurryRight",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "{ <T extends (...args: any) => any>(func: T, wait: number, options: DebounceSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<...>; }",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(func: (...args: any[]) => any, ...args: any[]) => number",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(func: (...args: any[]) => any, wait: number, ...args: any[]) => number",
          "optional": false
        },
        {
          "name": "flip",
          "type": "<T extends (...args: any) => any>(func: T) => T",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "{ <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction; Cache: MapCacheConstructor; }",
          "optional": false
        },
        {
          "name": "negate",
          "type": "<T extends any[]>(predicate: (...args: T) => boolean) => (...args: T) => boolean",
          "optional": false
        },
        {
          "name": "once",
          "type": "<T extends (...args: any) => any>(func: T) => T",
          "optional": false
        },
        {
          "name": "overArgs",
          "type": "(func: (...args: any[]) => any, ...transforms: Many<(...args: any[]) => any>[]) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "partial",
          "type": "Partial",
          "optional": false
        },
        {
          "name": "partialRight",
          "type": "PartialRight",
          "optional": false
        },
        {
          "name": "rearg",
          "type": "(func: (...args: any[]) => any, ...indexes: Many<number>[]) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(func: (...args: any[]) => any, start?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "spread",
          "type": "<TResult>(func: (...args: any[]) => TResult, start?: number) => (...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "{ <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<...>; }",
          "optional": false
        },
        {
          "name": "unary",
          "type": "<T, TResult>(func: (arg1: T, ...args: any[]) => TResult) => (arg1: T) => TResult",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult) => (...args: TArgs[]) => TResult",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "<T>(value?: Many<T>) => T[]",
          "optional": false
        },
        {
          "name": "clone",
          "type": "<T>(value: T) => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "<T>(value: T) => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ <T>(value: T, customizer: CloneDeepWithCustomizer<T>): any; <T>(value: T): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult; <T, TResult>(value: T, customizer: CloneWithCustomizer<...>): T | TResult; <T>(value: T): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "<T>(object: T, source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "(value?: any) => value is IArguments",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "{ (value?: any): value is any[]; <T>(value?: any): value is any[]; }",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "(value?: any) => value is ArrayBuffer",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "{ <T extends { __lodashAnyHack: any; }>(t: T): boolean; (value: (...args: any[]) => any): value is never; (value: any): value is { length: number; }; }",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "{ <T extends { __lodashAnyHack: any; }>(value: T): boolean; (value: string | number | boolean | Function | ((...args: any[]) => any)): value is never; (value: any): value is object & { length: number; }; }",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "(value?: any) => value is boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "(value?: any) => value is Date",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "{ <T extends { __trapAny: any; }>(value?: T): boolean; (value: string): value is \"\"; (value: List<any> | Map<any, any> | Set<any>): boolean; (value: object): boolean; <T extends object>(value: T): value is EmptyObjectOf<...>; (value?: any): boolean; }",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(value: any, other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "(value: any) => value is Error",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "(value: any) => value is (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "(value?: any) => value is Map<any, any>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(object: object, source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(object: object, source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "(value: any) => value is (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "(value: any) => value is null",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "(value: any) => value is null",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "(value?: any) => value is number",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "(value?: any) => value is object",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "(value?: any) => value is RegExp",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "(value: any) => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "(value?: any) => value is Set<any>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "(value?: any) => value is string",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "(value: any) => value is symbol",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "(value: any) => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "(value: any) => value is undefined",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "(value?: any) => value is WeakMap<object, any>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "(value?: any) => value is WeakSet<object>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "{ <T>(value: Dictionary<T> | NumericDictionary<T>): T[]; <T>(value: T): T[keyof T][]; (): any[]; }",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "(value?: any) => any",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toString",
          "type": "(value: any) => string",
          "optional": false
        },
        {
          "name": "add",
          "type": "(augend: number, addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(dividend: number, divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "max",
          "type": "<T>(collection: List<T>) => T",
          "optional": false
        },
        {
          "name": "maxBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "mean",
          "type": "(collection: List<any>) => number",
          "optional": false
        },
        {
          "name": "meanBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "min",
          "type": "<T>(collection: List<T>) => T",
          "optional": false
        },
        {
          "name": "minBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplier: number, multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(minuend: number, subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "(collection: List<any>) => number",
          "optional": false
        },
        {
          "name": "sumBy",
          "type": "<T>(collection: List<T>, iteratee?: string | ((value: T) => number)) => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (number: number, lower: number, upper: number): number; (number: number, upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(n: number, start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; (min: number, max: number, floating?: boolean): number; (min: number, index: string | number, guard: object): number; }",
          "optional": false
        },
        {
          "name": "assign",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "assignIn",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "assignInWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "assignWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "at",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, ...props: PropertyPath[]): T[]; <T extends object>(object: T, ...props: Many<keyof T>[]): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "create",
          "type": "<T extends object, U extends object>(prototype: T, properties?: U) => T & U",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<...>; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullabl...",
          "optional": false
        },
        {
          "name": "defaultsDeep",
          "type": "(object: any, ...sources: any[]) => any",
          "optional": false
        },
        {
          "name": "entries",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "extend",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "extendWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "functions",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "<T extends {}>(object: any) => string[]",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [...]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject, path: TKey | [...], de...",
          "optional": false
        },
        {
          "name": "has",
          "type": "{ <T, K extends PropertyName>(object: T, path: K): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown; } & { ...; }; <T>(object: T, path: PropertyPath): boolean; }",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "<T>(object: T, path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "(object: object) => Dictionary<string>",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, interatee?: ValueIteratee<T>): Dictionary<string[]>; <T extends object>(object: T, interatee?: ValueIteratee<...>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(object: any, path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(object?: any) => string[]",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "(object?: any) => string[]",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "{ <T>(object: List<T>, iteratee?: ListIteratee<T>): Dictionary<T>; <T extends object>(object: T, iteratee?: ObjectIteratee<T>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(obj: string, callback: StringIterator<TResult>): NumericDictionary<TResult>; <T, TResult>(array: T[], callback: ArrayIterator<T, TResult>): NumericDictionary<...>; <T extends object, TResult>(obj: T, callback: ObjectIterator<...>): { [P in keyof T]: TResult; }; <T>(obj: Dictionary<...> | NumericDictionar...",
          "optional": false
        },
        {
          "name": "merge",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "mergeWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, objec...",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <T extends object, K extends PropertyName[]>(object: T, ...paths: K): Pick<T, Exclude<keyof T, K[number]>>; <T extends object, K extends keyof T>(object: T, ...paths: Many<K>[]): Omit<...>; <T extends object>(object: T, ...paths: Many<...>[]): Partial<...>; }",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "{ <T>(object: Dictionary<T>, predicate?: ValueKeyIteratee<T>): Dictionary<T>; <T>(object: NumericDictionary<T>, predicate?: ValueKeyIteratee<...>): NumericDictionary<...>; <T extends object>(object: T, predicate: ValueKeyIteratee<...>): Partial<...>; }",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <T extends object, U extends keyof T>(object: T, ...props: Many<U>[]): Pick<T, U>; <T>(object: T, ...props: Many<PropertyPath>[]): Partial<T>; }",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <T, S extends T>(object: Dictionary<T>, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>; <T, S extends T>(object: NumericDictionary<T>, predicate: ValueKeyIterateeTypeGuard<...>): NumericDictionary<...>; <T>(object: Dictionary<...>, predicate?: ValueKeyIteratee<...>): Dictionary<...>; <T>(object: Numeri...",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ <T extends object>(object: T, path: PropertyPath, value: any): T; <TResult>(object: object, path: PropertyPath, value: any): TResult; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ <T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): TResult; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <T, TResult>(object: readonly T[], iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult; <T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): TResult; <T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<...>, accumula...",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(object: any, path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "update",
          "type": "(object: object, path: PropertyPath, updater: (value: any) => any) => any",
          "optional": false
        },
        {
          "name": "updateWith",
          "type": "{ <T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): TResult; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; (object: any): any[]; }",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "chain",
          "type": "{ <TrapAny extends { __lodashAnyHack: any; }>(value: TrapAny): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <T extends null | undefined>(value: T): PrimitiveChain<...>; <T extends string>(value: T): StringChain<...>; (value: string): StringNullableChain; <T e...",
          "optional": false
        },
        {
          "name": "tap",
          "type": "<T>(value: T, interceptor: (value: T) => void) => T",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<T, TResult>(value: T, interceptor: (value: T) => TResult) => TResult",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "<T extends string>(string?: T) => string extends T ? string : Capitalize<Lowercase<T>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(string?: string, target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "<T extends string = string>(string?: T) => Uncapitalize<T>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(string: string, radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(string?: string, n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (string: string, pattern: string | RegExp, replacement: string | ReplaceFunction): string; (pattern: string | RegExp, replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "{ (string: string, separator?: string | RegExp, limit?: number): string[]; (string: string, index: string | number, guard: object): string[]; }",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(string?: string, target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(string?: string, options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "<T extends string = string>(string?: T) => Lowercase<T>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "<T extends string = string>(string?: T) => Uppercase<T>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(string?: string, options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "<T extends string = string>(string?: T) => Capitalize<T>",
          "optional": false
        },
        {
          "name": "words",
          "type": "{ (string?: string, pattern?: string | RegExp): string[]; (string: string, index: string | number, guard: object): string[]; }",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(func: (...args: any[]) => TResult, ...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "<T>(object: T, ...methodNames: Many<string>[]) => T",
          "optional": false
        },
        {
          "name": "cond",
          "type": "{ <R>(pairs: CondPairNullary<R>[]): () => R; <T, R>(pairs: CondPairUnary<T, R>[]): (Target: T) => R; }",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "<T>(source: ConformsPredicateObject<T>) => (value: T) => boolean",
          "optional": false
        },
        {
          "name": "constant",
          "type": "<T>(value: T) => () => T",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ <T>(value: T, defaultValue: T): T; <T, TDefault>(value: T, defaultValue: TDefault): T | TDefault; }",
          "optional": false
        },
        {
          "name": "flow",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4...",
          "optional": false
        },
        {
          "name": "flowRight",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2)...",
          "optional": false
        },
        {
          "name": "identity",
          "type": "{ <T>(value: T): T; (): undefined; }",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "{ <TFunction extends (...args: any[]) => any>(func: TFunction): TFunction; (func: string | number | symbol | object): (...args: any[]) => any; }",
          "optional": false
        },
        {
          "name": "matches",
          "type": "{ <T>(source: T): (value: any) => boolean; <T, V>(source: T): (value: V) => boolean; }",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <T>(path: PropertyPath, srcValue: T): (value: any) => boolean; <T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(path: PropertyPath, ...args: any[]) => (object: any) => any",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(object: object, ...args: any[]) => (path: PropertyPath) => any",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ <TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject; <TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashStatic; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "(n?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => (...args: any[]) => TResult[]",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 & Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 | Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>(path: PropertyPath) => (obj: TObj) => TResult",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "<T extends {}>(object: T) => (path: PropertyPath) => any",
          "optional": false
        },
        {
          "name": "range",
          "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "(context?: object) => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(n: number, iteratee: (num: number) => TResult): TResult[]; (n: number): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "(value: any) => string[]",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "(prefix?: string) => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Omit",
      "type": "Omit<T, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PartialObject",
      "type": "Partial<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Many",
      "type": "Many<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ImpChain",
      "type": "ImpChain<T>",
      "properties": [
        {
          "name": "castArray",
          "type": "((() => Collection<any>) & (() => Collection<any>) & (() => Collection<any>) & (() => Collection<any>) & (() => Collection<string>)) | ... 4 more ... | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "chain",
          "type": "((() => CollectionChain<any>) & (() => FunctionChain<any>) & (() => ObjectChain<any>) & (() => PrimitiveChain<any>) & (<T extends string>() => StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "({ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; } & { (methodName: string, ...args: any[]): Collection<...>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<...>; } & { ...; }) | ... 4 more ... |...",
          "optional": false
        },
        {
          "name": "size",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "now",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(((thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => Function<...>)) | ... 4 more ... | ((thisArg: any, ...partials: any[]) => Function<...>)",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(((key: string, ...partials: any[]) => Function<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => Function<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => Function<...>)) | ... 4 more ... | ((key: string, ...partials: any[]) => Function<...>)",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(((...args: any[]) => Primitive<number>) & ((...args: any[]) => Primitive<number>) & ((...args: any[]) => Primitive<number>)) | ((...args: any[]) => Primitive<number>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive...",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(((wait: number, ...args: any[]) => Primitive<number>) & ((wait: number, ...args: any[]) => Primitive<number>) & ((wait: number, ...args: any[]) => Primitive<number>)) | ... 4 more ... | ((wait: number, ...args: any[]) => Primitive<...>)",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "((<TArgs, TResult>(wrapper: (value: any[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>) & (<TArgs, TResult>(wrapper: (value: any, ...args: TArgs[]) => TResult) => Function<...>) & (<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => Function<...>)) | ... 4 more ......",
          "optional": false
        },
        {
          "name": "clone",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "({ (customizer: CloneDeepWithCustomizer<any[]>): any; (): any[]; } & { (customizer: CloneDeepWithCustomizer<any>): any; (): any; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "({ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<any[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<any[], TResult>): any[] | TResult; (): any[]; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(((source: any[]) => boolean) & ((source: ConformsPredicateObject<any>) => boolean) & ((source: string) => boolean)) | ((source: ConformsPredicateObject<T>) => boolean) | ((source: ConformsPredicateObject<...>) => boolean) | ((source: any[]) => boolean) | ((source: ConformsPredicateObject<...>) => boolean) | ((sourc...",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(((other: any, customizer?: IsEqualCustomizer) => boolean) & ((other: any, customizer?: IsEqualCustomizer) => boolean) & ((other: any, customizer?: IsEqualCustomizer) => boolean)) | ... 4 more ... | ((other: any, customizer?: IsEqualCustomizer) => boolean)",
          "optional": false
        },
        {
          "name": "isError",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(((source: object) => boolean) & ((source: object) => boolean) & ((source: object) => boolean)) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean)",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(((source: object, customizer: isMatchWithCustomizer) => boolean) & ((source: object, customizer: isMatchWithCustomizer) => boolean) & ((source: object, customizer: isMatchWithCustomizer) => boolean)) | ... 4 more ... | ((source: object, customizer: isMatchWithCustomizer) => boolean)",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "((() => this is LoDashImplicitWrapper<object>) & (() => this is LoDashImplicitWrapper<object>) & (() => this is LoDashImplicitWrapper<object>)) | ... 4 more ... | (() => this is LoDashImplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isString",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "((() => Object<any>) & (() => Object<any>) & (() => Object<any>)) | (() => Object<any>) | (() => Object<any>) | (() => Object<any>) | (() => Object<any>) | (() => Object<...>)",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "add",
          "type": "(((addend: number) => number) & ((addend: number) => number) & ((addend: number) => number)) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number)",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(((divisor: number) => number) & ((divisor: number) => number) & ((divisor: number) => number)) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number)",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
          "optional": false
        },
        {
          "name": "mean",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(((multiplicand: number) => number) & ((multiplicand: number) => number) & ((multiplicand: number) => number)) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number)",
          "optional": false
        },
        {
          "name": "round",
          "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(((subtrahend: number) => number) & ((subtrahend: number) => number) & ((subtrahend: number) => number)) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number)",
          "optional": false
        },
        {
          "name": "sum",
          "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "({ (lower: number, upper: number): number; (upper: number): number; } & { (lower: number, upper: number): number; (upper: number): number; } & { (lower: number, upper: number): number; (upper: number): number; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(((start: number, end?: number) => boolean) & ((start: number, end?: number) => boolean) & ((start: number, end?: number) => boolean)) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ...",
          "optional": false
        },
        {
          "name": "random",
          "type": "({ (floating?: boolean): number; (max: number, floating?: boolean): number; } & { (floating?: boolean): number; (max: number, floating?: boolean): number; } & { (floating?: boolean): number; (max: number, floating?: boolean): number; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>)) | ... 4 more ... | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>)) | ... 4 more ... | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(((predicate?: ObjectIteratee<any[]>) => string) & ((predicate?: ObjectIteratee<any>) => string) & ((predicate?: ObjectIteratee<string>) => string)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => string)",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(((predicate?: ObjectIteratee<any[]>) => string) & ((predicate?: ObjectIteratee<any>) => string) & ((predicate?: ObjectIteratee<string>) => string)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => string)",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
          "optional": false
        },
        {
          "name": "functions",
          "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "has",
          "type": "(((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean)) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean)",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean)) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean)",
          "optional": false
        },
        {
          "name": "invert",
          "type": "((() => Object<Dictionary<string>>) & (() => Object<Dictionary<string>>) & (() => Object<Dictionary<string>>)) | (() => Object<Dictionary<...>>) | (() => Object<...>) | (() => Object<...>) | (() => Object<...>) | (() => Object<...>)",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(((path: PropertyPath, ...args: any[]) => any) & ((path: PropertyPath, ...args: any[]) => any) & ((path: PropertyPath, ...args: any[]) => any)) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...ar...",
          "optional": false
        },
        {
          "name": "keys",
          "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "result",
          "type": "((<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult)) | ... 4 more ....",
          "optional": false
        },
        {
          "name": "set",
          "type": "({ (path: PropertyPath, value: any): Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "({ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<any[]>): Collection<any> & Function<any> & Object<...> & Primitive<...> & String<...>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, string]>)) | (() => Collection<[string, T extends Dictionary<...> ? U : T extends NumericDictionary<...> ? V : any]>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<....",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, string]>)) | (() => Collection<[string, T extends Dictionary<...> ? U : T extends NumericDictionary<...> ? V : any]>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<....",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(((path: PropertyPath) => Primitive<boolean>) & ((path: PropertyPath) => Primitive<boolean>) & ((path: PropertyPath) => Primitive<...>)) | ... 4 more ... | ((path: PropertyPath) => Primitive<...>)",
          "optional": false
        },
        {
          "name": "update",
          "type": "(((path: PropertyPath, updater: (value: any) => any) => Object<any>) & ((path: PropertyPath, updater: (value: any) => any) => Object<any>) & ((path: PropertyPath, updater: (value: any) => any) => Object<...>)) | ... 4 more ... | ((path: PropertyPath, updater: (value: any) => any) => Object<...>)",
          "optional": false
        },
        {
          "name": "commit",
          "type": "((() => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & (() => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & (() => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | (() => Primitive<...>)",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(((value: unknown) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((value: unknown) => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & ((value: unknown) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ((value: unknown) => P...",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "((() => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & (() => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & (() => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | (() => Primitive<...>)",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "value",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(((interceptor: (value: any[]) => void) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((interceptor: (value: any) => void) => Collection<...> & ... 3 more ... & String<...>) & ((interceptor: (value: string) => void) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 m...",
          "optional": false
        },
        {
          "name": "thru",
          "type": "((<TResult>(interceptor: (value: any[]) => TResult) => ImpChain<TResult>) & (<TResult>(interceptor: (value: any) => TResult) => ImpChain<TResult>) & (<TResult>(interceptor: (value: string) => TResult) => ImpChain<...>)) | ... 4 more ... | (<TResult>(interceptor: (value: T) => TResult) => ImpChain<...>)",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "((() => never) & (() => string) & (() => string)) | (() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>) | (() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? string & T : never>>) | (() => never) | (() => string extends T ? T & string : Capitalize<Lo...",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean)) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((t...",
          "optional": false
        },
        {
          "name": "escape",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "((() => string) & (() => string) & (() => Uncapitalize<string>)) | (() => T extends string ? Uncapitalize<T> : string) | (() => T extends string ? Uncapitalize<string & T> : string) | (() => string) | (() => T extends string ? Uncapitalize<string & T> : string) | (() => T extends string ? Uncapitalize<T> : string)",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(((radix?: number) => number) & ((radix?: number) => number) & ((radix?: number) => number)) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number)",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(((n?: number) => string) & ((n?: number) => string) & ((n?: number) => string)) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string)",
          "optional": false
        },
        {
          "name": "replace",
          "type": "({ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "split",
          "type": "(((separator?: string | RegExp, limit?: number) => Collection<string>) & ((separator?: string | RegExp, limit?: number) => Collection<string>) & ((separator?: string | RegExp, limit?: number) => Collection<...>)) | ... 4 more ... | ((separator?: string | RegExp, limit?: number) => Collection<...>)",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean)) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((t...",
          "optional": false
        },
        {
          "name": "template",
          "type": "(((options?: TemplateOptions) => TemplateExecutor) & ((options?: TemplateOptions) => TemplateExecutor) & ((options?: TemplateOptions) => TemplateExecutor)) | ... 4 more ... | ((options?: TemplateOptions) => TemplateExecutor)",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "((() => string) & (() => string) & (() => Lowercase<string>)) | (() => T extends string ? Lowercase<T> : string) | (() => T extends string ? Lowercase<string & T> : string) | (() => string) | (() => T extends string ? Lowercase<string & T> : string) | (() => T extends string ? Lowercase<T> : string)",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "((() => string) & (() => string) & (() => Uppercase<string>)) | (() => T extends string ? Uppercase<T> : string) | (() => T extends string ? Uppercase<string & T> : string) | (() => string) | (() => T extends string ? Uppercase<string & T> : string) | (() => T extends string ? Uppercase<T> : string)",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(((options?: TruncateOptions) => string) & ((options?: TruncateOptions) => string) & ((options?: TruncateOptions) => string)) | ... 4 more ... | ((options?: TruncateOptions) => string)",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "((() => string) & (() => string) & (() => Capitalize<string>)) | (() => T extends string ? Capitalize<T> : string) | (() => T extends string ? Capitalize<string & T> : string) | (() => string) | (() => T extends string ? Capitalize<string & T> : string) | (() => T extends string ? Capitalize<T> : string)",
          "optional": false
        },
        {
          "name": "words",
          "type": "(((pattern?: string | RegExp) => Collection<string>) & ((pattern?: string | RegExp) => Collection<string>) & ((pattern?: string | RegExp) => Collection<...>)) | ... 4 more ... | ((pattern?: string | RegExp) => Collection<...>)",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "((<TResult>(...args: any[]) => Error | TResult) & (<TResult>(...args: any[]) => Error | TResult) & (<TResult>(...args: any[]) => Error | TResult)) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: a...",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(((...methodNames: Many<string>[]) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((...methodNames: Many<...>[]) => Collection<...> & ... 3 more ... & String<...>) & ((...methodNames: Many<...>[]) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ((...metho...",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "((() => Function<(value: any[]) => boolean>) & (() => Function<(value: ConformsPredicateObject<any>) => boolean>) & (() => Function<(value: string) => boolean>)) | ... 4 more ... | (() => Function<...>)",
          "optional": false
        },
        {
          "name": "constant",
          "type": "((() => Function<() => any[]>) & (() => Function<() => any>) & (() => Function<() => string>)) | (() => Function<() => T>) | (() => Function<() => T>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>)",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "({ (defaultValue: any[]): any[]; <TDefault>(defaultValue: TDefault): any[] | TDefault; } & { (defaultValue: any): any; <TDefault>(defaultValue: TDefault): any; } & { (defaultValue: string): string; <TDefault>(defaultValue: TDefault): string | TDefault; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "matches",
          "type": "((<V>() => Function<(value: V) => boolean>) & (<V>() => Function<(value: V) => boolean>) & (<V>() => Function<(value: V) => boolean>)) | (<V>() => Function<(value: V) => boolean>) | (<V>() => Function<...>) | (<V>() => Function<...>) | (<V>() => Function<...>) | (<V>() => Function<...>)",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "({ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(((...args: any[]) => Function<(object: any) => any>) & ((...args: any[]) => Function<(object: any) => any>) & ((...args: any[]) => Function<(object: any) => any>)) | ... 4 more ... | ((...args: any[]) => Function<...>)",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(((...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashImplicitWrapper<...>)) | ... 4 more ... | ((...args: any[]) => LoDashImplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "({ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Collection<any> & Function<any> & Object<any> & Primitive<...> & String<...>; (options?: MixinOptions): LoDashImplicitWrapper<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "((() => LoDashStatic) & (() => LoDashStatic) & (() => LoDashStatic)) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic)",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(((...args: any[]) => void) & ((...args: any[]) => void) & ((...args: any[]) => void)) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void)",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "((() => Function<(...args: any[]) => any>) & (() => Function<(...args: any[]) => any>) & (() => Function<(...args: any[]) => any>)) | (() => Function<(...args: any[]) => any>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>)",
          "optional": false
        },
        {
          "name": "property",
          "type": "((<TObj, TResult>() => Function<(obj: TObj) => TResult>) & (<TObj, TResult>() => Function<(obj: TObj) => TResult>) & (<TObj, TResult>() => Function<(obj: TObj) => TResult>)) | ... 4 more ... | (<TObj, TResult>() => Function<...>)",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "((() => LoDashImplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashImplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashImplicitWrapper<...>)) | ... 4 more ... | (() => LoDashImplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "range",
          "type": "(((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>)) | ... 4 more ... | ((end?: number, step?: number) => Collection<...>)",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>)) | ... 4 more ... | ((end?: number, step?: number) => Collection<...>)",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "((() => LoDashStatic) & (() => LoDashStatic) & (() => LoDashStatic)) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic)",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "((() => any[]) & (() => any[]) & (() => any[])) | (() => any[]) | (() => any[]) | (() => any[]) | (() => any[]) | (() => any[])",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "({ (): false; (): false; } & { (): false; (): false; } & { (): false; (): false; }) | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "((() => any) & (() => any) & (() => any)) | (() => any) | (() => any) | (() => any) | (() => any) | (() => any)",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "({ (): true; (): true; } & { (): true; (): true; } & { (): true; (): true; }) | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "({ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; } & { <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; } & { <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ExpChain",
      "type": "ExpChain<T>",
      "properties": [
        {
          "name": "castArray",
          "type": "((() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "({ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "now",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(((thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => FunctionChain<...>)) | ... 4 more ... | ((thisArg: any, ...partials: any[]) => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(((key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => FunctionChain<...>)) | ... 4 more ... | ((key: string, ...partials: any[]) => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(((...args: any[]) => PrimitiveChain<number>) & ((...args: any[]) => PrimitiveChain<number>) & ((...args: any[]) => PrimitiveChain<number>)) | ... 4 more ... | ((...args: any[]) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(((wait: number, ...args: any[]) => PrimitiveChain<number>) & ((wait: number, ...args: any[]) => PrimitiveChain<number>) & ((wait: number, ...args: any[]) => PrimitiveChain<...>)) | ... 4 more ... | ((wait: number, ...args: any[]) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "((<TArgs, TResult>(wrapper: (value: any[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>) & (<TArgs, TResult>(wrapper: (value: any, ...args: TArgs[]) => TResult) => FunctionChain<...>) & (<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<...>)) |...",
          "optional": false
        },
        {
          "name": "clone",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "({ (customizer: CloneDeepWithCustomizer<any[]>): LoDashExplicitWrapper<any>; (): CollectionChain<any> & FunctionChain<...> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "({ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<any[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): CollectionChain<...> & ... 3 more ... & StringChain<...>; } & { ...; } & { ...; }) | ... 4 mor...",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(((source: any[]) => PrimitiveChain<boolean>) & ((source: ConformsPredicateObject<any>) => PrimitiveChain<boolean>) & ((source: string) => PrimitiveChain<...>)) | ... 4 more ... | ((source: ConformsPredicateObject<...>) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>) & ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>) & ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>)) | ... 4 more ... | ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isError",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(((source: object) => PrimitiveChain<boolean>) & ((source: object) => PrimitiveChain<boolean>) & ((source: object) => PrimitiveChain<boolean>)) | ... 4 more ... | ((source: object) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>) & ((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<...>) & ((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<...>)) | ... 4 more ... | ((source: object, customizer: isMatchWithCustomizer) => P...",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isString",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "((() => ObjectChain<any>) & (() => ObjectChain<any>) & (() => ObjectChain<any>)) | (() => ObjectChain<any>) | (() => ObjectChain<any>) | (() => ObjectChain<...>) | (() => ObjectChain<...>) | (() => ObjectChain<...>)",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "add",
          "type": "(((addend: number) => PrimitiveChain<number>) & ((addend: number) => PrimitiveChain<number>) & ((addend: number) => PrimitiveChain<number>)) | ... 4 more ... | ((addend: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(((divisor: number) => PrimitiveChain<number>) & ((divisor: number) => PrimitiveChain<number>) & ((divisor: number) => PrimitiveChain<number>)) | ... 4 more ... | ((divisor: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "mean",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(((multiplicand: number) => PrimitiveChain<number>) & ((multiplicand: number) => PrimitiveChain<number>) & ((multiplicand: number) => PrimitiveChain<number>)) | ... 4 more ... | ((multiplicand: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "round",
          "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(((subtrahend: number) => PrimitiveChain<number>) & ((subtrahend: number) => PrimitiveChain<number>) & ((subtrahend: number) => PrimitiveChain<number>)) | ... 4 more ... | ((subtrahend: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "sum",
          "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "({ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; } & { (lower: number, upper: number): PrimitiveChain<...>; (upper: number): PrimitiveChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(((start: number, end?: number) => PrimitiveChain<boolean>) & ((start: number, end?: number) => PrimitiveChain<boolean>) & ((start: number, end?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((start: number, end?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "random",
          "type": "({ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; } & { (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(((predicate?: ObjectIteratee<any[]>) => StringNullableChain) & ((predicate?: ObjectIteratee<any>) => StringNullableChain) & ((predicate?: ObjectIteratee<...>) => StringNullableChain)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => StringNullableChain)",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(((predicate?: ObjectIteratee<any[]>) => StringNullableChain) & ((predicate?: ObjectIteratee<any>) => StringNullableChain) & ((predicate?: ObjectIteratee<...>) => StringNullableChain)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => StringNullableChain)",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
          "optional": false
        },
        {
          "name": "functions",
          "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "has",
          "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "invert",
          "type": "((() => ObjectChain<Dictionary<string>>) & (() => ObjectChain<Dictionary<string>>) & (() => ObjectChain<Dictionary<string>>)) | ... 4 more ... | (() => ObjectChain<...>)",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>) & ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>) & ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<...>)) | ... 4 more ... | ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "keys",
          "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "result",
          "type": "((<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<...>) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain...",
          "optional": false
        },
        {
          "name": "set",
          "type": "({ (path: PropertyPath, value: any): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "({ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<any[]>): CollectionChain<any> & FunctionChain<any> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... |...",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, string]>)) | ... 4 more ... | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, string]>)) | ... 4 more ... | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "update",
          "type": "(((path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>) & ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>) & ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>)) | ... 4 more ... | ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>)",
          "optional": false
        },
        {
          "name": "chain",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "commit",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(((value: unknown) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & ((value: unknown) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((value: unknown) => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | ((value...",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "value",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(((interceptor: (value: any[]) => void) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>) & ((interceptor: (value: any) => void) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((interceptor: (value: string) => void) => CollectionChain<...> & ......",
          "optional": false
        },
        {
          "name": "thru",
          "type": "((<TResult>(interceptor: (value: any[]) => TResult) => ExpChain<TResult>) & (<TResult>(interceptor: (value: any) => TResult) => ExpChain<TResult>) & (<TResult>(interceptor: (value: string) => TResult) => ExpChain<...>)) | ... 4 more ... | (<TResult>(interceptor: (value: T) => TResult) => ExpChain<...>)",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "((() => StringChain<never>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((target?: string, position?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "escape",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Uncapitalize<string>>)) | (() => StringChain<T extends string ? Uncapitalize<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(((radix?: number) => PrimitiveChain<number>) & ((radix?: number) => PrimitiveChain<number>) & ((radix?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((radix?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(((n?: number) => StringChain<string>) & ((n?: number) => StringChain<string>) & ((n?: number) => StringChain<string>)) | ((n?: number) => StringChain<string>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>)",
          "optional": false
        },
        {
          "name": "replace",
          "type": "({ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "split",
          "type": "(((separator?: string | RegExp, limit?: number) => CollectionChain<string>) & ((separator?: string | RegExp, limit?: number) => CollectionChain<string>) & ((separator?: string | RegExp, limit?: number) => CollectionChain<...>)) | ... 4 more ... | ((separator?: string | RegExp, limit?: number) => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((target?: string, position?: number) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "template",
          "type": "(((options?: TemplateOptions) => FunctionChain<TemplateExecutor>) & ((options?: TemplateOptions) => FunctionChain<TemplateExecutor>) & ((options?: TemplateOptions) => FunctionChain<...>)) | ... 4 more ... | ((options?: TemplateOptions) => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Lowercase<string>>)) | (() => StringChain<T extends string ? Lowercase<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Uppercase<string>>)) | (() => StringChain<T extends string ? Uppercase<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(((options?: TruncateOptions) => StringChain<string>) & ((options?: TruncateOptions) => StringChain<string>) & ((options?: TruncateOptions) => StringChain<...>)) | ... 4 more ... | ((options?: TruncateOptions) => StringChain<...>)",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Capitalize<string>>)) | (() => StringChain<T extends string ? Capitalize<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "words",
          "type": "(((pattern?: string | RegExp) => CollectionChain<string>) & ((pattern?: string | RegExp) => CollectionChain<string>) & ((pattern?: string | RegExp) => CollectionChain<...>)) | ... 4 more ... | ((pattern?: string | RegExp) => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "((<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>) & (<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>) & (<TResult>(...args: any[]) => ObjectChain<...> | ExpChain<...>)) | ... 4 more ... | (<TResult>(...args: any[]) => ObjectChain<...> | ExpChain<...>)",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(((...methodNames: Many<string>[]) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>) & ((...methodNames: Many<...>[]) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((...methodNames: Many<...>[]) => CollectionChain<...> & ... 3 more ... & String...",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "((() => FunctionChain<(value: any[]) => boolean>) & (() => FunctionChain<(value: ConformsPredicateObject<any>) => boolean>) & (() => FunctionChain<...>)) | ... 4 more ... | (() => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "constant",
          "type": "((() => FunctionChain<() => any[]>) & (() => FunctionChain<() => any>) & (() => FunctionChain<() => string>)) | (() => FunctionChain<() => T>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "({ (defaultValue: any[]): CollectionChain<any>; <TDefault>(defaultValue: TDefault): CollectionChain<any> | ExpChain<TDefault>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "matches",
          "type": "((<V>() => FunctionChain<(value: V) => boolean>) & (<V>() => FunctionChain<(value: V) => boolean>) & (<V>() => FunctionChain<(value: V) => boolean>)) | ... 4 more ... | (<V>() => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "({ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(((...args: any[]) => FunctionChain<(object: any) => any>) & ((...args: any[]) => FunctionChain<(object: any) => any>) & ((...args: any[]) => FunctionChain<(object: any) => any>)) | ... 4 more ... | ((...args: any[]) => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(((...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashExplicitWrapper<...>)) | ... 4 more ... | ((...args: any[]) => LoDashExplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "({ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): CollectionChain<any> & FunctionChain<any> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; (options?: MixinOptions): LoDashExplicitWrapper<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "((() => LoDashExplicitWrapper<LoDashStatic>) & (() => LoDashExplicitWrapper<LoDashStatic>) & (() => LoDashExplicitWrapper<...>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(((...args: any[]) => PrimitiveChain<undefined>) & ((...args: any[]) => PrimitiveChain<undefined>) & ((...args: any[]) => PrimitiveChain<undefined>)) | ... 4 more ... | ((...args: any[]) => PrimitiveChain<...>)",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "((() => FunctionChain<(...args: any[]) => any>) & (() => FunctionChain<(...args: any[]) => any>) & (() => FunctionChain<(...args: any[]) => any>)) | (() => FunctionChain<(...args: any[]) => any>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "property",
          "type": "((<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>) & (<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>) & (<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>)) | ... 4 more ... | (<TObj, TResult>() => FunctionChain<...>)",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "((() => LoDashExplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashExplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashExplicitWrapper<...>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "range",
          "type": "(((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<...>)) | ... 4 more ... | ((end?: number, step?: number) => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<...>)) | ... 4 more ... | ((end?: number, step?: number) => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "((() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>)) | (() => CollectionChain<any>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "({ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; } & { (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "((() => LoDashExplicitWrapper<any>) & (() => LoDashExplicitWrapper<any>) & (() => LoDashExplicitWrapper<any>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "({ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; } & { (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "({ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; } & { <TResult>(iteratee: (num: number) => TResult): CollectionChain<...>; (): CollectionChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TemplateSettings",
      "type": "TemplateSettings",
      "properties": [
        {
          "name": "escape",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "evaluate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "imports",
          "type": "Dictionary<any>",
          "optional": true
        },
        {
          "name": "interpolate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "variable",
          "type": "string",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n(ERB). Change the following template settings to use alternative delimiters.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "MapCache",
      "type": "MapCache",
      "properties": [
        {
          "name": "delete",
          "type": "(key: any) => boolean",
          "optional": false
        },
        {
          "name": "get",
          "type": "(key: any) => any",
          "optional": false
        },
        {
          "name": "has",
          "type": "(key: any) => boolean",
          "optional": false
        },
        {
          "name": "set",
          "type": "(key: any, value: any) => MapCache",
          "optional": false
        },
        {
          "name": "clear",
          "type": "() => void",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Creates a cache object to store key/value pairs.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "MapCacheConstructor",
      "type": "MapCacheConstructor",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Collection",
      "type": "Collection<T>",
      "properties": [
        {
          "name": "pop",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...items: T[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: T, b: T) => number) => Collection<T>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "(start: number, deleteCount?: number, ...items: T[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: T[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "(size?: number) => Collection<T[]>",
          "optional": false
        },
        {
          "name": "compact",
          "type": "() => Collection<Truthy<T>>",
          "optional": false
        },
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "difference",
          "type": "(...values: List<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "differenceBy",
          "type": "{ <T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "differenceWith",
          "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>; <T2, T3, T4>(...values: (List<unknown> | Comparator2<T, never>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(n?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "dropRight",
          "type": "(n?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "dropRightWhile",
          "type": "(predicate?: ListIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "dropWhile",
          "type": "(predicate?: ListIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "fill",
          "type": "<U>(value: U, start?: number, end?: number) => Collection<T | U>",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "first",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "() => T extends Many<infer U> ? Collection<U> : Collection<T>",
          "optional": false
        },
        {
          "name": "flattenDeep",
          "type": "() => T extends ListOfRecursiveArraysOrValues<infer U> ? Collection<Flat<U>> : Collection<T>",
          "optional": false
        },
        {
          "name": "flattenDepth",
          "type": "(depth?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "fromPairs",
          "type": "() => Object<Dictionary<T extends [PropertyName, infer U] ? U : any>>",
          "optional": false
        },
        {
          "name": "head",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(value: T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "initial",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "(...arrays: List<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "intersectionBy",
          "type": "{ <T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): Collection<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "intersectionWith",
          "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>; (...values: (List<unknown> | Comparator2<T, never>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => string",
          "optional": false
        },
        {
          "name": "last",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(value: T, fromIndex?: number | true) => number",
          "optional": false
        },
        {
          "name": "nth",
          "type": "(n?: number) => T",
          "optional": false
        },
        {
          "name": "pull",
          "type": "(...values: T[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "pullAll",
          "type": "(values?: List<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "pullAllBy",
          "type": "<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>) => Collection<T>",
          "optional": false
        },
        {
          "name": "pullAllWith",
          "type": "<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>) => Collection<T>",
          "optional": false
        },
        {
          "name": "pullAt",
          "type": "(...indexes: Many<number>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "remove",
          "type": "(predicate?: ListIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "{ (value: T): number; (value: T): number; }",
          "optional": false
        },
        {
          "name": "sortedIndexBy",
          "type": "(value: T, iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedIndexOf",
          "type": "(value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndex",
          "type": "(value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexBy",
          "type": "(value: T, iteratee: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexOf",
          "type": "(value: T) => number",
          "optional": false
        },
        {
          "name": "sortedUniq",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "sortedUniqBy",
          "type": "(iteratee: ValueIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "tail",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "take",
          "type": "(n?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "takeRight",
          "type": "(n?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "takeRightWhile",
          "type": "(predicate?: ListIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "takeWhile",
          "type": "(predicate?: ListIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "union",
          "type": "(...arrays: List<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "unionBy",
          "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): Collection<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "unionWith",
          "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): Collection<T>; (...comparator: (List<T> | Comparator<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "uniqBy",
          "type": "(iteratee: ValueIteratee<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "uniqWith",
          "type": "(comparator?: Comparator<T>) => Collection<T>",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "() => T extends List<infer U> ? Collection<U[]> : unknown",
          "optional": false
        },
        {
          "name": "unzipWith",
          "type": "{ <TResult>(iteratee: (...values: (T extends List<infer U> ? U : unknown)[]) => TResult): Collection<TResult>; (): T extends List<infer U> ? Collection<...> : unknown; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "(...values: T[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "xor",
          "type": "(...arrays: List<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "xorBy",
          "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): Collection<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "xorWith",
          "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): Collection<T>; (...comparator: (List<T> | Comparator<T>)[]): Collection<...>; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ <T2>(arrays2: List<T2>): Collection<[T, T2]>; (...arrays: List<T>[]): Collection<T[]>; }",
          "optional": false
        },
        {
          "name": "zipObject",
          "type": "{ <U>(values: List<U>): Object<Dictionary<U>>; (): Object<Dictionary<undefined>>; }",
          "optional": false
        },
        {
          "name": "zipObjectDeep",
          "type": "(values?: List<any>) => Object<object>",
          "optional": false
        },
        {
          "name": "zipWith",
          "type": "{ <T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): Collection<TResult>; <T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): Collection<...>; <TResult>(...iteratee: (List<...> | ((...group: T[]) => TResult))[]): Collection<....",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => boolean",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>): Collection<S>; (predicate?: ListIterateeCustom<T, boolean>): Collection<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; }",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; }",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, Many<TResult>>): Collection<TResult>; (iteratee: object | [...]): Collection<...>; (): T extends Many<...> ? Collection<...> : Collection<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<...>; (iteratee: object | [...], depth?: number): Collection<...>; (depth?: number): Collection<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<T[]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: T, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<T, PropertyName>) => Object<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <K extends keyof T>(key: K): Collection<T[K]>; <TResult>(iteratee: ListIterator<T, TResult>): Collection<TResult>; (iteratee: PropertyName): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "(iteratees?: Many<PropertyName | PartialShallow<T> | ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => Collection<...>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "{ <U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashImplicitWrapper<[U[], Exclude<T, U>[]]>; (callback: ValueIteratee<T>): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult; (callback: MemoListIterator<T, T, List<T>>): T; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult; (callback: MemoListIterator<T, T, List<T>>): T; }",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => Collection<T>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => Collection<T>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => boolean",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(...iteratees: Many<ListIteratee<T>>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "max",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "maxBy",
          "type": "(iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "meanBy",
          "type": "(iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "min",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "minBy",
          "type": "(iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "sumBy",
          "type": "(iteratee?: string | ((value: T) => number)) => number",
          "optional": false
        },
        {
          "name": "at",
          "type": "(...props: PropertyPath[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: number): T; <TDefault>(path: number, defaultValue: TDefault): T | TDefault; }",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "(iteratee?: ListIteratee<T>) => Object<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: ArrayIterator<T, TResult>): NumericDictionary<TResult>; <TKey extends keyof T>(iteratee: TKey): Object<Dictionary<T[TKey]>>; (iteratee: object): Object<...>; (iteratee: string): Object<...>; (): Object<...>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "(...paths: Many<PropertyName>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "(predicate?: ValueKeyIteratee<T>) => Object<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): Object<Dictionary<S>>; (predicate?: ValueKeyIteratee<T>): Object<...>; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ImpChain<TResult>; (): Collection<any>; }",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => Function<(o: object) => boolean>",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => Function<(...args: any[]) => TResult[]>",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): Collection<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): Collection<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => Collection<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => Collection<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => never",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Collection<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CollectionChain",
      "type": "CollectionChain<T>",
      "properties": [
        {
          "name": "pop",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...items: T[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: T, b: T) => number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "(start: number, deleteCount?: number, ...items: T[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: T[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "(size?: number) => CollectionChain<T[]>",
          "optional": false
        },
        {
          "name": "compact",
          "type": "() => CollectionChain<Truthy<T>>",
          "optional": false
        },
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "difference",
          "type": "(...values: List<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "differenceBy",
          "type": "{ <T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "differenceWith",
          "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>; <T2, T3, T4>(...values: (List<unknown> | Comparator2<T, never>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "drop",
          "type": "(n?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "dropRight",
          "type": "(n?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "dropRightWhile",
          "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "dropWhile",
          "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "fill",
          "type": "<U>(value: U, start?: number, end?: number) => CollectionChain<T | U>",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "first",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "() => T extends Many<infer U> ? CollectionChain<U> : CollectionChain<T>",
          "optional": false
        },
        {
          "name": "flattenDeep",
          "type": "() => T extends ListOfRecursiveArraysOrValues<infer U> ? CollectionChain<Flat<U>> : CollectionChain<T>",
          "optional": false
        },
        {
          "name": "flattenDepth",
          "type": "(depth?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "fromPairs",
          "type": "() => ObjectChain<Dictionary<T extends [PropertyName, infer U] ? U : any>>",
          "optional": false
        },
        {
          "name": "head",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(value: T, fromIndex?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "initial",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "(...arrays: List<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "intersectionBy",
          "type": "{ <T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): CollectionChain<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "intersectionWith",
          "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>; (...values: (List<unknown> | Comparator2<T, never>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "last",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(value: T, fromIndex?: number | true) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "nth",
          "type": "(n?: number) => ExpChain<T>",
          "optional": false
        },
        {
          "name": "pull",
          "type": "(...values: T[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "pullAll",
          "type": "(values?: List<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "pullAllBy",
          "type": "<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "pullAllWith",
          "type": "<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "pullAt",
          "type": "(...indexes: Many<number>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "remove",
          "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "{ (value: T): PrimitiveChain<number>; (value: T): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "sortedIndexBy",
          "type": "(value: T, iteratee?: ValueIteratee<T>) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sortedIndexOf",
          "type": "(value: T) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sortedLastIndex",
          "type": "(value: T) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sortedLastIndexBy",
          "type": "(value: T, iteratee: ValueIteratee<T>) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sortedLastIndexOf",
          "type": "(value: T) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sortedUniq",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "sortedUniqBy",
          "type": "(iteratee: ValueIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "tail",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "take",
          "type": "(n?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "takeRight",
          "type": "(n?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "takeRightWhile",
          "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "takeWhile",
          "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "union",
          "type": "(...arrays: List<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "unionBy",
          "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): CollectionChain<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "unionWith",
          "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): CollectionChain<T>; (...comparator: (List<T> | Comparator<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "uniqBy",
          "type": "(iteratee: ValueIteratee<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "uniqWith",
          "type": "(comparator?: Comparator<T>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "() => T extends List<infer U> ? CollectionChain<U[]> : unknown",
          "optional": false
        },
        {
          "name": "unzipWith",
          "type": "{ <TResult>(iteratee: (...values: (T extends List<infer U> ? U : unknown)[]) => TResult): CollectionChain<TResult>; (): T extends List<infer U> ? CollectionChain<...> : unknown; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "(...values: T[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "xor",
          "type": "(...arrays: List<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "xorBy",
          "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): CollectionChain<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "xorWith",
          "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): CollectionChain<T>; (...comparator: (List<T> | Comparator<T>)[]): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ <T2>(arrays2: List<T2>): CollectionChain<[T, T2]>; (...arrays: List<T>[]): CollectionChain<T[]>; }",
          "optional": false
        },
        {
          "name": "zipObject",
          "type": "{ <U>(values: List<U>): ObjectChain<Dictionary<U>>; (): ObjectChain<Dictionary<undefined>>; }",
          "optional": false
        },
        {
          "name": "zipObjectDeep",
          "type": "(values?: List<any>) => ObjectChain<object>",
          "optional": false
        },
        {
          "name": "zipWith",
          "type": "{ <T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): CollectionChain<TResult>; <T2, T3, TResult>(arrays2: List<T2>, arrays3: List<...>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): CollectionChain<...>; <TResult>(...iteratee: (List<...> | ((...group: T[]) => TResult))[]): C...",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>): CollectionChain<S>; (predicate?: ListIterateeCustom<T, boolean>): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, Many<TResult>>): CollectionChain<TResult>; (iteratee: object | [...]): CollectionChain<...>; (): T extends Many<...> ? CollectionChain<...> : CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<...>; (iteratee: object | [...], depth?: number): CollectionChain<...>; (depth?: number): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<T[]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: T, fromIndex?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<T, PropertyName>) => ObjectChain<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <K extends keyof T>(key: K): CollectionChain<T[K]>; <TResult>(iteratee: ListIterator<T, TResult>): CollectionChain<TResult>; (iteratee: PropertyName): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "(iteratees?: Many<PropertyName | PartialShallow<T> | ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => CollectionChain<...>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "{ <U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashExplicitWrapper<[U[], Exclude<T, U>[]]>; (callback: ValueIteratee<T>): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>; (callback: MemoListIterator<T, T, List<...>>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>; (callback: MemoListIterator<T, T, List<...>>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate?: ListIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(...iteratees: Many<ListIteratee<T>>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "max",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "maxBy",
          "type": "(iteratee?: ValueIteratee<T>) => ExpChain<T>",
          "optional": false
        },
        {
          "name": "meanBy",
          "type": "(iteratee?: ValueIteratee<T>) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "min",
          "type": "() => ExpChain<T>",
          "optional": false
        },
        {
          "name": "minBy",
          "type": "(iteratee?: ValueIteratee<T>) => ExpChain<T>",
          "optional": false
        },
        {
          "name": "sumBy",
          "type": "(iteratee?: string | ((value: T) => number)) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "at",
          "type": "(...props: PropertyPath[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: number): ExpChain<T>; <TDefault>(path: number, defaultValue: TDefault): ExpChain<T> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "(iteratee?: ListIteratee<T>) => ObjectChain<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: ArrayIterator<T, TResult>): ObjectChain<NumericDictionary<TResult>>; <TKey extends keyof T>(iteratee: TKey): ObjectChain<...>; (iteratee: object): ObjectChain<...>; (iteratee: string): ObjectChain<...>; (): ObjectChain<...>; }",
          "optional": false
        },
        {
          "name": "omit",
          "type": "(...paths: Many<PropertyName>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "(predicate?: ValueKeyIteratee<T>) => ObjectChain<Dictionary<T>>",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): ObjectChain<Dictionary<S>>; (predicate?: ValueKeyIteratee<T>): ObjectChain<...>; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ExpChain<TResult>; (): CollectionChain<any>; }",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => FunctionChain<(o: object) => boolean>",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => FunctionChain<(...args: any[]) => TResult[]>",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): CollectionChain<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): CollectionChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): CollectionChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<never>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): CollectionChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function",
      "type": "Function<T>",
      "properties": [
        {
          "name": "ary",
          "type": "(n?: number) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "curry",
          "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? Function<CurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, ar...",
          "optional": false
        },
        {
          "name": "curryRight",
          "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? Function<RightCurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T...",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "{ (wait: number, options: DebounceSettingsLeading): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never; (wait?: number, options?: DebounceSettings): T extends (...args: any[]) => any ? Function<...> : never; }",
          "optional": false
        },
        {
          "name": "flip",
          "type": "() => Function<T>",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "(resolver?: (...args: any[]) => any) => Function<T & MemoizedFunction>",
          "optional": false
        },
        {
          "name": "negate",
          "type": "() => Function<(...args: Parameters<T>) => boolean>",
          "optional": false
        },
        {
          "name": "once",
          "type": "() => Function<T>",
          "optional": false
        },
        {
          "name": "overArgs",
          "type": "(...transforms: Many<(...args: any[]) => any>[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "partial",
          "type": "{ <T2>(plc1: LoDashStatic, arg2: T2): Function<T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : T extends Function3<...> ? Function2<...> : T extends Function4<...> ? Function3<...> : any>; <T3>(plc1: LoDashStatic, plc2: LoDashStatic, arg3: T3): Function<...>; <T1, T3>(arg1: T1, plc2: LoDashStatic, ar...",
          "optional": false
        },
        {
          "name": "partialRight",
          "type": "{ <T1>(arg1: T1, plc2: LoDashStatic): Function<T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> : any>; <T2>(arg2: T2): Function<...>; <T1>(arg1: T1, plc2: LoDashStatic, plc3: LoDashStatic): Function<...>; <T2>(arg2: T2, plc3: LoDashStatic): Function<...>; <T1, T2>(arg1: T1, arg2: T2, plc3: LoDashStatic...",
          "optional": false
        },
        {
          "name": "rearg",
          "type": "(...indexes: Many<number>[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(start?: number) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "spread",
          "type": "(start?: number) => Function<(...args: any[]) => ReturnType<T>>",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "{ (wait?: number, options?: ThrottleSettingsLeading): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never; (wait?: number, options?: ThrottleSettings): T extends (...args: any[]) => any ? Function<...> : never; }",
          "optional": false
        },
        {
          "name": "unary",
          "type": "() => Function<(arg1: Parameters<T>[\"0\"]) => ReturnType<T>>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "flow",
          "type": "{ <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): Function<...>; <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<...>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R...",
          "optional": false
        },
        {
          "name": "flowRight",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>[\"0\"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): Function<...>; <A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<...>[\"0\"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2...",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => Function<T>",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => Function<(...args: any[]) => (ReturnType<T> | TResult)[]>",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: Parameters<T> | TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: Parameters<T> | TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): Function<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Function<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => Function<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => Function<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => Function<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => Function<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => Function<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Function<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [
        "LoDashImplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "String",
      "type": "String<T>",
      "properties": [
        {
          "name": "first",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "head",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => string",
          "optional": false
        },
        {
          "name": "last",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: StringIterator<any>) => String<string>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: StringIterator<any>) => String<string>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(predicate?: StringIterator<boolean>) => Collection<string>",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): Collection<TResult>; (): Collection<string>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<TResult>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<TResult>; (depth?: number): Collection<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: StringIterator<any>) => String<string>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: StringIterator<any>) => String<string>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: string, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <TResult>(iteratee: StringIterator<TResult>): Collection<TResult>; (): Collection<string>; }",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(callback: StringIterator<unknown>) => LoDashImplicitWrapper<[string[], string[]]>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: StringIterator<boolean>) => Collection<string>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: number | number[]): string; (path: number | number[], defaultValue: string): string; }",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: StringIterator<TResult>): Object<NumericDictionary<TResult>>; (): Object<NumericDictionary<string>>; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "<T extends string>() => StringChain<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => Function<(o: object) => any>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): String<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): String<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => String<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => String<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => String<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => String<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => String<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): String<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [
        "LoDashImplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Object",
      "type": "Object<T>",
      "properties": [
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => boolean",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): Collection<S>; (predicate?: ObjectIterateeCustom<T, boolean>): Collection<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, Many<TResult>>): Collection<TResult>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<...>; (iteratee: object | [...], depth?: number): Collection<...>; (depth?: number): Collection<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<T[keyof T][]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: T[keyof T], fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>) => Object<Dictionary<T[keyof T]>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <K extends keyof T[keyof T]>(key: K): Collection<T[keyof T][K]>; <TResult>(iteratee: ObjectIterator<T, TResult>): Collection<TResult>; (iteratee: PropertyName): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "(iteratees?: Many<ObjectIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(callback: ValueIteratee<T[keyof T]>) => LoDashImplicitWrapper<[T[keyof T][], T[keyof T][]]>",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult; (callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult; (callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => T[keyof T]",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => boolean",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(...iteratees: Many<ObjectIteratee<T>>[]) => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "assign",
          "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
          "optional": false
        },
        {
          "name": "assignIn",
          "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
          "optional": false
        },
        {
          "name": "assignInWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
          "optional": false
        },
        {
          "name": "assignWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
          "optional": false
        },
        {
          "name": "at",
          "type": "(...props: Many<keyof T>[]) => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "create",
          "type": "<U extends object>(properties?: U) => Object<T & U>",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "{ <TSource>(source: TSource): Object<NonNullable<TSource & T>>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<NonNullable<TSource2 & TSource1 & T>>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(sour...",
          "optional": false
        },
        {
          "name": "defaultsDeep",
          "type": "(...sources: any[]) => Object<any>",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, T[keyof T]]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, T[keyof T]]>",
          "optional": false
        },
        {
          "name": "extend",
          "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
          "optional": false
        },
        {
          "name": "extendWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ <TKey extends keyof T>(path: TKey | [TKey]): T[TKey]; <TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): TDefault | Exclude<T[TKey], undefined>; <TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [...]): T[TKey1][TKey2]; <TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDe...",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "(iteratee?: ObjectIteratee<T>) => Object<Dictionary<T[keyof T]>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: ObjectIterator<T, TResult>): Object<{ [P in keyof T]: TResult; }>; <TResult>(callback: DictionaryIterator<T[keyof T], TResult>): Object<...>; (iteratee: object): Object<...>; <TKey extends keyof T[keyof T]>(iteratee: TKey): Object<...>; (iteratee: string): Object<...>; (): Object<...>; }",
          "optional": false
        },
        {
          "name": "merge",
          "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
          "optional": false
        },
        {
          "name": "mergeWith",
          "type": "{ <TSource>(source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Object<....",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <K extends keyof T>(...paths: Many<K>[]): Object<Omit<T, K>>; (...paths: Many<string | number | symbol | [PropertyName, any] | PartialShallow<T>>[]): Object<...>; }",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "(predicate: ValueKeyIteratee<T[keyof T]>) => Object<Partial<T>>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <U extends keyof T>(...props: Many<U>[]): Object<Pick<T, U>>; (...props: Many<PropertyPath>[]): Object<Partial<T>>; }",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): Object<NumericDictionary<unknown> extends T ? NumericDictionary<...> : Dictionary<...>>; (predicate?: ValueKeyIteratee<...>): Object<...>; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ImpChain<TResult>; <TResult>(iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): ImpChain<...>; (): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "updateWith",
          "type": "{ (path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): Object<T>; <TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): Object<...>; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "() => Collection<T[keyof T]>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => Function<(o: T) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): Object<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Object<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => Object<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => Object<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => Object<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => Object<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => Object<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Object<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [
        "LoDashImplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Primitive",
      "type": "Primitive<T>",
      "properties": [
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => Collection<T>",
          "optional": false
        },
        {
          "name": "after",
          "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => Function<TFunc>",
          "optional": false
        },
        {
          "name": "before",
          "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => Function<TFunc>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => Collection<T>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): Primitive<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Primitive<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => Primitive<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => Primitive<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => Primitive<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => Primitive<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => Primitive<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Primitive<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [
        "LoDashImplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "FunctionChain",
      "type": "FunctionChain<T>",
      "properties": [
        {
          "name": "ary",
          "type": "(n?: number) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "curry",
          "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? FunctionChain<CurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg...",
          "optional": false
        },
        {
          "name": "curryRight",
          "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? FunctionChain<RightCurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2...",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "{ (wait: number, options: DebounceSettingsLeading): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never; (wait?: number, options?: DebounceSettings): T extends (...args: any[]) => any ? FunctionChain<...> : never; }",
          "optional": false
        },
        {
          "name": "flip",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "(resolver?: (...args: any[]) => any) => FunctionChain<T & MemoizedFunction>",
          "optional": false
        },
        {
          "name": "negate",
          "type": "() => FunctionChain<(...args: Parameters<T>) => boolean>",
          "optional": false
        },
        {
          "name": "once",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "overArgs",
          "type": "(...transforms: Many<(...args: any[]) => any>[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "partial",
          "type": "{ <T2>(plc1: LoDashStatic, arg2: T2): FunctionChain<T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : T extends Function3<...> ? Function2<...> : T extends Function4<...> ? Function3<...> : any>; <T3>(plc1: LoDashStatic, plc2: LoDashStatic, arg3: T3): FunctionChain<...>; <T1, T3>(arg1: T1, plc2: LoDash...",
          "optional": false
        },
        {
          "name": "partialRight",
          "type": "{ <T1>(arg1: T1, plc2: LoDashStatic): FunctionChain<T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> : any>; <T2>(arg2: T2): FunctionChain<...>; <T1>(arg1: T1, plc2: LoDashStatic, plc3: LoDashStatic): FunctionChain<...>; <T2>(arg2: T2, plc3: LoDashStatic): FunctionChain<...>; <T1, T2>(arg1: T1, arg2: T2...",
          "optional": false
        },
        {
          "name": "rearg",
          "type": "(...indexes: Many<number>[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(start?: number) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "spread",
          "type": "(start?: number) => FunctionChain<(...args: any[]) => ReturnType<T>>",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "{ (wait?: number, options?: ThrottleSettingsLeading): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never; (wait?: number, options?: ThrottleSettings): T extends (...args: any[]) => any ? FunctionChain<...> : never; }",
          "optional": false
        },
        {
          "name": "unary",
          "type": "() => FunctionChain<(arg1: Parameters<T>[\"0\"]) => ReturnType<T>>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "flow",
          "type": "{ <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): FunctionChain<...>; <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<...>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6)...",
          "optional": false
        },
        {
          "name": "flowRight",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>[\"0\"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<...>; <A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<...>[\"0\"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) ...",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => FunctionChain<(...args: any[]) => (ReturnType<T> | TResult)[]>",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): FunctionChain<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): FunctionChain<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): FunctionChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): FunctionChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => FunctionChain<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): FunctionChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [
        "LoDashExplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "StringChain",
      "type": "StringChain<T>",
      "properties": [
        {
          "name": "first",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "head",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "last",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>; (): CollectionChain<string>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<TResult>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<TResult>; (depth?: number): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: string, fromIndex?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>; (): CollectionChain<string>; }",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(callback: StringIterator<unknown>) => LoDashExplicitWrapper<[string[], string[]]>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: number | number[]): StringChain<string>; (path: number | number[], defaultValue: string): StringChain<string>; }",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>; (): ObjectChain<NumericDictionary<string>>; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => FunctionChain<(o: object) => any>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): StringChain<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): StringChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): StringChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => StringChain<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => StringChain<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => StringChain<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => StringChain<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): StringChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [
        "LoDashExplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "StringNullableChain",
      "type": "StringNullableChain",
      "properties": [
        {
          "name": "first",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "head",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "last",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "filter",
          "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>; (): CollectionChain<string>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<TResult>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<TResult>; (depth?: number): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>; (): CollectionChain<string>; }",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(callback: StringIterator<unknown>) => LoDashExplicitWrapper<[string[], string[]]>",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ (path: number | number[]): StringNullableChain; (path: number | number[], defaultValue: string): StringChain<string>; }",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>; (): ObjectChain<NumericDictionary<string>>; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => FunctionChain<(o: object) => any>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<string>): LoDashExplicitWrapper<any>; (): StringNullableChain; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): StringChain<...> | ExpChain<...>; (): StringNullableChain; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: string) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): StringNullableChain; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): StringNullableChain; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, string]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, string]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => StringNullableChain",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: string) => void) => StringNullableChain",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: string) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<Uncapitalize<string>>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<Lowercase<string>>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<Uppercase<string>>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<Capitalize<string>>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => StringNullableChain",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: string) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => string>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: string): StringChain<string>; <TDefault>(defaultValue: TDefault): StringChain<string> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => StringNullableChain",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): StringNullableChain; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [
        "LoDashExplicitWrapper<string | undefined>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectChain",
      "type": "ObjectChain<T>",
      "properties": [
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<number>>",
          "optional": false
        },
        {
          "name": "each",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "every",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): CollectionChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, Many<TResult>>): CollectionChain<TResult>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<...>; (iteratee: object | [...], depth?: number): CollectionChain<...>; (depth?: number): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<T[keyof T][]>>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(target: T[keyof T], fromIndex?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>) => ObjectChain<Dictionary<T[keyof T]>>",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <K extends keyof T[keyof T]>(key: K): CollectionChain<T[keyof T][K]>; <TResult>(iteratee: ObjectIterator<T, TResult>): CollectionChain<TResult>; (iteratee: PropertyName): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "(iteratees?: Many<ObjectIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "partition",
          "type": "(callback: ValueIteratee<T[keyof T]>) => LoDashExplicitWrapper<[T[keyof T][], T[keyof T][]]>",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>; (callback: MemoObjectIterator<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>; (callback: MemoObjectIterator<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "reject",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "sample",
          "type": "() => ExpChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "(n?: number) => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "() => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "(...iteratees: Many<ObjectIteratee<T>>[]) => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "() => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "assign",
          "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
          "optional": false
        },
        {
          "name": "assignIn",
          "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
          "optional": false
        },
        {
          "name": "assignInWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
          "optional": false
        },
        {
          "name": "assignWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
          "optional": false
        },
        {
          "name": "at",
          "type": "(...props: Many<keyof T>[]) => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "create",
          "type": "<U extends object>(properties?: U) => ObjectChain<T & U>",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "{ <TSource>(source: TSource): ObjectChain<NonNullable<TSource & T>>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, sou...",
          "optional": false
        },
        {
          "name": "defaultsDeep",
          "type": "(...sources: any[]) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, T[keyof T]]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, T[keyof T]]>",
          "optional": false
        },
        {
          "name": "extend",
          "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
          "optional": false
        },
        {
          "name": "extendWith",
          "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ <TKey extends keyof T>(path: TKey | [TKey]): ExpChain<T[TKey]>; <TKey extends keyof T>(path: TKey | [TKey], defaultValue: never[]): T[TKey] extends any[] ? ExpChain<...> : CollectionChain<...> | ExpChain<...>; <TKey extends keyof T, TDefault>(path: TKey | [...], defaultValue: TDefault): ExpChain<...> | ExpChain<.....",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<string[]>>",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "(iteratee?: ObjectIteratee<T>) => ObjectChain<Dictionary<T[keyof T]>>",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(callback: ObjectIterator<T, TResult>): ObjectChain<{ [P in keyof T]: TResult; }>; <TResult>(callback: DictionaryIterator<T[keyof T], TResult>): ObjectChain<...>; (iteratee: object): ObjectChain<...>; <TKey extends keyof T[keyof T]>(iteratee: TKey): ObjectChain<...>; (iteratee: string): ObjectChain<...>; ...",
          "optional": false
        },
        {
          "name": "merge",
          "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
          "optional": false
        },
        {
          "name": "mergeWith",
          "type": "{ <TSource>(source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Obj...",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <K extends keyof T>(...paths: Many<K>[]): ObjectChain<Omit<T, K>>; (...paths: Many<PropertyName>[]): ObjectChain<Partial<T>>; }",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "(predicate: ValueKeyIteratee<T[keyof T]>) => ObjectChain<Partial<T>>",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <U extends keyof T>(...props: Many<U>[]): ObjectChain<Pick<T, U>>; (...props: Many<PropertyPath>[]): ObjectChain<Partial<T>>; }",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): ObjectChain<NumericDictionary<unknown> extends T ? NumericDictionary<...> : Dictionary<...>>; (predicate?: ValueKeyIteratee<...>): ObjectChain<...>; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ExpChain<TResult>; <TResult>(iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): ExpChain<...>; (): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "updateWith",
          "type": "{ (path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): ObjectChain<T>; <TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): ObjectChain<...>; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "() => CollectionChain<T[keyof T]>",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "() => FunctionChain<(o: T) => boolean>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): ObjectChain<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): ObjectChain<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): ObjectChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): ObjectChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => ObjectChain<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): ObjectChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<LoDashStatic>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [
        "LoDashExplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PrimitiveChain",
      "type": "PrimitiveChain<T>",
      "properties": [
        {
          "name": "concat",
          "type": "(...values: Many<T>[]) => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "after",
          "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => FunctionChain<TFunc>",
          "optional": false
        },
        {
          "name": "before",
          "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => FunctionChain<TFunc>",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "() => CollectionChain<T>",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): PrimitiveChain<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): PrimitiveChain<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): PrimitiveChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): PrimitiveChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => PrimitiveChain<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): PrimitiveChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [
        "LoDashExplicitWrapper<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NotVoid",
      "type": "unknown",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IterateeShorthand",
      "type": "IterateeShorthand<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ArrayIterator",
      "type": "ArrayIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TupleIterator",
      "type": "TupleIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListIterator",
      "type": "ListIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListIteratee",
      "type": "ListIteratee<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListIterateeCustom",
      "type": "ListIterateeCustom<T, TResult>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListIteratorTypeGuard",
      "type": "ListIteratorTypeGuard<T, S>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectIterator",
      "type": "ObjectIterator<TObject, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectIteratee",
      "type": "ObjectIteratee<TObject>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectIterateeCustom",
      "type": "ObjectIterateeCustom<TObject, TResult>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ObjectIteratorTypeGuard",
      "type": "ObjectIteratorTypeGuard<TObject, S>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "StringIterator",
      "type": "StringIterator<TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoVoidIterator",
      "type": "MemoVoidIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": true
      },
      "isExported": false
    },
    {
      "name": "MemoIterator",
      "type": "MemoIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": true
      },
      "isExported": false
    },
    {
      "name": "MemoListIterator",
      "type": "MemoListIterator<T, TResult, TList>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoObjectIterator",
      "type": "MemoObjectIterator<T, TResult, TList>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoIteratorCapped",
      "type": "MemoIteratorCapped<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoIteratorCappedRight",
      "type": "MemoIteratorCappedRight<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoVoidArrayIterator",
      "type": "MemoVoidArrayIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoVoidDictionaryIterator",
      "type": "MemoVoidDictionaryIterator<T, K, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoVoidIteratorCapped",
      "type": "MemoVoidIteratorCapped<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ValueIteratee",
      "type": "ValueIteratee<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ValueIterateeCustom",
      "type": "ValueIterateeCustom<T, TResult>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ValueIteratorTypeGuard",
      "type": "ValueIteratorTypeGuard<T, S>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ValueKeyIteratee",
      "type": "ValueKeyIteratee<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ValueKeyIterateeTypeGuard",
      "type": "ValueKeyIterateeTypeGuard<T, S>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Comparator",
      "type": "Comparator<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Comparator2",
      "type": "Comparator2<T1, T2>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PropertyName",
      "type": "PropertyName",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PropertyPath",
      "type": "PropertyPath",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "List",
      "type": "List<T>",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Common interface between Arrays and jQuery objects",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "Dictionary",
      "type": "Dictionary<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NumericDictionary",
      "type": "NumericDictionary<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "AnyKindOfDictionary",
      "type": "AnyKindOfDictionary",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PartialShallow",
      "type": "PartialShallow<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "StringToNumber",
      "type": "StringToNumber<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(radix?: number) => string",
          "optional": false
        },
        {
          "name": "toFixed",
          "type": "(fractionDigits?: number) => string",
          "optional": false
        },
        {
          "name": "toExponential",
          "type": "(fractionDigits?: number) => string",
          "optional": false
        },
        {
          "name": "toPrecision",
          "type": "(precision?: number) => string",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "{ (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitArrayWrapper",
      "type": "LoDashImplicitArrayWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashImplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => never",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitArrayWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitNillableArrayWrapper",
      "type": "LoDashImplicitNillableArrayWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashImplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => never",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNillableArrayWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitObjectWrapper",
      "type": "LoDashImplicitObjectWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashImplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitObjectWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitNillableObjectWrapper",
      "type": "LoDashImplicitNillableObjectWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashImplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => T extends string ? Uncapitalize<T> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => T extends string ? Lowercase<T> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => T extends string ? Uppercase<T> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => T extends string ? Capitalize<T> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNillableObjectWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitNumberArrayWrapper",
      "type": "LoDashImplicitNumberArrayWrapper",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: number[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<number[]>): any; (): number[]; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<number[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<number[], TResult>): number[] | TResult; (): number[]; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: any[]) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<number[]>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<number[]>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<number[]>): LoDashImplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, number]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, number]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: number[]) => void) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: number[]) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => never",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: any[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => number[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: number[]): number[]; <TDefault>(defaultValue: TDefault): number[] | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNumberArrayWrapper; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitStringWrapper",
      "type": "LoDashImplicitStringWrapper",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<string>): any; (): string; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<string, TResult>): string | TResult; (): string; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: string) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<string>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<string>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitStringWrapper; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): LoDashImplicitStringWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, string]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, string]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: string) => void) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: string) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => Uncapitalize<string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => Lowercase<string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => Uppercase<string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => Capitalize<string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitStringWrapper",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: string) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => string>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: string): string; <TDefault>(defaultValue: TDefault): string | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitStringWrapper; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitArrayWrapper",
      "type": "LoDashExplicitArrayWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitArrayWrapper<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitArrayWrapper<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashExplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<never>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitArrayWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitNillableArrayWrapper",
      "type": "LoDashExplicitNillableArrayWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitNillableArrayWrapper<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitNillableArrayWrapper<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashExplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T[]) => void) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<never>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitNillableArrayWrapper<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNillableArrayWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitObjectWrapper",
      "type": "LoDashExplicitObjectWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): LoDashExplicitObjectWrapper<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitObjectWrapper<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashExplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitObjectWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitNillableObjectWrapper",
      "type": "LoDashExplicitNillableObjectWrapper<T>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): LoDashExplicitNillableObjectWrapper<T>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitNillableObjectWrapper<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashExplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => T",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: T) => void) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => T>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitNillableObjectWrapper<T>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNillableObjectWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitNumberArrayWrapper",
      "type": "LoDashExplicitNumberArrayWrapper",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: number[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<number[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitNumberArrayWrapper; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<number[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitNumberArrayWrapper; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: any[]) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<number[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<number[]>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<number[]>): LoDashExplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, number]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, number]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => number[]",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: number[]) => void) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: number[]) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<never>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: any[]) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => number[]>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: number[]): CollectionChain<number>; <TDefault>(defaultValue: TDefault): CollectionChain<number> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitNumberArrayWrapper",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNumberArrayWrapper; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitStringWrapper",
      "type": "LoDashExplicitStringWrapper",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<string>): LoDashExplicitWrapper<any>; (): LoDashExplicitStringWrapper; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): StringChain<...> | ExpChain<...>; (): LoDashExplicitStringWrapper; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: string) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitStringWrapper; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): LoDashExplicitStringWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, string]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, string]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: string) => void) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: string) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<Uncapitalize<string>>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<Lowercase<string>>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<Uppercase<string>>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<Capitalize<string>>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: string) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => string>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: string): StringChain<string>; <TDefault>(defaultValue: TDefault): StringChain<string> | ExpChain<TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitStringWrapper",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitStringWrapper; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DictionaryIterator",
      "type": "DictionaryIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DictionaryIteratee",
      "type": "DictionaryIteratee<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DictionaryIteratorTypeGuard",
      "type": "DictionaryIteratorTypeGuard<T, S>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NumericDictionaryIterator",
      "type": "NumericDictionaryIterator<T, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NumericDictionaryIteratee",
      "type": "NumericDictionaryIteratee<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "NumericDictionaryIterateeCustom",
      "type": "NumericDictionaryIterateeCustom<T, TResult>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Falsey",
      "type": "Falsey",
      "properties": [
        {
          "name": "valueOf",
          "type": "(() => string) | (() => number) | (() => boolean) | (() => bigint)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Truthy",
      "type": "Truthy<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RecursiveArray",
      "type": "RecursiveArray<T>",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
          "optional": false
        },
        {
          "name": "pop",
          "type": "() => RecursiveArray<T> | T",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...items: (RecursiveArray<T> | T)[]) => number",
          "optional": false
        },
        {
          "name": "concat",
          "type": "{ (...items: ConcatArray<RecursiveArray<T> | T>[]): (RecursiveArray<T> | T)[]; (...items: (RecursiveArray<T> | T | ConcatArray<...>)[]): (RecursiveArray<...> | T)[]; }",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => string",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => (RecursiveArray<T> | T)[]",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => RecursiveArray<T> | T",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => (RecursiveArray<T> | T)[]",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: RecursiveArray<T> | T, b: RecursiveArray<T> | T) => number) => RecursiveArray<T>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "{ (start: number, deleteCount?: number): (RecursiveArray<T> | T)[]; (start: number, deleteCount: number, ...items: (RecursiveArray<T> | T)[]): (RecursiveArray<...> | T)[]; }",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: (RecursiveArray<T> | T)[]) => number",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "every",
          "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: RecursiveArray<...> | T, index: number, array: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): boolean; }",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => unknown, thisArg?: any) => boolean",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(callbackfn: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => void, thisArg?: any) => void",
          "optional": false
        },
        {
          "name": "map",
          "type": "<U>(callbackfn: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => U, thisArg?: any) => U[]",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): S[]; (predicate: (value: RecursiveArray<...> | T, index: number, array: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): (RecursiveArray<...> | T)[]; }",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ (callbackfn: (previousValue: RecursiveArray<T> | T, currentValue: RecursiveArray<T> | T, currentIndex: number, array: (RecursiveArray<T> | T)[]) => RecursiveArray<...> | T): RecursiveArray<...> | T; (callbackfn: (previousValue: RecursiveArray<...> | T, currentValue: RecursiveArray<...> | T, currentIndex: number, a...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ (callbackfn: (previousValue: RecursiveArray<T> | T, currentValue: RecursiveArray<T> | T, currentIndex: number, array: (RecursiveArray<T> | T)[]) => RecursiveArray<...> | T): RecursiveArray<...> | T; (callbackfn: (previousValue: RecursiveArray<...> | T, currentValue: RecursiveArray<...> | T, currentIndex: number, a...",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, obj: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): S; (predicate: (value: RecursiveArray<...> | T, index: number, obj: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): RecursiveArray<...> | T; }",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(predicate: (value: RecursiveArray<T> | T, index: number, obj: (RecursiveArray<T> | T)[]) => unknown, thisArg?: any) => number",
          "optional": false
        },
        {
          "name": "fill",
          "type": "(value: RecursiveArray<T> | T, start?: number, end?: number) => RecursiveArray<T>",
          "optional": false
        },
        {
          "name": "copyWithin",
          "type": "(target: number, start: number, end?: number) => RecursiveArray<T>",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => ArrayIterator<[number, RecursiveArray<T> | T]>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => ArrayIterator<number>",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => ArrayIterator<RecursiveArray<T> | T>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "<U, This = undefined>(callback: (this: This, value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => U | readonly U[], thisArg?: This) => U[]",
          "optional": false
        },
        {
          "name": "flat",
          "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
          "optional": false
        },
        {
          "name": "__@iterator@4630",
          "type": "() => ArrayIterator<RecursiveArray<T> | T>",
          "optional": false
        },
        {
          "name": "__@unscopables@4632",
          "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
          "optional": false
        },
        {
          "name": "at",
          "type": "(index: number) => RecursiveArray<T> | T",
          "optional": false
        }
      ],
      "extends": [
        "Array<T|RecursiveArray<T>>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ListOfRecursiveArraysOrValues",
      "type": "ListOfRecursiveArraysOrValues<T>",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "extends": [
        "List<T|RecursiveArray<T>>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Flat",
      "type": "Flat<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashImplicitWrapper",
      "type": "LoDashImplicitWrapper<TValue>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => Primitive<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<TValue>): any; (): TValue; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<TValue, TResult>): TValue | TResult; (): TValue; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<TValue>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => this is LoDashImplicitWrapper<object>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => boolean",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => Object<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => Collection<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<TValue>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<TValue>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => Object<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashImplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): LoDashImplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => Primitive<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: TValue) => void) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: TValue) => TResult) => ImpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => string extends TValue ? TValue & string : Capitalize<Lowercase<TValue extends string ? TValue : never>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => TValue extends string ? Uncapitalize<TValue> : string",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => TValue extends string ? Lowercase<TValue> : string",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => TValue extends string ? Uppercase<TValue> : string",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => string",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => TValue extends string ? Capitalize<TValue> : string",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => Collection<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashImplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => Function<(value: ConformsPredicateObject<TValue>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => Function<() => TValue>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: TValue): TValue; <TDefault>(defaultValue: TDefault): TValue extends null ? TDefault : TValue | TDefault; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => Function<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => Function<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitWrapper<TValue>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => Function<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => Collection<number>",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => Collection<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashExplicitWrapper",
      "type": "LoDashExplicitWrapper<TValue>",
      "properties": [
        {
          "name": "invokeMap",
          "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
          "optional": false
        },
        {
          "name": "clone",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ (customizer: CloneDeepWithCustomizer<TValue>): LoDashExplicitWrapper<any>; (): LoDashExplicitWrapper<TValue>; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "(source: ConformsPredicateObject<TValue>) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isError",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(source: object) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "() => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(other: any) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "() => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "add",
          "type": "(addend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(divisor: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "mean",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplicand: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "round",
          "type": "(precision?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(subtrahend: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "sum",
          "type": "() => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "() => CollectionChain<[string, any]>",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "(predicate?: ObjectIteratee<TValue>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "(predicate?: ObjectIteratee<TValue>) => StringNullableChain",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "functions",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "has",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "invert",
          "type": "() => ObjectChain<Dictionary<string>>",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ (path: PropertyPath, value: any): LoDashExplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): LoDashExplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "() => CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "() => CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "update",
          "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
          "optional": false
        },
        {
          "name": "chain",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "commit",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "plant",
          "type": "(value: unknown) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "toJSON",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "value",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "() => TValue",
          "optional": false
        },
        {
          "name": "tap",
          "type": "(interceptor: (value: TValue) => void) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<TResult>(interceptor: (value: TValue) => TResult) => ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "() => StringChain<string extends TValue ? TValue & string : Capitalize<Lowercase<TValue extends string ? TValue : never>>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "escape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "() => StringChain<TValue extends string ? Uncapitalize<TValue> : string>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(length?: number, chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(radix?: number) => PrimitiveChain<number>",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(n?: number) => StringChain<string>",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "split",
          "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
          "optional": false
        },
        {
          "name": "template",
          "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "() => StringChain<TValue extends string ? Lowercase<TValue> : string>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "() => StringChain<TValue extends string ? Uppercase<TValue> : string>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "(chars?: string) => StringChain<string>",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(options?: TruncateOptions) => StringChain<string>",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "() => StringChain<TValue extends string ? Capitalize<TValue> : string>",
          "optional": false
        },
        {
          "name": "words",
          "type": "(pattern?: string | RegExp) => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "(...methodNames: Many<string>[]) => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "() => FunctionChain<(value: ConformsPredicateObject<TValue>) => boolean>",
          "optional": false
        },
        {
          "name": "constant",
          "type": "() => FunctionChain<() => TValue>",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ (defaultValue: TValue): ExpChain<TValue>; <TDefault>(defaultValue: TDefault): ExpChain<TValue extends null ? TDefault : TValue | TDefault>; }",
          "optional": false
        },
        {
          "name": "identity",
          "type": "() => LoDashExplicitWrapper<TValue>",
          "optional": false
        },
        {
          "name": "matches",
          "type": "<V>() => FunctionChain<(value: V) => boolean>",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitWrapper<TValue>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashExplicitWrapper<LoDashStatic>",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => PrimitiveChain<undefined>",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "() => FunctionChain<(...args: any[]) => any>",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
          "optional": false
        },
        {
          "name": "range",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "(end?: number, step?: number) => CollectionChain<number>",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => CollectionChain<any>",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => LoDashExplicitWrapper<any>",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => StringChain<string>",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "() => CollectionChain<string>",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "() => StringChain<string>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "FunctionBind",
      "type": "FunctionBind",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "FunctionBindKey",
      "type": "FunctionBindKey",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Curry",
      "type": "Curry",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurriedFunction1",
      "type": "CurriedFunction1<T1, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurriedFunction2",
      "type": "CurriedFunction2<T1, T2, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurriedFunction3",
      "type": "CurriedFunction3<T1, T2, T3, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurriedFunction4",
      "type": "CurriedFunction4<T1, T2, T3, T4, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurriedFunction5",
      "type": "CurriedFunction5<T1, T2, T3, T4, T5, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RightCurriedFunction1",
      "type": "RightCurriedFunction1<T1, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RightCurriedFunction2",
      "type": "RightCurriedFunction2<T1, T2, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RightCurriedFunction3",
      "type": "RightCurriedFunction3<T1, T2, T3, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RightCurriedFunction4",
      "type": "RightCurriedFunction4<T1, T2, T3, T4, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "RightCurriedFunction5",
      "type": "RightCurriedFunction5<T1, T2, T3, T4, T5, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CurryRight",
      "type": "CurryRight",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DebounceSettings",
      "type": "DebounceSettings",
      "properties": [
        {
          "name": "leading",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "maxWait",
          "type": "number",
          "optional": true
        },
        {
          "name": "trailing",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DebounceSettingsLeading",
      "type": "DebounceSettingsLeading",
      "properties": [
        {
          "name": "leading",
          "type": "true",
          "optional": false
        },
        {
          "name": "maxWait",
          "type": "number",
          "optional": true
        },
        {
          "name": "trailing",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [
        "DebounceSettings"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DebouncedFunc",
      "type": "DebouncedFunc<T>",
      "properties": [
        {
          "name": "cancel",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "flush",
          "type": "() => ReturnType<T>",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "DebouncedFuncLeading",
      "type": "DebouncedFuncLeading<T>",
      "properties": [
        {
          "name": "flush",
          "type": "() => ReturnType<T>",
          "optional": false
        },
        {
          "name": "cancel",
          "type": "() => void",
          "optional": false
        }
      ],
      "extends": [
        "DebouncedFunc<T>"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MemoizedFunction",
      "type": "MemoizedFunction",
      "properties": [
        {
          "name": "cache",
          "type": "MapCache",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "__",
      "type": "LoDashStatic",
      "properties": [
        {
          "name": "VERSION",
          "type": "string",
          "optional": false
        },
        {
          "name": "templateSettings",
          "type": "TemplateSettings",
          "optional": false
        },
        {
          "name": "chunk",
          "type": "<T>(array: List<T>, size?: number) => T[][]",
          "optional": false
        },
        {
          "name": "compact",
          "type": "<T>(array: List<T | Falsey>) => T[]",
          "optional": false
        },
        {
          "name": "concat",
          "type": "<T>(...values: Many<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "difference",
          "type": "<T>(array: List<T>, ...values: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "differenceBy",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, values3: List<...>, iteratee: ValueIteratee<...>)...",
          "optional": false
        },
        {
          "name": "differenceWith",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
          "optional": false
        },
        {
          "name": "drop",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "dropRight",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "dropRightWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "dropWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "fill",
          "type": "{ <T>(array: any[], value: T): T[]; <T>(array: List<any>, value: T): List<T>; <T, U>(array: U[], value: T, start?: number, end?: number): (T | U)[]; <T, U>(array: List<U>, value: T, start?: number, end?: number): List<...>; }",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "findLastIndex",
          "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "first",
          "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
          "optional": false
        },
        {
          "name": "flatten",
          "type": "<T>(array: List<Many<T>>) => T[]",
          "optional": false
        },
        {
          "name": "flattenDeep",
          "type": "<T>(array: ListOfRecursiveArraysOrValues<T>) => Flat<T>[]",
          "optional": false
        },
        {
          "name": "flattenDepth",
          "type": "<T>(array: ListOfRecursiveArraysOrValues<T>, depth?: number) => T[]",
          "optional": false
        },
        {
          "name": "fromPairs",
          "type": "{ <T>(pairs: List<[PropertyName, T]>): Dictionary<T>; (pairs: List<any[]>): Dictionary<any>; }",
          "optional": false
        },
        {
          "name": "head",
          "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "<T>(array: List<T>, value: T, fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "initial",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "intersection",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "intersectionBy",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | ValueIteratee<...>)[]): T...",
          "optional": false
        },
        {
          "name": "intersectionWith",
          "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
          "optional": false
        },
        {
          "name": "join",
          "type": "(array: List<any>, separator?: string) => string",
          "optional": false
        },
        {
          "name": "last",
          "type": "<T>(array: List<T>) => T",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "<T>(array: List<T>, value: T, fromIndex?: number | true) => number",
          "optional": false
        },
        {
          "name": "nth",
          "type": "<T>(array: List<T>, n?: number) => T",
          "optional": false
        },
        {
          "name": "pull",
          "type": "{ <T>(array: T[], ...values: T[]): T[]; <T>(array: List<T>, ...values: T[]): List<T>; }",
          "optional": false
        },
        {
          "name": "pullAll",
          "type": "{ <T>(array: T[], values?: List<T>): T[]; <T>(array: List<T>, values?: List<T>): List<T>; }",
          "optional": false
        },
        {
          "name": "pullAllBy",
          "type": "{ <T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, iteratee: ValueIteratee<...>): List<...>; }",
          "optional": false
        },
        {
          "name": "pullAllWith",
          "type": "{ <T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[]; <T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, comparator: Comparator2<...>): List<...>; }",
          "optional": false
        },
        {
          "name": "pullAt",
          "type": "{ <T>(array: T[], ...indexes: Many<number>[]): T[]; <T>(array: List<T>, ...indexes: Many<number>[]): List<T>; }",
          "optional": false
        },
        {
          "name": "remove",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "<TList extends List<any>>(array: TList) => TList",
          "optional": false
        },
        {
          "name": "slice",
          "type": "<T>(array: List<T>, start?: number, end?: number) => T[]",
          "optional": false
        },
        {
          "name": "sortedIndex",
          "type": "{ <T>(array: List<T>, value: T): number; <T>(array: List<T>, value: T): number; }",
          "optional": false
        },
        {
          "name": "sortedIndexBy",
          "type": "<T>(array: List<T>, value: T, iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedIndexOf",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndex",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexBy",
          "type": "<T>(array: List<T>, value: T, iteratee: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "sortedLastIndexOf",
          "type": "<T>(array: List<T>, value: T) => number",
          "optional": false
        },
        {
          "name": "sortedUniq",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "sortedUniqBy",
          "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "tail",
          "type": "{ <T extends unknown[]>(array: readonly [unknown, ...T]): T; <T>(array: List<T>): T[]; }",
          "optional": false
        },
        {
          "name": "take",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "takeRight",
          "type": "<T>(array: List<T>, n?: number) => T[]",
          "optional": false
        },
        {
          "name": "takeRightWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "takeWhile",
          "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "union",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "unionBy",
          "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee?: ValueIteratee<...>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>,...",
          "optional": false
        },
        {
          "name": "unionWith",
          "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "uniq",
          "type": "<T>(array: List<T>) => T[]",
          "optional": false
        },
        {
          "name": "uniqBy",
          "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
          "optional": false
        },
        {
          "name": "uniqWith",
          "type": "<T>(array: List<T>, comparator?: Comparator<T>) => T[]",
          "optional": false
        },
        {
          "name": "unzip",
          "type": "<T>(array: T[][] | List<List<T>>) => T[][]",
          "optional": false
        },
        {
          "name": "unzipWith",
          "type": "{ <T, TResult>(array: List<List<T>>, iteratee: (...values: T[]) => TResult): TResult[]; <T>(array: List<List<T>>): T[][]; }",
          "optional": false
        },
        {
          "name": "without",
          "type": "<T>(array: List<T>, ...values: T[]) => T[]",
          "optional": false
        },
        {
          "name": "xor",
          "type": "<T>(...arrays: List<T>[]) => T[]",
          "optional": false
        },
        {
          "name": "xorBy",
          "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...iteratee: (ValueIteratee<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "xorWith",
          "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
          "optional": false
        },
        {
          "name": "zip",
          "type": "{ <T1, T2>(arrays1: List<T1>, arrays2: List<T2>): [T1, T2][]; <T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): [...][]; <T1, T2, T3, T4>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>): [...][]; <T1, T2, T3, T4, T5>(arrays1: List<...>, arrays2: List<...>, arrays3...",
          "optional": false
        },
        {
          "name": "zipObject",
          "type": "{ <T>(props: List<PropertyName>, values: List<T>): Dictionary<T>; (props?: List<PropertyName>): Dictionary<undefined>; }",
          "optional": false
        },
        {
          "name": "zipObjectDeep",
          "type": "(paths?: List<PropertyPath>, values?: List<any>) => object",
          "optional": false
        },
        {
          "name": "zipWith",
          "type": "{ <T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[]; <T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[]; <T1, T2, T3, TResult>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee: (value1: T1, value2: T2, value3:...",
          "optional": false
        },
        {
          "name": "countBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<number>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "each",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "eachRight",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "every",
          "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>): S[]; <T>(collection: List<...>, predicate?: ListIterateeCustom<...>): T[]; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<....",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
          "optional": false
        },
        {
          "name": "findLast",
          "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "{ <T>(collection: Dictionary<Many<T>> | NumericDictionary<Many<T>>): T[]; (collection: object): any[]; <T, TResult>(collection: List<T>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, iteratee: string): any[]; (colle...",
          "optional": false
        },
        {
          "name": "flatMapDeep",
          "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, i...",
          "optional": false
        },
        {
          "name": "flatMapDepth",
          "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>, depth?: number): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>, depth?: number): T...",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "forEachRight",
          "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
          "optional": false
        },
        {
          "name": "groupBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<T[]>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "includes",
          "type": "<T>(collection: Dictionary<T> | NumericDictionary<T>, target: T, fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "invokeMap",
          "type": "{ (collection: object, methodName: string, ...args: any[]): any[]; <TResult>(collection: object, method: (...args: any[]) => TResult, ...args: any[]): TResult[]; }",
          "optional": false
        },
        {
          "name": "keyBy",
          "type": "{ <T>(collection: List<T>, iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>; <T extends object>(collection: T, iteratee?: ValueIterateeCustom<...>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "map",
          "type": "{ <T extends readonly [unknown, ...unknown[]], TResult>(collection: T, iteratee: TupleIterator<T, TResult>): { [K in keyof T]: TResult; }; <T, TResult>(collection: T[], iteratee: ArrayIterator<...>): TResult[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T>(collection: Dictionary<.....",
          "optional": false
        },
        {
          "name": "orderBy",
          "type": "{ <T>(collection: List<T>, iteratees?: Many<ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">): T[]; <T>(collection: List<T>, iteratees?: Many<...>, orders?: Many<...>): T[]; <T extends object>(collection: T, iteratees?: Many<...>, orders?: Many<...>): T[keyof T][]; <T extends object>(collection: T,...",
          "optional": false
        },
        {
          "name": "partition",
          "type": "{ <T, U extends T>(collection: List<T>, callback: ValueIteratorTypeGuard<T, U>): [U[], Exclude<T, U>[]]; <T>(collection: List<T>, callback: ValueIteratee<...>): [...]; <T extends object>(collection: T, callback: ValueIteratee<...>): [...]; }",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
          "optional": false
        },
        {
          "name": "reject",
          "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): T[]; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<...>): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "sample",
          "type": "{ <T>(collection: readonly [T, ...T[]]): T; <T>(collection: Dictionary<T> | NumericDictionary<T>): T; <T extends object>(collection: T): T[keyof T]; }",
          "optional": false
        },
        {
          "name": "sampleSize",
          "type": "{ <T>(collection: Dictionary<T> | NumericDictionary<T>, n?: number): T[]; <T extends object>(collection: T, n?: number): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "shuffle",
          "type": "{ <T>(collection: List<T>): T[]; <T extends object>(collection: T): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "size",
          "type": "(collection: string | object) => number",
          "optional": false
        },
        {
          "name": "some",
          "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
          "optional": false
        },
        {
          "name": "sortBy",
          "type": "{ <T>(collection: List<T>, ...iteratees: Many<ListIteratee<T>>[]): T[]; <T extends object>(collection: T, ...iteratees: Many<ObjectIteratee<T>>[]): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "now",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "after",
          "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
          "optional": false
        },
        {
          "name": "ary",
          "type": "(func: (...args: any[]) => any, n?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "before",
          "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
          "optional": false
        },
        {
          "name": "bind",
          "type": "FunctionBind",
          "optional": false
        },
        {
          "name": "bindKey",
          "type": "FunctionBindKey",
          "optional": false
        },
        {
          "name": "curry",
          "type": "Curry",
          "optional": false
        },
        {
          "name": "curryRight",
          "type": "CurryRight",
          "optional": false
        },
        {
          "name": "debounce",
          "type": "{ <T extends (...args: any) => any>(func: T, wait: number, options: DebounceSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<...>; }",
          "optional": false
        },
        {
          "name": "defer",
          "type": "(func: (...args: any[]) => any, ...args: any[]) => number",
          "optional": false
        },
        {
          "name": "delay",
          "type": "(func: (...args: any[]) => any, wait: number, ...args: any[]) => number",
          "optional": false
        },
        {
          "name": "flip",
          "type": "<T extends (...args: any) => any>(func: T) => T",
          "optional": false
        },
        {
          "name": "memoize",
          "type": "{ <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction; Cache: MapCacheConstructor; }",
          "optional": false
        },
        {
          "name": "negate",
          "type": "<T extends any[]>(predicate: (...args: T) => boolean) => (...args: T) => boolean",
          "optional": false
        },
        {
          "name": "once",
          "type": "<T extends (...args: any) => any>(func: T) => T",
          "optional": false
        },
        {
          "name": "overArgs",
          "type": "(func: (...args: any[]) => any, ...transforms: Many<(...args: any[]) => any>[]) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "partial",
          "type": "Partial",
          "optional": false
        },
        {
          "name": "partialRight",
          "type": "PartialRight",
          "optional": false
        },
        {
          "name": "rearg",
          "type": "(func: (...args: any[]) => any, ...indexes: Many<number>[]) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "rest",
          "type": "(func: (...args: any[]) => any, start?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "spread",
          "type": "<TResult>(func: (...args: any[]) => TResult, start?: number) => (...args: any[]) => TResult",
          "optional": false
        },
        {
          "name": "throttle",
          "type": "{ <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<...>; }",
          "optional": false
        },
        {
          "name": "unary",
          "type": "<T, TResult>(func: (arg1: T, ...args: any[]) => TResult) => (arg1: T) => TResult",
          "optional": false
        },
        {
          "name": "wrap",
          "type": "<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult) => (...args: TArgs[]) => TResult",
          "optional": false
        },
        {
          "name": "castArray",
          "type": "<T>(value?: Many<T>) => T[]",
          "optional": false
        },
        {
          "name": "clone",
          "type": "<T>(value: T) => T",
          "optional": false
        },
        {
          "name": "cloneDeep",
          "type": "<T>(value: T) => T",
          "optional": false
        },
        {
          "name": "cloneDeepWith",
          "type": "{ <T>(value: T, customizer: CloneDeepWithCustomizer<T>): any; <T>(value: T): T; }",
          "optional": false
        },
        {
          "name": "cloneWith",
          "type": "{ <T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult; <T, TResult>(value: T, customizer: CloneWithCustomizer<...>): T | TResult; <T>(value: T): T; }",
          "optional": false
        },
        {
          "name": "conformsTo",
          "type": "<T>(object: T, source: ConformsPredicateObject<T>) => boolean",
          "optional": false
        },
        {
          "name": "eq",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "gt",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "gte",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "isArguments",
          "type": "(value?: any) => value is IArguments",
          "optional": false
        },
        {
          "name": "isArray",
          "type": "{ (value?: any): value is any[]; <T>(value?: any): value is any[]; }",
          "optional": false
        },
        {
          "name": "isArrayBuffer",
          "type": "(value?: any) => value is ArrayBuffer",
          "optional": false
        },
        {
          "name": "isArrayLike",
          "type": "{ <T extends { __lodashAnyHack: any; }>(t: T): boolean; (value: (...args: any[]) => any): value is never; (value: any): value is { length: number; }; }",
          "optional": false
        },
        {
          "name": "isArrayLikeObject",
          "type": "{ <T extends { __lodashAnyHack: any; }>(value: T): boolean; (value: string | number | boolean | Function | ((...args: any[]) => any)): value is never; (value: any): value is object & { length: number; }; }",
          "optional": false
        },
        {
          "name": "isBoolean",
          "type": "(value?: any) => value is boolean",
          "optional": false
        },
        {
          "name": "isBuffer",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isDate",
          "type": "(value?: any) => value is Date",
          "optional": false
        },
        {
          "name": "isElement",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isEmpty",
          "type": "{ <T extends { __trapAny: any; }>(value?: T): boolean; (value: string): value is \"\"; (value: List<any> | Map<any, any> | Set<any>): boolean; (value: object): boolean; <T extends object>(value: T): value is EmptyObjectOf<...>; (value?: any): boolean; }",
          "optional": false
        },
        {
          "name": "isEqual",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "isEqualWith",
          "type": "(value: any, other: any, customizer?: IsEqualCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isError",
          "type": "(value: any) => value is Error",
          "optional": false
        },
        {
          "name": "isFinite",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isFunction",
          "type": "(value: any) => value is (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "isInteger",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isLength",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isMap",
          "type": "(value?: any) => value is Map<any, any>",
          "optional": false
        },
        {
          "name": "isMatch",
          "type": "(object: object, source: object) => boolean",
          "optional": false
        },
        {
          "name": "isMatchWith",
          "type": "(object: object, source: object, customizer: isMatchWithCustomizer) => boolean",
          "optional": false
        },
        {
          "name": "isNaN",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isNative",
          "type": "(value: any) => value is (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "isNil",
          "type": "(value: any) => value is null",
          "optional": false
        },
        {
          "name": "isNull",
          "type": "(value: any) => value is null",
          "optional": false
        },
        {
          "name": "isNumber",
          "type": "(value?: any) => value is number",
          "optional": false
        },
        {
          "name": "isObject",
          "type": "(value?: any) => value is object",
          "optional": false
        },
        {
          "name": "isObjectLike",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isPlainObject",
          "type": "(value?: any) => boolean",
          "optional": false
        },
        {
          "name": "isRegExp",
          "type": "(value?: any) => value is RegExp",
          "optional": false
        },
        {
          "name": "isSafeInteger",
          "type": "(value: any) => boolean",
          "optional": false
        },
        {
          "name": "isSet",
          "type": "(value?: any) => value is Set<any>",
          "optional": false
        },
        {
          "name": "isString",
          "type": "(value?: any) => value is string",
          "optional": false
        },
        {
          "name": "isSymbol",
          "type": "(value: any) => value is symbol",
          "optional": false
        },
        {
          "name": "isTypedArray",
          "type": "(value: any) => boolean",
          "optional": false
        },
        {
          "name": "isUndefined",
          "type": "(value: any) => value is undefined",
          "optional": false
        },
        {
          "name": "isWeakMap",
          "type": "(value?: any) => value is WeakMap<object, any>",
          "optional": false
        },
        {
          "name": "isWeakSet",
          "type": "(value?: any) => value is WeakSet<object>",
          "optional": false
        },
        {
          "name": "lt",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "lte",
          "type": "(value: any, other: any) => boolean",
          "optional": false
        },
        {
          "name": "toArray",
          "type": "{ <T>(value: Dictionary<T> | NumericDictionary<T>): T[]; <T>(value: T): T[keyof T][]; (): any[]; }",
          "optional": false
        },
        {
          "name": "toFinite",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toInteger",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toLength",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toNumber",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toPlainObject",
          "type": "(value?: any) => any",
          "optional": false
        },
        {
          "name": "toSafeInteger",
          "type": "(value: any) => number",
          "optional": false
        },
        {
          "name": "toString",
          "type": "(value: any) => string",
          "optional": false
        },
        {
          "name": "add",
          "type": "(augend: number, addend: number) => number",
          "optional": false
        },
        {
          "name": "ceil",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "divide",
          "type": "(dividend: number, divisor: number) => number",
          "optional": false
        },
        {
          "name": "floor",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "max",
          "type": "<T>(collection: List<T>) => T",
          "optional": false
        },
        {
          "name": "maxBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "mean",
          "type": "(collection: List<any>) => number",
          "optional": false
        },
        {
          "name": "meanBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => number",
          "optional": false
        },
        {
          "name": "min",
          "type": "<T>(collection: List<T>) => T",
          "optional": false
        },
        {
          "name": "minBy",
          "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
          "optional": false
        },
        {
          "name": "multiply",
          "type": "(multiplier: number, multiplicand: number) => number",
          "optional": false
        },
        {
          "name": "round",
          "type": "(n: number, precision?: number) => number",
          "optional": false
        },
        {
          "name": "subtract",
          "type": "(minuend: number, subtrahend: number) => number",
          "optional": false
        },
        {
          "name": "sum",
          "type": "(collection: List<any>) => number",
          "optional": false
        },
        {
          "name": "sumBy",
          "type": "<T>(collection: List<T>, iteratee?: string | ((value: T) => number)) => number",
          "optional": false
        },
        {
          "name": "clamp",
          "type": "{ (number: number, lower: number, upper: number): number; (number: number, upper: number): number; }",
          "optional": false
        },
        {
          "name": "inRange",
          "type": "(n: number, start: number, end?: number) => boolean",
          "optional": false
        },
        {
          "name": "random",
          "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; (min: number, max: number, floating?: boolean): number; (min: number, index: string | number, guard: object): number; }",
          "optional": false
        },
        {
          "name": "assign",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "assignIn",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "assignInWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "assignWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "at",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, ...props: PropertyPath[]): T[]; <T extends object>(object: T, ...props: Many<keyof T>[]): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "create",
          "type": "<T extends object, U extends object>(prototype: T, properties?: U) => T & U",
          "optional": false
        },
        {
          "name": "defaults",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<...>; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullabl...",
          "optional": false
        },
        {
          "name": "defaultsDeep",
          "type": "(object: any, ...sources: any[]) => any",
          "optional": false
        },
        {
          "name": "entries",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "entriesIn",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "extend",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "extendWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
          "optional": false
        },
        {
          "name": "findKey",
          "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "findLastKey",
          "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
          "optional": false
        },
        {
          "name": "forIn",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forInRight",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forOwn",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "forOwnRight",
          "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
          "optional": false
        },
        {
          "name": "functions",
          "type": "(object: any) => string[]",
          "optional": false
        },
        {
          "name": "functionsIn",
          "type": "<T extends {}>(object: any) => string[]",
          "optional": false
        },
        {
          "name": "get",
          "type": "{ <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [...]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject, path: TKey | [...], de...",
          "optional": false
        },
        {
          "name": "has",
          "type": "{ <T, K extends PropertyName>(object: T, path: K): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown; } & { ...; }; <T>(object: T, path: PropertyPath): boolean; }",
          "optional": false
        },
        {
          "name": "hasIn",
          "type": "<T>(object: T, path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "invert",
          "type": "(object: object) => Dictionary<string>",
          "optional": false
        },
        {
          "name": "invertBy",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, interatee?: ValueIteratee<T>): Dictionary<string[]>; <T extends object>(object: T, interatee?: ValueIteratee<...>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "invoke",
          "type": "(object: any, path: PropertyPath, ...args: any[]) => any",
          "optional": false
        },
        {
          "name": "keys",
          "type": "(object?: any) => string[]",
          "optional": false
        },
        {
          "name": "keysIn",
          "type": "(object?: any) => string[]",
          "optional": false
        },
        {
          "name": "mapKeys",
          "type": "{ <T>(object: List<T>, iteratee?: ListIteratee<T>): Dictionary<T>; <T extends object>(object: T, iteratee?: ObjectIteratee<T>): Dictionary<...>; }",
          "optional": false
        },
        {
          "name": "mapValues",
          "type": "{ <TResult>(obj: string, callback: StringIterator<TResult>): NumericDictionary<TResult>; <T, TResult>(array: T[], callback: ArrayIterator<T, TResult>): NumericDictionary<...>; <T extends object, TResult>(obj: T, callback: ObjectIterator<...>): { [P in keyof T]: TResult; }; <T>(obj: Dictionary<...> | NumericDictionar...",
          "optional": false
        },
        {
          "name": "merge",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
          "optional": false
        },
        {
          "name": "mergeWith",
          "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, objec...",
          "optional": false
        },
        {
          "name": "omit",
          "type": "{ <T extends object, K extends PropertyName[]>(object: T, ...paths: K): Pick<T, Exclude<keyof T, K[number]>>; <T extends object, K extends keyof T>(object: T, ...paths: Many<K>[]): Omit<...>; <T extends object>(object: T, ...paths: Many<...>[]): Partial<...>; }",
          "optional": false
        },
        {
          "name": "omitBy",
          "type": "{ <T>(object: Dictionary<T>, predicate?: ValueKeyIteratee<T>): Dictionary<T>; <T>(object: NumericDictionary<T>, predicate?: ValueKeyIteratee<...>): NumericDictionary<...>; <T extends object>(object: T, predicate: ValueKeyIteratee<...>): Partial<...>; }",
          "optional": false
        },
        {
          "name": "pick",
          "type": "{ <T extends object, U extends keyof T>(object: T, ...props: Many<U>[]): Pick<T, U>; <T>(object: T, ...props: Many<PropertyPath>[]): Partial<T>; }",
          "optional": false
        },
        {
          "name": "pickBy",
          "type": "{ <T, S extends T>(object: Dictionary<T>, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>; <T, S extends T>(object: NumericDictionary<T>, predicate: ValueKeyIterateeTypeGuard<...>): NumericDictionary<...>; <T>(object: Dictionary<...>, predicate?: ValueKeyIteratee<...>): Dictionary<...>; <T>(object: Numeri...",
          "optional": false
        },
        {
          "name": "result",
          "type": "<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
          "optional": false
        },
        {
          "name": "set",
          "type": "{ <T extends object>(object: T, path: PropertyPath, value: any): T; <TResult>(object: object, path: PropertyPath, value: any): TResult; }",
          "optional": false
        },
        {
          "name": "setWith",
          "type": "{ <T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): TResult; }",
          "optional": false
        },
        {
          "name": "toPairs",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "toPairsIn",
          "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
          "optional": false
        },
        {
          "name": "transform",
          "type": "{ <T, TResult>(object: readonly T[], iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult; <T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): TResult; <T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<...>, accumula...",
          "optional": false
        },
        {
          "name": "unset",
          "type": "(object: any, path: PropertyPath) => boolean",
          "optional": false
        },
        {
          "name": "update",
          "type": "(object: object, path: PropertyPath, updater: (value: any) => any) => any",
          "optional": false
        },
        {
          "name": "updateWith",
          "type": "{ <T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): TResult; }",
          "optional": false
        },
        {
          "name": "values",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; (object: any): any[]; }",
          "optional": false
        },
        {
          "name": "valuesIn",
          "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; }",
          "optional": false
        },
        {
          "name": "chain",
          "type": "{ <TrapAny extends { __lodashAnyHack: any; }>(value: TrapAny): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <T extends null | undefined>(value: T): PrimitiveChain<...>; <T extends string>(value: T): StringChain<...>; (value: string): StringNullableChain; <T e...",
          "optional": false
        },
        {
          "name": "tap",
          "type": "<T>(value: T, interceptor: (value: T) => void) => T",
          "optional": false
        },
        {
          "name": "thru",
          "type": "<T, TResult>(value: T, interceptor: (value: T) => TResult) => TResult",
          "optional": false
        },
        {
          "name": "camelCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "capitalize",
          "type": "<T extends string>(string?: T) => string extends T ? string : Capitalize<Lowercase<T>>",
          "optional": false
        },
        {
          "name": "deburr",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "endsWith",
          "type": "(string?: string, target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "escape",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "escapeRegExp",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "kebabCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "lowerCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "lowerFirst",
          "type": "<T extends string = string>(string?: T) => Uncapitalize<T>",
          "optional": false
        },
        {
          "name": "pad",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padEnd",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "padStart",
          "type": "(string?: string, length?: number, chars?: string) => string",
          "optional": false
        },
        {
          "name": "parseInt",
          "type": "(string: string, radix?: number) => number",
          "optional": false
        },
        {
          "name": "repeat",
          "type": "(string?: string, n?: number) => string",
          "optional": false
        },
        {
          "name": "replace",
          "type": "{ (string: string, pattern: string | RegExp, replacement: string | ReplaceFunction): string; (pattern: string | RegExp, replacement: string | ReplaceFunction): string; }",
          "optional": false
        },
        {
          "name": "snakeCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "split",
          "type": "{ (string: string, separator?: string | RegExp, limit?: number): string[]; (string: string, index: string | number, guard: object): string[]; }",
          "optional": false
        },
        {
          "name": "startCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "startsWith",
          "type": "(string?: string, target?: string, position?: number) => boolean",
          "optional": false
        },
        {
          "name": "template",
          "type": "(string?: string, options?: TemplateOptions) => TemplateExecutor",
          "optional": false
        },
        {
          "name": "toLower",
          "type": "<T extends string = string>(string?: T) => Lowercase<T>",
          "optional": false
        },
        {
          "name": "toUpper",
          "type": "<T extends string = string>(string?: T) => Uppercase<T>",
          "optional": false
        },
        {
          "name": "trim",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "trimEnd",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "trimStart",
          "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
          "optional": false
        },
        {
          "name": "truncate",
          "type": "(string?: string, options?: TruncateOptions) => string",
          "optional": false
        },
        {
          "name": "unescape",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "upperCase",
          "type": "(string?: string) => string",
          "optional": false
        },
        {
          "name": "upperFirst",
          "type": "<T extends string = string>(string?: T) => Capitalize<T>",
          "optional": false
        },
        {
          "name": "words",
          "type": "{ (string?: string, pattern?: string | RegExp): string[]; (string: string, index: string | number, guard: object): string[]; }",
          "optional": false
        },
        {
          "name": "attempt",
          "type": "<TResult>(func: (...args: any[]) => TResult, ...args: any[]) => Error | TResult",
          "optional": false
        },
        {
          "name": "bindAll",
          "type": "<T>(object: T, ...methodNames: Many<string>[]) => T",
          "optional": false
        },
        {
          "name": "cond",
          "type": "{ <R>(pairs: CondPairNullary<R>[]): () => R; <T, R>(pairs: CondPairUnary<T, R>[]): (Target: T) => R; }",
          "optional": false
        },
        {
          "name": "conforms",
          "type": "<T>(source: ConformsPredicateObject<T>) => (value: T) => boolean",
          "optional": false
        },
        {
          "name": "constant",
          "type": "<T>(value: T) => () => T",
          "optional": false
        },
        {
          "name": "defaultTo",
          "type": "{ <T>(value: T, defaultValue: T): T; <T, TDefault>(value: T, defaultValue: TDefault): T | TDefault; }",
          "optional": false
        },
        {
          "name": "flow",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4...",
          "optional": false
        },
        {
          "name": "flowRight",
          "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2)...",
          "optional": false
        },
        {
          "name": "identity",
          "type": "{ <T>(value: T): T; (): undefined; }",
          "optional": false
        },
        {
          "name": "iteratee",
          "type": "{ <TFunction extends (...args: any[]) => any>(func: TFunction): TFunction; (func: string | number | symbol | object): (...args: any[]) => any; }",
          "optional": false
        },
        {
          "name": "matches",
          "type": "{ <T>(source: T): (value: any) => boolean; <T, V>(source: T): (value: V) => boolean; }",
          "optional": false
        },
        {
          "name": "matchesProperty",
          "type": "{ <T>(path: PropertyPath, srcValue: T): (value: any) => boolean; <T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean; }",
          "optional": false
        },
        {
          "name": "method",
          "type": "(path: PropertyPath, ...args: any[]) => (object: any) => any",
          "optional": false
        },
        {
          "name": "methodOf",
          "type": "(object: object, ...args: any[]) => (path: PropertyPath) => any",
          "optional": false
        },
        {
          "name": "mixin",
          "type": "{ <TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject; <TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashStatic; }",
          "optional": false
        },
        {
          "name": "noConflict",
          "type": "() => LoDashStatic",
          "optional": false
        },
        {
          "name": "noop",
          "type": "(...args: any[]) => void",
          "optional": false
        },
        {
          "name": "nthArg",
          "type": "(n?: number) => (...args: any[]) => any",
          "optional": false
        },
        {
          "name": "over",
          "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => (...args: any[]) => TResult[]",
          "optional": false
        },
        {
          "name": "overEvery",
          "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 & Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
          "optional": false
        },
        {
          "name": "overSome",
          "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 | Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
          "optional": false
        },
        {
          "name": "property",
          "type": "<TObj, TResult>(path: PropertyPath) => (obj: TObj) => TResult",
          "optional": false
        },
        {
          "name": "propertyOf",
          "type": "<T extends {}>(object: T) => (path: PropertyPath) => any",
          "optional": false
        },
        {
          "name": "range",
          "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
          "optional": false
        },
        {
          "name": "rangeRight",
          "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
          "optional": false
        },
        {
          "name": "runInContext",
          "type": "(context?: object) => LoDashStatic",
          "optional": false
        },
        {
          "name": "stubArray",
          "type": "() => any[]",
          "optional": false
        },
        {
          "name": "stubFalse",
          "type": "{ (): false; (): false; }",
          "optional": false
        },
        {
          "name": "stubObject",
          "type": "() => any",
          "optional": false
        },
        {
          "name": "stubString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "stubTrue",
          "type": "{ (): true; (): true; }",
          "optional": false
        },
        {
          "name": "times",
          "type": "{ <TResult>(n: number, iteratee: (num: number) => TResult): TResult[]; (n: number): number[]; }",
          "optional": false
        },
        {
          "name": "toPath",
          "type": "(value: any) => string[]",
          "optional": false
        },
        {
          "name": "uniqueId",
          "type": "(prefix?: string) => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function0",
      "type": "Function0<R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function1",
      "type": "Function1<T1, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function2",
      "type": "Function2<T1, T2, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function3",
      "type": "Function3<T1, T2, T3, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Function4",
      "type": "Function4<T1, T2, T3, T4, R>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Partial",
      "type": "Partial",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "PartialRight",
      "type": "PartialRight",
      "properties": [
        {
          "name": "placeholder",
          "type": "LoDashStatic",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ThrottleSettings",
      "type": "ThrottleSettings",
      "properties": [
        {
          "name": "leading",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "trailing",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ThrottleSettingsLeading",
      "type": "ThrottleSettingsLeading",
      "properties": [
        {
          "name": "trailing",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "FunctionBase",
      "type": "Function",
      "properties": [
        {
          "name": "apply",
          "type": "(this: Function, thisArg: any, argArray?: any) => any",
          "optional": false
        },
        {
          "name": "call",
          "type": "(this: Function, thisArg: any, ...argArray: any[]) => any",
          "optional": false
        },
        {
          "name": "bind",
          "type": "(this: Function, thisArg: any, ...argArray: any[]) => any",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "prototype",
          "type": "any",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": false
        },
        {
          "name": "arguments",
          "type": "any",
          "optional": false
        },
        {
          "name": "caller",
          "type": "Function",
          "optional": false
        },
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "__@hasInstance@19411",
          "type": "(value: any) => boolean",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CloneDeepWithCustomizer",
      "type": "CloneDeepWithCustomizer<TObject>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CloneWithCustomizer",
      "type": "CloneWithCustomizer<TValue, TResult>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CondPairNullary",
      "type": "CondPairNullary<R>",
      "properties": [
        {
          "name": "0",
          "type": "() => boolean",
          "optional": false
        },
        {
          "name": "1",
          "type": "() => R",
          "optional": false
        },
        {
          "name": "length",
          "type": "2",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
          "optional": false
        },
        {
          "name": "pop",
          "type": "() => (() => boolean) | (() => R)",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...items: ((() => boolean) | (() => R))[]) => number",
          "optional": false
        },
        {
          "name": "concat",
          "type": "{ (...items: ConcatArray<(() => boolean) | (() => R)>[]): ((() => boolean) | (() => R))[]; (...items: ((() => boolean) | (() => R) | ConcatArray<(() => boolean) | (() => R)>)[]): ((() => boolean) | (() => R))[]; }",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => string",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => ((() => boolean) | (() => R))[]",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => (() => boolean) | (() => R)",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => ((() => boolean) | (() => R))[]",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: (() => boolean) | (() => R), b: (() => boolean) | (() => R)) => number) => CondPairNullary<R>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "{ (start: number, deleteCount?: number): ((() => boolean) | (() => R))[]; (start: number, deleteCount: number, ...items: ((() => boolean) | (() => R))[]): ((() => boolean) | (() => R))[]; }",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: ((() => boolean) | (() => R))[]) => number",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "every",
          "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: an...",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any) => boolean",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(callbackfn: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => void, thisArg?: any) => void",
          "optional": false
        },
        {
          "name": "map",
          "type": "<U>(callbackfn: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => U, thisArg?: any) => U[]",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): S[]; (predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any): ((()...",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | (() => R), currentIndex: number, array: ((() => boolean) | (() => R))[]) => (() => boolean) | (() => R)): (() => boolean) | (() => R); (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | ...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | (() => R), currentIndex: number, array: ((() => boolean) | (() => R))[]) => (() => boolean) | (() => R)): (() => boolean) | (() => R); (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | ...",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): S; (predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any): (() => boo...",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any) => number",
          "optional": false
        },
        {
          "name": "fill",
          "type": "(value: (() => boolean) | (() => R), start?: number, end?: number) => CondPairNullary<R>",
          "optional": false
        },
        {
          "name": "copyWithin",
          "type": "(target: number, start: number, end?: number) => CondPairNullary<R>",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => ArrayIterator<[number, (() => boolean) | (() => R)]>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => ArrayIterator<number>",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => ArrayIterator<(() => boolean) | (() => R)>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "<U, This = undefined>(callback: (this: This, value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => U | readonly U[], thisArg?: This) => U[]",
          "optional": false
        },
        {
          "name": "flat",
          "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
          "optional": false
        },
        {
          "name": "__@iterator@4630",
          "type": "() => ArrayIterator<(() => boolean) | (() => R)>",
          "optional": false
        },
        {
          "name": "__@unscopables@4632",
          "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
          "optional": false
        },
        {
          "name": "at",
          "type": "(index: number) => (() => boolean) | (() => R)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "CondPairUnary",
      "type": "CondPairUnary<T, R>",
      "properties": [
        {
          "name": "0",
          "type": "(val: T) => boolean",
          "optional": false
        },
        {
          "name": "1",
          "type": "(val: T) => R",
          "optional": false
        },
        {
          "name": "length",
          "type": "2",
          "optional": false
        },
        {
          "name": "toString",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "toLocaleString",
          "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
          "optional": false
        },
        {
          "name": "pop",
          "type": "() => ((val: T) => boolean) | ((val: T) => R)",
          "optional": false
        },
        {
          "name": "push",
          "type": "(...items: (((val: T) => boolean) | ((val: T) => R))[]) => number",
          "optional": false
        },
        {
          "name": "concat",
          "type": "{ (...items: ConcatArray<((val: T) => boolean) | ((val: T) => R)>[]): (((val: T) => boolean) | ((val: T) => R))[]; (...items: (((val: T) => boolean) | ((val: T) => R) | ConcatArray<...>)[]): (((val: T) => boolean) | ((val: T) => R))[]; }",
          "optional": false
        },
        {
          "name": "join",
          "type": "(separator?: string) => string",
          "optional": false
        },
        {
          "name": "reverse",
          "type": "() => (((val: T) => boolean) | ((val: T) => R))[]",
          "optional": false
        },
        {
          "name": "shift",
          "type": "() => ((val: T) => boolean) | ((val: T) => R)",
          "optional": false
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => (((val: T) => boolean) | ((val: T) => R))[]",
          "optional": false
        },
        {
          "name": "sort",
          "type": "(compareFn?: (a: ((val: T) => boolean) | ((val: T) => R), b: ((val: T) => boolean) | ((val: T) => R)) => number) => CondPairUnary<T, R>",
          "optional": false
        },
        {
          "name": "splice",
          "type": "{ (start: number, deleteCount?: number): (((val: T) => boolean) | ((val: T) => R))[]; (start: number, deleteCount: number, ...items: (((val: T) => boolean) | ((val: T) => R))[]): (((val: T) => boolean) | ((val: T) => R))[]; }",
          "optional": false
        },
        {
          "name": "unshift",
          "type": "(...items: (((val: T) => boolean) | ((val: T) => R))[]) => number",
          "optional": false
        },
        {
          "name": "indexOf",
          "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "lastIndexOf",
          "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => number",
          "optional": false
        },
        {
          "name": "every",
          "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T...",
          "optional": false
        },
        {
          "name": "some",
          "type": "(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => unknown, thisArg?: any) => boolean",
          "optional": false
        },
        {
          "name": "forEach",
          "type": "(callbackfn: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => void, thisArg?: any) => void",
          "optional": false
        },
        {
          "name": "map",
          "type": "<U>(callbackfn: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => U, thisArg?: any) => U[]",
          "optional": false
        },
        {
          "name": "filter",
          "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): S[]; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boo...",
          "optional": false
        },
        {
          "name": "reduce",
          "type": "{ (callbackfn: (previousValue: ((val: T) => boolean) | ((val: T) => R), currentValue: ((val: T) => boolean) | ((val: T) => R), currentIndex: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => ((val: T) => boolean) | ((val: T) => R)): ((val: T) => boolean) | ((val: T) => R); (callbackfn: (previousValue: (...",
          "optional": false
        },
        {
          "name": "reduceRight",
          "type": "{ (callbackfn: (previousValue: ((val: T) => boolean) | ((val: T) => R), currentValue: ((val: T) => boolean) | ((val: T) => R), currentIndex: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => ((val: T) => boolean) | ((val: T) => R)): ((val: T) => boolean) | ((val: T) => R); (callbackfn: (previousValue: (...",
          "optional": false
        },
        {
          "name": "find",
          "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): S; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) ...",
          "optional": false
        },
        {
          "name": "findIndex",
          "type": "(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) | ((val: T) => R))[]) => unknown, thisArg?: any) => number",
          "optional": false
        },
        {
          "name": "fill",
          "type": "(value: ((val: T) => boolean) | ((val: T) => R), start?: number, end?: number) => CondPairUnary<T, R>",
          "optional": false
        },
        {
          "name": "copyWithin",
          "type": "(target: number, start: number, end?: number) => CondPairUnary<T, R>",
          "optional": false
        },
        {
          "name": "entries",
          "type": "() => ArrayIterator<[number, ((val: T) => boolean) | ((val: T) => R)]>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "() => ArrayIterator<number>",
          "optional": false
        },
        {
          "name": "values",
          "type": "() => ArrayIterator<((val: T) => boolean) | ((val: T) => R)>",
          "optional": false
        },
        {
          "name": "includes",
          "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => boolean",
          "optional": false
        },
        {
          "name": "flatMap",
          "type": "<U, This = undefined>(callback: (this: This, value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => U | readonly U[], thisArg?: This) => U[]",
          "optional": false
        },
        {
          "name": "flat",
          "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
          "optional": false
        },
        {
          "name": "__@iterator@4630",
          "type": "() => ArrayIterator<((val: T) => boolean) | ((val: T) => R)>",
          "optional": false
        },
        {
          "name": "__@unscopables@4632",
          "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
          "optional": false
        },
        {
          "name": "at",
          "type": "(index: number) => ((val: T) => boolean) | ((val: T) => R)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "EmptyObject",
      "type": "EmptyObject<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "EmptyObjectOf",
      "type": "EmptyObjectOf<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "IsEqualCustomizer",
      "type": "IsEqualCustomizer",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "isMatchWithCustomizer",
      "type": "isMatchWithCustomizer",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "AssignCustomizer",
      "type": "AssignCustomizer",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfArrayLikeByKey",
      "type": "GetFieldTypeOfArrayLikeByKey<T, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfStringByKey",
      "type": "GetFieldTypeOfStringByKey<T, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfNarrowedByKey",
      "type": "GetFieldTypeOfNarrowedByKey<T, K>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfNarrowedByDotPath",
      "type": "GetFieldTypeOfNarrowedByDotPath<T, P>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. Assumes P is a dot-delimited path.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfNarrowedByLcKR",
      "type": "GetFieldTypeOfNarrowedByLcKR<T, Lc, K, R>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. This is a piece of GetFieldTypeOfNarrowedByLKR logic,\nassuming that Lc isn't to be ignored, and does not end with dot.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfNarrowedByLKR",
      "type": "GetFieldTypeOfNarrowedByLKR<T, L, K, R>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. Assumes T has been narrowed; L is a dot-delimited path,\nand should be ignored if an empty string; K is a key name; and R is\na dot-delimetered path, to be ignored if an empty string. Also if\nL has a tail dot, or R has a front dot, these dots should be discarded,\nhowever when L or R is just a dot, they should be interpreted as empty\nkey name (rather than ignored).",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfNarrowed",
      "type": "GetFieldTypeOfNarrowed<T, X, XT>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. Assumes T has been narrowed.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfObject",
      "type": "GetFieldTypeOfObject<T, X, XT>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. Assumes T has been narrowed to an object type.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldTypeOfPrimitive",
      "type": "GetFieldTypeOfPrimitive<T, X, XT>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Internal. Assumes T has been narrowed to a primitive type.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "GetFieldType",
      "type": "GetFieldType<T, X, XT>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Deduces the type of value at the path P of type T,\nso that _.get<T, P>(t: T, p: P): GetFieldType<T, P>.\nXT specifies the exact meaning of X:\n- 'Path' (default) - X is a path type to be fully parsed;\n- 'DotPath - X is a dot-delimitered path, without square (indexing) brackets;\n- 'Key' - X is a simple key, and needs no parsing.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "MergeWithCustomizer",
      "type": "(value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "SetWithCustomizer",
      "type": "SetWithCustomizer<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "LoDashWrapper",
      "type": "LoDashWrapper<TValue>",
      "properties": [
        {
          "name": "toString",
          "type": "() => string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ReplaceFunction",
      "type": "ReplaceFunction",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TemplateOptions",
      "type": "TemplateOptions",
      "properties": [
        {
          "name": "sourceURL",
          "type": "string",
          "optional": true
        },
        {
          "name": "escape",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "evaluate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "imports",
          "type": "Dictionary<any>",
          "optional": true
        },
        {
          "name": "interpolate",
          "type": "RegExp",
          "optional": true
        },
        {
          "name": "variable",
          "type": "string",
          "optional": true
        }
      ],
      "extends": [
        "TemplateSettings"
      ],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TemplateExecutor",
      "type": "TemplateExecutor",
      "properties": [
        {
          "name": "source",
          "type": "string",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "TruncateOptions",
      "type": "TruncateOptions",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": true
        },
        {
          "name": "omission",
          "type": "string",
          "optional": true
        },
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "ConformsPredicateObject",
      "type": "ConformsPredicateObject<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "MixinOptions",
      "type": "MixinOptions",
      "properties": [
        {
          "name": "chain",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    }
  ],
  "classes": [],
  "constants": [
    {
      "name": "_.VERSION",
      "type": "string",
      "value": "\"4.14.191\"",
      "jsdoc": null,
      "isExported": true
    },
    {
      "name": "_.VERSION",
      "type": "string",
      "value": "\"4.14.191\"",
      "jsdoc": {
        "description": "The semantic version number.",
        "deprecated": false
      },
      "isExported": false
    },
    {
      "name": "_",
      "type": "LoDashStatic",
      "jsdoc": null,
      "isExported": false
    }
  ],
  "namespaces": [
    {
      "name": "_",
      "contents": {
        "functions": [],
        "enums": [],
        "types": [
          {
            "name": "LoDashStatic",
            "type": "LoDashStatic",
            "properties": [
              {
                "name": "VERSION",
                "type": "string",
                "optional": false
              },
              {
                "name": "templateSettings",
                "type": "TemplateSettings",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "<T>(array: List<T>, size?: number) => T[][]",
                "optional": false
              },
              {
                "name": "compact",
                "type": "<T>(array: List<T | Falsey>) => T[]",
                "optional": false
              },
              {
                "name": "concat",
                "type": "<T>(...values: Many<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "difference",
                "type": "<T>(array: List<T>, ...values: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "differenceBy",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, values3: List<...>, iteratee: ValueIteratee<...>)...",
                "optional": false
              },
              {
                "name": "differenceWith",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
                "optional": false
              },
              {
                "name": "drop",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "dropRight",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "dropRightWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "dropWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "fill",
                "type": "{ <T>(array: any[], value: T): T[]; <T>(array: List<any>, value: T): List<T>; <T, U>(array: U[], value: T, start?: number, end?: number): (T | U)[]; <T, U>(array: List<U>, value: T, start?: number, end?: number): List<...>; }",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "<T>(array: List<Many<T>>) => T[]",
                "optional": false
              },
              {
                "name": "flattenDeep",
                "type": "<T>(array: ListOfRecursiveArraysOrValues<T>) => Flat<T>[]",
                "optional": false
              },
              {
                "name": "flattenDepth",
                "type": "<T>(array: ListOfRecursiveArraysOrValues<T>, depth?: number) => T[]",
                "optional": false
              },
              {
                "name": "fromPairs",
                "type": "{ <T>(pairs: List<[PropertyName, T]>): Dictionary<T>; (pairs: List<any[]>): Dictionary<any>; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "<T>(array: List<T>, value: T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "initial",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "intersectionBy",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | ValueIteratee<...>)[]): T...",
                "optional": false
              },
              {
                "name": "intersectionWith",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
                "optional": false
              },
              {
                "name": "join",
                "type": "(array: List<any>, separator?: string) => string",
                "optional": false
              },
              {
                "name": "last",
                "type": "<T>(array: List<T>) => T",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "<T>(array: List<T>, value: T, fromIndex?: number | true) => number",
                "optional": false
              },
              {
                "name": "nth",
                "type": "<T>(array: List<T>, n?: number) => T",
                "optional": false
              },
              {
                "name": "pull",
                "type": "{ <T>(array: T[], ...values: T[]): T[]; <T>(array: List<T>, ...values: T[]): List<T>; }",
                "optional": false
              },
              {
                "name": "pullAll",
                "type": "{ <T>(array: T[], values?: List<T>): T[]; <T>(array: List<T>, values?: List<T>): List<T>; }",
                "optional": false
              },
              {
                "name": "pullAllBy",
                "type": "{ <T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, iteratee: ValueIteratee<...>): List<...>; }",
                "optional": false
              },
              {
                "name": "pullAllWith",
                "type": "{ <T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[]; <T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, comparator: Comparator2<...>): List<...>; }",
                "optional": false
              },
              {
                "name": "pullAt",
                "type": "{ <T>(array: T[], ...indexes: Many<number>[]): T[]; <T>(array: List<T>, ...indexes: Many<number>[]): List<T>; }",
                "optional": false
              },
              {
                "name": "remove",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "<TList extends List<any>>(array: TList) => TList",
                "optional": false
              },
              {
                "name": "slice",
                "type": "<T>(array: List<T>, start?: number, end?: number) => T[]",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "{ <T>(array: List<T>, value: T): number; <T>(array: List<T>, value: T): number; }",
                "optional": false
              },
              {
                "name": "sortedIndexBy",
                "type": "<T>(array: List<T>, value: T, iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedIndexOf",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndex",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexBy",
                "type": "<T>(array: List<T>, value: T, iteratee: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexOf",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedUniq",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "sortedUniqBy",
                "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "tail",
                "type": "{ <T extends unknown[]>(array: readonly [unknown, ...T]): T; <T>(array: List<T>): T[]; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "takeRight",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "takeRightWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "takeWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "union",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "unionBy",
                "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee?: ValueIteratee<...>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>,...",
                "optional": false
              },
              {
                "name": "unionWith",
                "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "uniqBy",
                "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "uniqWith",
                "type": "<T>(array: List<T>, comparator?: Comparator<T>) => T[]",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "<T>(array: T[][] | List<List<T>>) => T[][]",
                "optional": false
              },
              {
                "name": "unzipWith",
                "type": "{ <T, TResult>(array: List<List<T>>, iteratee: (...values: T[]) => TResult): TResult[]; <T>(array: List<List<T>>): T[][]; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "<T>(array: List<T>, ...values: T[]) => T[]",
                "optional": false
              },
              {
                "name": "xor",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "xorBy",
                "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...iteratee: (ValueIteratee<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "xorWith",
                "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ <T1, T2>(arrays1: List<T1>, arrays2: List<T2>): [T1, T2][]; <T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): [...][]; <T1, T2, T3, T4>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>): [...][]; <T1, T2, T3, T4, T5>(arrays1: List<...>, arrays2: List<...>, arrays3...",
                "optional": false
              },
              {
                "name": "zipObject",
                "type": "{ <T>(props: List<PropertyName>, values: List<T>): Dictionary<T>; (props?: List<PropertyName>): Dictionary<undefined>; }",
                "optional": false
              },
              {
                "name": "zipObjectDeep",
                "type": "(paths?: List<PropertyPath>, values?: List<any>) => object",
                "optional": false
              },
              {
                "name": "zipWith",
                "type": "{ <T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[]; <T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[]; <T1, T2, T3, TResult>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee: (value1: T1, value2: T2, value3:...",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<number>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "each",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "every",
                "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>): S[]; <T>(collection: List<...>, predicate?: ListIterateeCustom<...>): T[]; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<....",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <T>(collection: Dictionary<Many<T>> | NumericDictionary<Many<T>>): T[]; (collection: object): any[]; <T, TResult>(collection: List<T>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, iteratee: string): any[]; (colle...",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, i...",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>, depth?: number): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>, depth?: number): T...",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<T[]>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "includes",
                "type": "<T>(collection: Dictionary<T> | NumericDictionary<T>, target: T, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (collection: object, methodName: string, ...args: any[]): any[]; <TResult>(collection: object, method: (...args: any[]) => TResult, ...args: any[]): TResult[]; }",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>; <T extends object>(collection: T, iteratee?: ValueIterateeCustom<...>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <T extends readonly [unknown, ...unknown[]], TResult>(collection: T, iteratee: TupleIterator<T, TResult>): { [K in keyof T]: TResult; }; <T, TResult>(collection: T[], iteratee: ArrayIterator<...>): TResult[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T>(collection: Dictionary<.....",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "{ <T>(collection: List<T>, iteratees?: Many<ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">): T[]; <T>(collection: List<T>, iteratees?: Many<...>, orders?: Many<...>): T[]; <T extends object>(collection: T, iteratees?: Many<...>, orders?: Many<...>): T[keyof T][]; <T extends object>(collection: T,...",
                "optional": false
              },
              {
                "name": "partition",
                "type": "{ <T, U extends T>(collection: List<T>, callback: ValueIteratorTypeGuard<T, U>): [U[], Exclude<T, U>[]]; <T>(collection: List<T>, callback: ValueIteratee<...>): [...]; <T extends object>(collection: T, callback: ValueIteratee<...>): [...]; }",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
                "optional": false
              },
              {
                "name": "reject",
                "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): T[]; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<...>): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ <T>(collection: readonly [T, ...T[]]): T; <T>(collection: Dictionary<T> | NumericDictionary<T>): T; <T extends object>(collection: T): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "{ <T>(collection: Dictionary<T> | NumericDictionary<T>, n?: number): T[]; <T extends object>(collection: T, n?: number): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "{ <T>(collection: List<T>): T[]; <T extends object>(collection: T): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "(collection: string | object) => number",
                "optional": false
              },
              {
                "name": "some",
                "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "{ <T>(collection: List<T>, ...iteratees: Many<ListIteratee<T>>[]): T[]; <T extends object>(collection: T, ...iteratees: Many<ObjectIteratee<T>>[]): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "after",
                "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
                "optional": false
              },
              {
                "name": "ary",
                "type": "(func: (...args: any[]) => any, n?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "before",
                "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
                "optional": false
              },
              {
                "name": "bind",
                "type": "FunctionBind",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "FunctionBindKey",
                "optional": false
              },
              {
                "name": "curry",
                "type": "Curry",
                "optional": false
              },
              {
                "name": "curryRight",
                "type": "CurryRight",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "{ <T extends (...args: any) => any>(func: T, wait: number, options: DebounceSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<...>; }",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(func: (...args: any[]) => any, ...args: any[]) => number",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(func: (...args: any[]) => any, wait: number, ...args: any[]) => number",
                "optional": false
              },
              {
                "name": "flip",
                "type": "<T extends (...args: any) => any>(func: T) => T",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "{ <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction; Cache: MapCacheConstructor; }",
                "optional": false
              },
              {
                "name": "negate",
                "type": "<T extends any[]>(predicate: (...args: T) => boolean) => (...args: T) => boolean",
                "optional": false
              },
              {
                "name": "once",
                "type": "<T extends (...args: any) => any>(func: T) => T",
                "optional": false
              },
              {
                "name": "overArgs",
                "type": "(func: (...args: any[]) => any, ...transforms: Many<(...args: any[]) => any>[]) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "partial",
                "type": "Partial",
                "optional": false
              },
              {
                "name": "partialRight",
                "type": "PartialRight",
                "optional": false
              },
              {
                "name": "rearg",
                "type": "(func: (...args: any[]) => any, ...indexes: Many<number>[]) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(func: (...args: any[]) => any, start?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "spread",
                "type": "<TResult>(func: (...args: any[]) => TResult, start?: number) => (...args: any[]) => TResult",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "{ <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<...>; }",
                "optional": false
              },
              {
                "name": "unary",
                "type": "<T, TResult>(func: (arg1: T, ...args: any[]) => TResult) => (arg1: T) => TResult",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult) => (...args: TArgs[]) => TResult",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "<T>(value?: Many<T>) => T[]",
                "optional": false
              },
              {
                "name": "clone",
                "type": "<T>(value: T) => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "<T>(value: T) => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ <T>(value: T, customizer: CloneDeepWithCustomizer<T>): any; <T>(value: T): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult; <T, TResult>(value: T, customizer: CloneWithCustomizer<...>): T | TResult; <T>(value: T): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "<T>(object: T, source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "(value?: any) => value is IArguments",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "{ (value?: any): value is any[]; <T>(value?: any): value is any[]; }",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "(value?: any) => value is ArrayBuffer",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "{ <T extends { __lodashAnyHack: any; }>(t: T): boolean; (value: (...args: any[]) => any): value is never; (value: any): value is { length: number; }; }",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "{ <T extends { __lodashAnyHack: any; }>(value: T): boolean; (value: string | number | boolean | Function | ((...args: any[]) => any)): value is never; (value: any): value is object & { length: number; }; }",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "(value?: any) => value is boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "(value?: any) => value is Date",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "{ <T extends { __trapAny: any; }>(value?: T): boolean; (value: string): value is \"\"; (value: List<any> | Map<any, any> | Set<any>): boolean; (value: object): boolean; <T extends object>(value: T): value is EmptyObjectOf<...>; (value?: any): boolean; }",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(value: any, other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "(value: any) => value is Error",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "(value: any) => value is (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "(value?: any) => value is Map<any, any>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(object: object, source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(object: object, source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "(value: any) => value is (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "(value: any) => value is null",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "(value: any) => value is null",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "(value?: any) => value is number",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "(value?: any) => value is object",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "(value?: any) => value is RegExp",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "(value: any) => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "(value?: any) => value is Set<any>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "(value?: any) => value is string",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "(value: any) => value is symbol",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "(value: any) => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "(value: any) => value is undefined",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "(value?: any) => value is WeakMap<object, any>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "(value?: any) => value is WeakSet<object>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "{ <T>(value: Dictionary<T> | NumericDictionary<T>): T[]; <T>(value: T): T[keyof T][]; (): any[]; }",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "(value?: any) => any",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toString",
                "type": "(value: any) => string",
                "optional": false
              },
              {
                "name": "add",
                "type": "(augend: number, addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(dividend: number, divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "max",
                "type": "<T>(collection: List<T>) => T",
                "optional": false
              },
              {
                "name": "maxBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "mean",
                "type": "(collection: List<any>) => number",
                "optional": false
              },
              {
                "name": "meanBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "min",
                "type": "<T>(collection: List<T>) => T",
                "optional": false
              },
              {
                "name": "minBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplier: number, multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(minuend: number, subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "(collection: List<any>) => number",
                "optional": false
              },
              {
                "name": "sumBy",
                "type": "<T>(collection: List<T>, iteratee?: string | ((value: T) => number)) => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (number: number, lower: number, upper: number): number; (number: number, upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(n: number, start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; (min: number, max: number, floating?: boolean): number; (min: number, index: string | number, guard: object): number; }",
                "optional": false
              },
              {
                "name": "assign",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "assignIn",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "assignInWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "assignWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "at",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, ...props: PropertyPath[]): T[]; <T extends object>(object: T, ...props: Many<keyof T>[]): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "create",
                "type": "<T extends object, U extends object>(prototype: T, properties?: U) => T & U",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<...>; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullabl...",
                "optional": false
              },
              {
                "name": "defaultsDeep",
                "type": "(object: any, ...sources: any[]) => any",
                "optional": false
              },
              {
                "name": "entries",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "extend",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "extendWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "functions",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "<T extends {}>(object: any) => string[]",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [...]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject, path: TKey | [...], de...",
                "optional": false
              },
              {
                "name": "has",
                "type": "{ <T, K extends PropertyName>(object: T, path: K): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown; } & { ...; }; <T>(object: T, path: PropertyPath): boolean; }",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "<T>(object: T, path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "(object: object) => Dictionary<string>",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, interatee?: ValueIteratee<T>): Dictionary<string[]>; <T extends object>(object: T, interatee?: ValueIteratee<...>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(object: any, path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "(object?: any) => string[]",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "(object?: any) => string[]",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "{ <T>(object: List<T>, iteratee?: ListIteratee<T>): Dictionary<T>; <T extends object>(object: T, iteratee?: ObjectIteratee<T>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(obj: string, callback: StringIterator<TResult>): NumericDictionary<TResult>; <T, TResult>(array: T[], callback: ArrayIterator<T, TResult>): NumericDictionary<...>; <T extends object, TResult>(obj: T, callback: ObjectIterator<...>): { [P in keyof T]: TResult; }; <T>(obj: Dictionary<...> | NumericDictionar...",
                "optional": false
              },
              {
                "name": "merge",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "mergeWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, objec...",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <T extends object, K extends PropertyName[]>(object: T, ...paths: K): Pick<T, Exclude<keyof T, K[number]>>; <T extends object, K extends keyof T>(object: T, ...paths: Many<K>[]): Omit<...>; <T extends object>(object: T, ...paths: Many<...>[]): Partial<...>; }",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "{ <T>(object: Dictionary<T>, predicate?: ValueKeyIteratee<T>): Dictionary<T>; <T>(object: NumericDictionary<T>, predicate?: ValueKeyIteratee<...>): NumericDictionary<...>; <T extends object>(object: T, predicate: ValueKeyIteratee<...>): Partial<...>; }",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <T extends object, U extends keyof T>(object: T, ...props: Many<U>[]): Pick<T, U>; <T>(object: T, ...props: Many<PropertyPath>[]): Partial<T>; }",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <T, S extends T>(object: Dictionary<T>, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>; <T, S extends T>(object: NumericDictionary<T>, predicate: ValueKeyIterateeTypeGuard<...>): NumericDictionary<...>; <T>(object: Dictionary<...>, predicate?: ValueKeyIteratee<...>): Dictionary<...>; <T>(object: Numeri...",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ <T extends object>(object: T, path: PropertyPath, value: any): T; <TResult>(object: object, path: PropertyPath, value: any): TResult; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ <T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): TResult; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <T, TResult>(object: readonly T[], iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult; <T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): TResult; <T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<...>, accumula...",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(object: any, path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "update",
                "type": "(object: object, path: PropertyPath, updater: (value: any) => any) => any",
                "optional": false
              },
              {
                "name": "updateWith",
                "type": "{ <T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): TResult; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; (object: any): any[]; }",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "chain",
                "type": "{ <TrapAny extends { __lodashAnyHack: any; }>(value: TrapAny): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <T extends null | undefined>(value: T): PrimitiveChain<...>; <T extends string>(value: T): StringChain<...>; (value: string): StringNullableChain; <T e...",
                "optional": false
              },
              {
                "name": "tap",
                "type": "<T>(value: T, interceptor: (value: T) => void) => T",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<T, TResult>(value: T, interceptor: (value: T) => TResult) => TResult",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "<T extends string>(string?: T) => string extends T ? string : Capitalize<Lowercase<T>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(string?: string, target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "<T extends string = string>(string?: T) => Uncapitalize<T>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(string: string, radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(string?: string, n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (string: string, pattern: string | RegExp, replacement: string | ReplaceFunction): string; (pattern: string | RegExp, replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "{ (string: string, separator?: string | RegExp, limit?: number): string[]; (string: string, index: string | number, guard: object): string[]; }",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(string?: string, target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(string?: string, options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "<T extends string = string>(string?: T) => Lowercase<T>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "<T extends string = string>(string?: T) => Uppercase<T>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(string?: string, options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "<T extends string = string>(string?: T) => Capitalize<T>",
                "optional": false
              },
              {
                "name": "words",
                "type": "{ (string?: string, pattern?: string | RegExp): string[]; (string: string, index: string | number, guard: object): string[]; }",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(func: (...args: any[]) => TResult, ...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "<T>(object: T, ...methodNames: Many<string>[]) => T",
                "optional": false
              },
              {
                "name": "cond",
                "type": "{ <R>(pairs: CondPairNullary<R>[]): () => R; <T, R>(pairs: CondPairUnary<T, R>[]): (Target: T) => R; }",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "<T>(source: ConformsPredicateObject<T>) => (value: T) => boolean",
                "optional": false
              },
              {
                "name": "constant",
                "type": "<T>(value: T) => () => T",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ <T>(value: T, defaultValue: T): T; <T, TDefault>(value: T, defaultValue: TDefault): T | TDefault; }",
                "optional": false
              },
              {
                "name": "flow",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4...",
                "optional": false
              },
              {
                "name": "flowRight",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2)...",
                "optional": false
              },
              {
                "name": "identity",
                "type": "{ <T>(value: T): T; (): undefined; }",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "{ <TFunction extends (...args: any[]) => any>(func: TFunction): TFunction; (func: string | number | symbol | object): (...args: any[]) => any; }",
                "optional": false
              },
              {
                "name": "matches",
                "type": "{ <T>(source: T): (value: any) => boolean; <T, V>(source: T): (value: V) => boolean; }",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <T>(path: PropertyPath, srcValue: T): (value: any) => boolean; <T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(path: PropertyPath, ...args: any[]) => (object: any) => any",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(object: object, ...args: any[]) => (path: PropertyPath) => any",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ <TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject; <TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashStatic; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "(n?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => (...args: any[]) => TResult[]",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 & Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 | Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>(path: PropertyPath) => (obj: TObj) => TResult",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "<T extends {}>(object: T) => (path: PropertyPath) => any",
                "optional": false
              },
              {
                "name": "range",
                "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "(context?: object) => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(n: number, iteratee: (num: number) => TResult): TResult[]; (n: number): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "(value: any) => string[]",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "(prefix?: string) => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Omit",
            "type": "Omit<T, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PartialObject",
            "type": "Partial<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Many",
            "type": "Many<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ImpChain",
            "type": "ImpChain<T>",
            "properties": [
              {
                "name": "castArray",
                "type": "((() => Collection<any>) & (() => Collection<any>) & (() => Collection<any>) & (() => Collection<any>) & (() => Collection<string>)) | ... 4 more ... | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "chain",
                "type": "((() => CollectionChain<any>) & (() => FunctionChain<any>) & (() => ObjectChain<any>) & (() => PrimitiveChain<any>) & (<T extends string>() => StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "({ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; } & { (methodName: string, ...args: any[]): Collection<...>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<...>; } & { ...; }) | ... 4 more ... |...",
                "optional": false
              },
              {
                "name": "size",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "now",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(((thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => Function<...>)) | ... 4 more ... | ((thisArg: any, ...partials: any[]) => Function<...>)",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(((key: string, ...partials: any[]) => Function<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => Function<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => Function<...>)) | ... 4 more ... | ((key: string, ...partials: any[]) => Function<...>)",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(((...args: any[]) => Primitive<number>) & ((...args: any[]) => Primitive<number>) & ((...args: any[]) => Primitive<number>)) | ((...args: any[]) => Primitive<number>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive<...>) | ((...args: any[]) => Primitive...",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(((wait: number, ...args: any[]) => Primitive<number>) & ((wait: number, ...args: any[]) => Primitive<number>) & ((wait: number, ...args: any[]) => Primitive<number>)) | ... 4 more ... | ((wait: number, ...args: any[]) => Primitive<...>)",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "((<TArgs, TResult>(wrapper: (value: any[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>) & (<TArgs, TResult>(wrapper: (value: any, ...args: TArgs[]) => TResult) => Function<...>) & (<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => Function<...>)) | ... 4 more ......",
                "optional": false
              },
              {
                "name": "clone",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "({ (customizer: CloneDeepWithCustomizer<any[]>): any; (): any[]; } & { (customizer: CloneDeepWithCustomizer<any>): any; (): any; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "({ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<any[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<any[], TResult>): any[] | TResult; (): any[]; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(((source: any[]) => boolean) & ((source: ConformsPredicateObject<any>) => boolean) & ((source: string) => boolean)) | ((source: ConformsPredicateObject<T>) => boolean) | ((source: ConformsPredicateObject<...>) => boolean) | ((source: any[]) => boolean) | ((source: ConformsPredicateObject<...>) => boolean) | ((sourc...",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(((other: any, customizer?: IsEqualCustomizer) => boolean) & ((other: any, customizer?: IsEqualCustomizer) => boolean) & ((other: any, customizer?: IsEqualCustomizer) => boolean)) | ... 4 more ... | ((other: any, customizer?: IsEqualCustomizer) => boolean)",
                "optional": false
              },
              {
                "name": "isError",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(((source: object) => boolean) & ((source: object) => boolean) & ((source: object) => boolean)) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean) | ((source: object) => boolean)",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(((source: object, customizer: isMatchWithCustomizer) => boolean) & ((source: object, customizer: isMatchWithCustomizer) => boolean) & ((source: object, customizer: isMatchWithCustomizer) => boolean)) | ... 4 more ... | ((source: object, customizer: isMatchWithCustomizer) => boolean)",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "((() => this is LoDashImplicitWrapper<object>) & (() => this is LoDashImplicitWrapper<object>) & (() => this is LoDashImplicitWrapper<object>)) | ... 4 more ... | (() => this is LoDashImplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isString",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "((() => boolean) & (() => boolean) & (() => boolean)) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean) | (() => boolean)",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(((other: any) => boolean) & ((other: any) => boolean) & ((other: any) => boolean)) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean) | ((other: any) => boolean)",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "((() => Object<any>) & (() => Object<any>) & (() => Object<any>)) | (() => Object<any>) | (() => Object<any>) | (() => Object<any>) | (() => Object<any>) | (() => Object<...>)",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "add",
                "type": "(((addend: number) => number) & ((addend: number) => number) & ((addend: number) => number)) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number) | ((addend: number) => number)",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(((divisor: number) => number) & ((divisor: number) => number) & ((divisor: number) => number)) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number) | ((divisor: number) => number)",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
                "optional": false
              },
              {
                "name": "mean",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(((multiplicand: number) => number) & ((multiplicand: number) => number) & ((multiplicand: number) => number)) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number) | ((multiplicand: number) => number)",
                "optional": false
              },
              {
                "name": "round",
                "type": "(((precision?: number) => number) & ((precision?: number) => number) & ((precision?: number) => number)) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number) | ((precision?: number) => number)",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(((subtrahend: number) => number) & ((subtrahend: number) => number) & ((subtrahend: number) => number)) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number) | ((subtrahend: number) => number)",
                "optional": false
              },
              {
                "name": "sum",
                "type": "((() => number) & (() => number) & (() => number)) | (() => number) | (() => number) | (() => number) | (() => number) | (() => number)",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "({ (lower: number, upper: number): number; (upper: number): number; } & { (lower: number, upper: number): number; (upper: number): number; } & { (lower: number, upper: number): number; (upper: number): number; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(((start: number, end?: number) => boolean) & ((start: number, end?: number) => boolean) & ((start: number, end?: number) => boolean)) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ((start: number, end?: number) => boolean) | ...",
                "optional": false
              },
              {
                "name": "random",
                "type": "({ (floating?: boolean): number; (max: number, floating?: boolean): number; } & { (floating?: boolean): number; (max: number, floating?: boolean): number; } & { (floating?: boolean): number; (max: number, floating?: boolean): number; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>)) | ... 4 more ... | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, any]>)) | ... 4 more ... | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(((predicate?: ObjectIteratee<any[]>) => string) & ((predicate?: ObjectIteratee<any>) => string) & ((predicate?: ObjectIteratee<string>) => string)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => string)",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(((predicate?: ObjectIteratee<any[]>) => string) & ((predicate?: ObjectIteratee<any>) => string) & ((predicate?: ObjectIteratee<string>) => string)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => string)",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>) & ((iteratee?: ObjectIterator<...>) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ...",
                "optional": false
              },
              {
                "name": "functions",
                "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "has",
                "type": "(((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean)) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean)",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean) & ((path: PropertyPath) => boolean)) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean) | ((path: PropertyPath) => boolean)",
                "optional": false
              },
              {
                "name": "invert",
                "type": "((() => Object<Dictionary<string>>) & (() => Object<Dictionary<string>>) & (() => Object<Dictionary<string>>)) | (() => Object<Dictionary<...>>) | (() => Object<...>) | (() => Object<...>) | (() => Object<...>) | (() => Object<...>)",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(((path: PropertyPath, ...args: any[]) => any) & ((path: PropertyPath, ...args: any[]) => any) & ((path: PropertyPath, ...args: any[]) => any)) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...args: any[]) => any) | ((path: PropertyPath, ...ar...",
                "optional": false
              },
              {
                "name": "keys",
                "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "result",
                "type": "((<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult)) | ... 4 more ....",
                "optional": false
              },
              {
                "name": "set",
                "type": "({ (path: PropertyPath, value: any): Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "({ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<any[]>): Collection<any> & Function<any> & Object<...> & Primitive<...> & String<...>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, string]>)) | (() => Collection<[string, T extends Dictionary<...> ? U : T extends NumericDictionary<...> ? V : any]>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<....",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "((() => Collection<[string, any]>) & (() => Collection<[string, any]>) & (() => Collection<[string, string]>)) | (() => Collection<[string, T extends Dictionary<...> ? U : T extends NumericDictionary<...> ? V : any]>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<....",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(((path: PropertyPath) => Primitive<boolean>) & ((path: PropertyPath) => Primitive<boolean>) & ((path: PropertyPath) => Primitive<...>)) | ... 4 more ... | ((path: PropertyPath) => Primitive<...>)",
                "optional": false
              },
              {
                "name": "update",
                "type": "(((path: PropertyPath, updater: (value: any) => any) => Object<any>) & ((path: PropertyPath, updater: (value: any) => any) => Object<any>) & ((path: PropertyPath, updater: (value: any) => any) => Object<...>)) | ... 4 more ... | ((path: PropertyPath, updater: (value: any) => any) => Object<...>)",
                "optional": false
              },
              {
                "name": "commit",
                "type": "((() => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & (() => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & (() => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | (() => Primitive<...>)",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(((value: unknown) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((value: unknown) => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & ((value: unknown) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ((value: unknown) => P...",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "((() => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & (() => Collection<any> & Function<...> & Object<...> & Primitive<...> & String<...>) & (() => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | (() => Primitive<...>)",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "value",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(((interceptor: (value: any[]) => void) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((interceptor: (value: any) => void) => Collection<...> & ... 3 more ... & String<...>) & ((interceptor: (value: string) => void) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 m...",
                "optional": false
              },
              {
                "name": "thru",
                "type": "((<TResult>(interceptor: (value: any[]) => TResult) => ImpChain<TResult>) & (<TResult>(interceptor: (value: any) => TResult) => ImpChain<TResult>) & (<TResult>(interceptor: (value: string) => TResult) => ImpChain<...>)) | ... 4 more ... | (<TResult>(interceptor: (value: T) => TResult) => ImpChain<...>)",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "((() => never) & (() => string) & (() => string)) | (() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>) | (() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? string & T : never>>) | (() => never) | (() => string extends T ? T & string : Capitalize<Lo...",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean)) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((t...",
                "optional": false
              },
              {
                "name": "escape",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "((() => string) & (() => string) & (() => Uncapitalize<string>)) | (() => T extends string ? Uncapitalize<T> : string) | (() => T extends string ? Uncapitalize<string & T> : string) | (() => string) | (() => T extends string ? Uncapitalize<string & T> : string) | (() => T extends string ? Uncapitalize<T> : string)",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string) & ((length?: number, chars?: string) => string)) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: string) => string) | ((length?: number, chars?: ...",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(((radix?: number) => number) & ((radix?: number) => number) & ((radix?: number) => number)) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number) | ((radix?: number) => number)",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(((n?: number) => string) & ((n?: number) => string) & ((n?: number) => string)) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string) | ((n?: number) => string)",
                "optional": false
              },
              {
                "name": "replace",
                "type": "({ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "split",
                "type": "(((separator?: string | RegExp, limit?: number) => Collection<string>) & ((separator?: string | RegExp, limit?: number) => Collection<string>) & ((separator?: string | RegExp, limit?: number) => Collection<...>)) | ... 4 more ... | ((separator?: string | RegExp, limit?: number) => Collection<...>)",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean) & ((target?: string, position?: number) => boolean)) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((target?: string, position?: number) => boolean) | ((t...",
                "optional": false
              },
              {
                "name": "template",
                "type": "(((options?: TemplateOptions) => TemplateExecutor) & ((options?: TemplateOptions) => TemplateExecutor) & ((options?: TemplateOptions) => TemplateExecutor)) | ... 4 more ... | ((options?: TemplateOptions) => TemplateExecutor)",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "((() => string) & (() => string) & (() => Lowercase<string>)) | (() => T extends string ? Lowercase<T> : string) | (() => T extends string ? Lowercase<string & T> : string) | (() => string) | (() => T extends string ? Lowercase<string & T> : string) | (() => T extends string ? Lowercase<T> : string)",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "((() => string) & (() => string) & (() => Uppercase<string>)) | (() => T extends string ? Uppercase<T> : string) | (() => T extends string ? Uppercase<string & T> : string) | (() => string) | (() => T extends string ? Uppercase<string & T> : string) | (() => T extends string ? Uppercase<T> : string)",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(((chars?: string) => string) & ((chars?: string) => string) & ((chars?: string) => string)) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string) | ((chars?: string) => string)",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(((options?: TruncateOptions) => string) & ((options?: TruncateOptions) => string) & ((options?: TruncateOptions) => string)) | ... 4 more ... | ((options?: TruncateOptions) => string)",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "((() => string) & (() => string) & (() => Capitalize<string>)) | (() => T extends string ? Capitalize<T> : string) | (() => T extends string ? Capitalize<string & T> : string) | (() => string) | (() => T extends string ? Capitalize<string & T> : string) | (() => T extends string ? Capitalize<T> : string)",
                "optional": false
              },
              {
                "name": "words",
                "type": "(((pattern?: string | RegExp) => Collection<string>) & ((pattern?: string | RegExp) => Collection<string>) & ((pattern?: string | RegExp) => Collection<...>)) | ... 4 more ... | ((pattern?: string | RegExp) => Collection<...>)",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "((<TResult>(...args: any[]) => Error | TResult) & (<TResult>(...args: any[]) => Error | TResult) & (<TResult>(...args: any[]) => Error | TResult)) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: any[]) => Error | TResult) | (<TResult>(...args: a...",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(((...methodNames: Many<string>[]) => Collection<any> & Function<any> & Object<any> & Primitive<any> & String<string>) & ((...methodNames: Many<...>[]) => Collection<...> & ... 3 more ... & String<...>) & ((...methodNames: Many<...>[]) => Collection<...> & ... 3 more ... & String<...>)) | ... 4 more ... | ((...metho...",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "((() => Function<(value: any[]) => boolean>) & (() => Function<(value: ConformsPredicateObject<any>) => boolean>) & (() => Function<(value: string) => boolean>)) | ... 4 more ... | (() => Function<...>)",
                "optional": false
              },
              {
                "name": "constant",
                "type": "((() => Function<() => any[]>) & (() => Function<() => any>) & (() => Function<() => string>)) | (() => Function<() => T>) | (() => Function<() => T>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>)",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "({ (defaultValue: any[]): any[]; <TDefault>(defaultValue: TDefault): any[] | TDefault; } & { (defaultValue: any): any; <TDefault>(defaultValue: TDefault): any; } & { (defaultValue: string): string; <TDefault>(defaultValue: TDefault): string | TDefault; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "matches",
                "type": "((<V>() => Function<(value: V) => boolean>) & (<V>() => Function<(value: V) => boolean>) & (<V>() => Function<(value: V) => boolean>)) | (<V>() => Function<(value: V) => boolean>) | (<V>() => Function<...>) | (<V>() => Function<...>) | (<V>() => Function<...>) | (<V>() => Function<...>)",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "({ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(((...args: any[]) => Function<(object: any) => any>) & ((...args: any[]) => Function<(object: any) => any>) & ((...args: any[]) => Function<(object: any) => any>)) | ... 4 more ... | ((...args: any[]) => Function<...>)",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(((...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashImplicitWrapper<...>)) | ... 4 more ... | ((...args: any[]) => LoDashImplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "({ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Collection<any> & Function<any> & Object<any> & Primitive<...> & String<...>; (options?: MixinOptions): LoDashImplicitWrapper<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "((() => LoDashStatic) & (() => LoDashStatic) & (() => LoDashStatic)) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic)",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(((...args: any[]) => void) & ((...args: any[]) => void) & ((...args: any[]) => void)) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void) | ((...args: any[]) => void)",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "((() => Function<(...args: any[]) => any>) & (() => Function<(...args: any[]) => any>) & (() => Function<(...args: any[]) => any>)) | (() => Function<(...args: any[]) => any>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>) | (() => Function<...>)",
                "optional": false
              },
              {
                "name": "property",
                "type": "((<TObj, TResult>() => Function<(obj: TObj) => TResult>) & (<TObj, TResult>() => Function<(obj: TObj) => TResult>) & (<TObj, TResult>() => Function<(obj: TObj) => TResult>)) | ... 4 more ... | (<TObj, TResult>() => Function<...>)",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "((() => LoDashImplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashImplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashImplicitWrapper<...>)) | ... 4 more ... | (() => LoDashImplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "range",
                "type": "(((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>)) | ... 4 more ... | ((end?: number, step?: number) => Collection<...>)",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>) & ((end?: number, step?: number) => Collection<number>)) | ... 4 more ... | ((end?: number, step?: number) => Collection<...>)",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "((() => LoDashStatic) & (() => LoDashStatic) & (() => LoDashStatic)) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic) | (() => LoDashStatic)",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "((() => any[]) & (() => any[]) & (() => any[])) | (() => any[]) | (() => any[]) | (() => any[]) | (() => any[]) | (() => any[])",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "({ (): false; (): false; } & { (): false; (): false; } & { (): false; (): false; }) | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; } | { (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "((() => any) & (() => any) & (() => any)) | (() => any) | (() => any) | (() => any) | (() => any) | (() => any)",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "({ (): true; (): true; } & { (): true; (): true; } & { (): true; (): true; }) | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; } | { (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "({ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; } & { <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; } & { <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "((() => Collection<string>) & (() => Collection<string>) & (() => Collection<string>)) | (() => Collection<string>) | (() => Collection<string>) | (() => Collection<...>) | (() => Collection<...>) | (() => Collection<...>)",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "((() => string) & (() => string) & (() => string)) | (() => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ExpChain",
            "type": "ExpChain<T>",
            "properties": [
              {
                "name": "castArray",
                "type": "((() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "({ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "now",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(((thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((thisArg: any, ...partials: any[]) => FunctionChain<...>)) | ... 4 more ... | ((thisArg: any, ...partials: any[]) => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(((key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>) & ((key: string, ...partials: any[]) => FunctionChain<...>)) | ... 4 more ... | ((key: string, ...partials: any[]) => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(((...args: any[]) => PrimitiveChain<number>) & ((...args: any[]) => PrimitiveChain<number>) & ((...args: any[]) => PrimitiveChain<number>)) | ... 4 more ... | ((...args: any[]) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(((wait: number, ...args: any[]) => PrimitiveChain<number>) & ((wait: number, ...args: any[]) => PrimitiveChain<number>) & ((wait: number, ...args: any[]) => PrimitiveChain<...>)) | ... 4 more ... | ((wait: number, ...args: any[]) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "((<TArgs, TResult>(wrapper: (value: any[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>) & (<TArgs, TResult>(wrapper: (value: any, ...args: TArgs[]) => TResult) => FunctionChain<...>) & (<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<...>)) |...",
                "optional": false
              },
              {
                "name": "clone",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "({ (customizer: CloneDeepWithCustomizer<any[]>): LoDashExplicitWrapper<any>; (): CollectionChain<any> & FunctionChain<...> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "({ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<any[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): CollectionChain<...> & ... 3 more ... & StringChain<...>; } & { ...; } & { ...; }) | ... 4 mor...",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(((source: any[]) => PrimitiveChain<boolean>) & ((source: ConformsPredicateObject<any>) => PrimitiveChain<boolean>) & ((source: string) => PrimitiveChain<...>)) | ... 4 more ... | ((source: ConformsPredicateObject<...>) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>) & ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>) & ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>)) | ... 4 more ... | ((other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isError",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(((source: object) => PrimitiveChain<boolean>) & ((source: object) => PrimitiveChain<boolean>) & ((source: object) => PrimitiveChain<boolean>)) | ... 4 more ... | ((source: object) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>) & ((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<...>) & ((source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<...>)) | ... 4 more ... | ((source: object, customizer: isMatchWithCustomizer) => P...",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isString",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "((() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>) & (() => PrimitiveChain<boolean>)) | (() => PrimitiveChain<boolean>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>) & ((other: any) => PrimitiveChain<boolean>)) | ... 4 more ... | ((other: any) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "((() => ObjectChain<any>) & (() => ObjectChain<any>) & (() => ObjectChain<any>)) | (() => ObjectChain<any>) | (() => ObjectChain<any>) | (() => ObjectChain<...>) | (() => ObjectChain<...>) | (() => ObjectChain<...>)",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "add",
                "type": "(((addend: number) => PrimitiveChain<number>) & ((addend: number) => PrimitiveChain<number>) & ((addend: number) => PrimitiveChain<number>)) | ... 4 more ... | ((addend: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(((divisor: number) => PrimitiveChain<number>) & ((divisor: number) => PrimitiveChain<number>) & ((divisor: number) => PrimitiveChain<number>)) | ... 4 more ... | ((divisor: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "mean",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(((multiplicand: number) => PrimitiveChain<number>) & ((multiplicand: number) => PrimitiveChain<number>) & ((multiplicand: number) => PrimitiveChain<number>)) | ... 4 more ... | ((multiplicand: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "round",
                "type": "(((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>) & ((precision?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((precision?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(((subtrahend: number) => PrimitiveChain<number>) & ((subtrahend: number) => PrimitiveChain<number>) & ((subtrahend: number) => PrimitiveChain<number>)) | ... 4 more ... | ((subtrahend: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "sum",
                "type": "((() => PrimitiveChain<number>) & (() => PrimitiveChain<number>) & (() => PrimitiveChain<number>)) | (() => PrimitiveChain<number>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>) | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "({ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; } & { (lower: number, upper: number): PrimitiveChain<...>; (upper: number): PrimitiveChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(((start: number, end?: number) => PrimitiveChain<boolean>) & ((start: number, end?: number) => PrimitiveChain<boolean>) & ((start: number, end?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((start: number, end?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "random",
                "type": "({ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; } & { (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<...>)) | ... 4 more ... | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(((predicate?: ObjectIteratee<any[]>) => StringNullableChain) & ((predicate?: ObjectIteratee<any>) => StringNullableChain) & ((predicate?: ObjectIteratee<...>) => StringNullableChain)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => StringNullableChain)",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(((predicate?: ObjectIteratee<any[]>) => StringNullableChain) & ((predicate?: ObjectIteratee<any>) => StringNullableChain) & ((predicate?: ObjectIteratee<...>) => StringNullableChain)) | ... 4 more ... | ((predicate?: ObjectIteratee<...>) => StringNullableChain)",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(((iteratee?: ObjectIterator<any[], any>) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<...> & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((iteratee?: ObjectIterator<...>) => CollectionChain<...> & ... 3 more...",
                "optional": false
              },
              {
                "name": "functions",
                "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "has",
                "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "invert",
                "type": "((() => ObjectChain<Dictionary<string>>) & (() => ObjectChain<Dictionary<string>>) & (() => ObjectChain<Dictionary<string>>)) | ... 4 more ... | (() => ObjectChain<...>)",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>) & ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>) & ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<...>)) | ... 4 more ... | ((path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "keys",
                "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "result",
                "type": "((<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<...>) & (<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain...",
                "optional": false
              },
              {
                "name": "set",
                "type": "({ (path: PropertyPath, value: any): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "({ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<any[]>): CollectionChain<any> & FunctionChain<any> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; } & { ...; } & { ...; }) | ... 4 more ... |...",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, string]>)) | ... 4 more ... | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "((() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, any]>) & (() => CollectionChain<[string, string]>)) | ... 4 more ... | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<boolean>) & ((path: PropertyPath) => PrimitiveChain<...>)) | ... 4 more ... | ((path: PropertyPath) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "update",
                "type": "(((path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>) & ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>) & ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>)) | ... 4 more ... | ((path: PropertyPath, updater: (value: any) => any) => ObjectChain<...>)",
                "optional": false
              },
              {
                "name": "chain",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "commit",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(((value: unknown) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & ((value: unknown) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((value: unknown) => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | ((value...",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "value",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "((() => any[]) & (() => any) & (() => string)) | (() => T) | (() => T) | (() => unknown[]) | (() => T) | (() => T)",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(((interceptor: (value: any[]) => void) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>) & ((interceptor: (value: any) => void) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((interceptor: (value: string) => void) => CollectionChain<...> & ......",
                "optional": false
              },
              {
                "name": "thru",
                "type": "((<TResult>(interceptor: (value: any[]) => TResult) => ExpChain<TResult>) & (<TResult>(interceptor: (value: any) => TResult) => ExpChain<TResult>) & (<TResult>(interceptor: (value: string) => TResult) => ExpChain<...>)) | ... 4 more ... | (<TResult>(interceptor: (value: T) => TResult) => ExpChain<...>)",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "((() => StringChain<never>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((target?: string, position?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "escape",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Uncapitalize<string>>)) | (() => StringChain<T extends string ? Uncapitalize<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<string>) & ((length?: number, chars?: string) => StringChain<...>)) | ... 4 more ... | ((length?: number, chars?: string) => StringChain<...>)",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(((radix?: number) => PrimitiveChain<number>) & ((radix?: number) => PrimitiveChain<number>) & ((radix?: number) => PrimitiveChain<number>)) | ... 4 more ... | ((radix?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(((n?: number) => StringChain<string>) & ((n?: number) => StringChain<string>) & ((n?: number) => StringChain<string>)) | ((n?: number) => StringChain<string>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>) | ((n?: number) => StringChain<...>)",
                "optional": false
              },
              {
                "name": "replace",
                "type": "({ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "split",
                "type": "(((separator?: string | RegExp, limit?: number) => CollectionChain<string>) & ((separator?: string | RegExp, limit?: number) => CollectionChain<string>) & ((separator?: string | RegExp, limit?: number) => CollectionChain<...>)) | ... 4 more ... | ((separator?: string | RegExp, limit?: number) => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<boolean>) & ((target?: string, position?: number) => PrimitiveChain<...>)) | ... 4 more ... | ((target?: string, position?: number) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "template",
                "type": "(((options?: TemplateOptions) => FunctionChain<TemplateExecutor>) & ((options?: TemplateOptions) => FunctionChain<TemplateExecutor>) & ((options?: TemplateOptions) => FunctionChain<...>)) | ... 4 more ... | ((options?: TemplateOptions) => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Lowercase<string>>)) | (() => StringChain<T extends string ? Lowercase<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Uppercase<string>>)) | (() => StringChain<T extends string ? Uppercase<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>) & ((chars?: string) => StringChain<string>)) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) => StringChain<...>) | ((chars?: string) =...",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(((options?: TruncateOptions) => StringChain<string>) & ((options?: TruncateOptions) => StringChain<string>) & ((options?: TruncateOptions) => StringChain<...>)) | ... 4 more ... | ((options?: TruncateOptions) => StringChain<...>)",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<Capitalize<string>>)) | (() => StringChain<T extends string ? Capitalize<T> : string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "words",
                "type": "(((pattern?: string | RegExp) => CollectionChain<string>) & ((pattern?: string | RegExp) => CollectionChain<string>) & ((pattern?: string | RegExp) => CollectionChain<...>)) | ... 4 more ... | ((pattern?: string | RegExp) => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "((<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>) & (<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>) & (<TResult>(...args: any[]) => ObjectChain<...> | ExpChain<...>)) | ... 4 more ... | (<TResult>(...args: any[]) => ObjectChain<...> | ExpChain<...>)",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(((...methodNames: Many<string>[]) => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>) & ((...methodNames: Many<...>[]) => CollectionChain<...> & ... 3 more ... & StringChain<...>) & ((...methodNames: Many<...>[]) => CollectionChain<...> & ... 3 more ... & String...",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "((() => FunctionChain<(value: any[]) => boolean>) & (() => FunctionChain<(value: ConformsPredicateObject<any>) => boolean>) & (() => FunctionChain<...>)) | ... 4 more ... | (() => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "constant",
                "type": "((() => FunctionChain<() => any[]>) & (() => FunctionChain<() => any>) & (() => FunctionChain<() => string>)) | (() => FunctionChain<() => T>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "({ (defaultValue: any[]): CollectionChain<any>; <TDefault>(defaultValue: TDefault): CollectionChain<any> | ExpChain<TDefault>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "((() => CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<string>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>) & (() => CollectionChain<...> & ... 3 more ... & StringChain<...>)) | ... 4 more ... | (() => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "matches",
                "type": "((<V>() => FunctionChain<(value: V) => boolean>) & (<V>() => FunctionChain<(value: V) => boolean>) & (<V>() => FunctionChain<(value: V) => boolean>)) | ... 4 more ... | (<V>() => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "({ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(((...args: any[]) => FunctionChain<(object: any) => any>) & ((...args: any[]) => FunctionChain<(object: any) => any>) & ((...args: any[]) => FunctionChain<(object: any) => any>)) | ... 4 more ... | ((...args: any[]) => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(((...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>) & ((...args: any[]) => LoDashExplicitWrapper<...>)) | ... 4 more ... | ((...args: any[]) => LoDashExplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "({ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): CollectionChain<any> & FunctionChain<any> & ObjectChain<...> & PrimitiveChain<...> & StringChain<...>; (options?: MixinOptions): LoDashExplicitWrapper<...>; } & { ...; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "((() => LoDashExplicitWrapper<LoDashStatic>) & (() => LoDashExplicitWrapper<LoDashStatic>) & (() => LoDashExplicitWrapper<...>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(((...args: any[]) => PrimitiveChain<undefined>) & ((...args: any[]) => PrimitiveChain<undefined>) & ((...args: any[]) => PrimitiveChain<undefined>)) | ... 4 more ... | ((...args: any[]) => PrimitiveChain<...>)",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "((() => FunctionChain<(...args: any[]) => any>) & (() => FunctionChain<(...args: any[]) => any>) & (() => FunctionChain<(...args: any[]) => any>)) | (() => FunctionChain<(...args: any[]) => any>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>) | (() => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "property",
                "type": "((<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>) & (<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>) & (<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>)) | ... 4 more ... | (<TObj, TResult>() => FunctionChain<...>)",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "((() => LoDashExplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashExplicitWrapper<(path: PropertyPath) => any>) & (() => LoDashExplicitWrapper<...>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "range",
                "type": "(((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<...>)) | ... 4 more ... | ((end?: number, step?: number) => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<number>) & ((end?: number, step?: number) => CollectionChain<...>)) | ... 4 more ... | ((end?: number, step?: number) => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "((() => CollectionChain<any>) & (() => CollectionChain<any>) & (() => CollectionChain<any>)) | (() => CollectionChain<any>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "({ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; } & { (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "((() => LoDashExplicitWrapper<any>) & (() => LoDashExplicitWrapper<any>) & (() => LoDashExplicitWrapper<any>)) | ... 4 more ... | (() => LoDashExplicitWrapper<...>)",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "({ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; } & { (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "({ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; } & { <TResult>(iteratee: (num: number) => TResult): CollectionChain<...>; (): CollectionChain<...>; } & { ...; }) | ... 4 more ... | { ...; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "((() => CollectionChain<string>) & (() => CollectionChain<string>) & (() => CollectionChain<string>)) | (() => CollectionChain<string>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>) | (() => CollectionChain<...>)",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "((() => StringChain<string>) & (() => StringChain<string>) & (() => StringChain<string>)) | (() => StringChain<string>) | (() => StringChain<string>) | (() => StringChain<...>) | (() => StringChain<...>) | (() => StringChain<...>)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TemplateSettings",
            "type": "TemplateSettings",
            "properties": [
              {
                "name": "escape",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "evaluate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "imports",
                "type": "Dictionary<any>",
                "optional": true
              },
              {
                "name": "interpolate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "variable",
                "type": "string",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": {
              "description": "By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n(ERB). Change the following template settings to use alternative delimiters.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "MapCache",
            "type": "MapCache",
            "properties": [
              {
                "name": "delete",
                "type": "(key: any) => boolean",
                "optional": false
              },
              {
                "name": "get",
                "type": "(key: any) => any",
                "optional": false
              },
              {
                "name": "has",
                "type": "(key: any) => boolean",
                "optional": false
              },
              {
                "name": "set",
                "type": "(key: any, value: any) => MapCache",
                "optional": false
              },
              {
                "name": "clear",
                "type": "() => void",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": {
              "description": "Creates a cache object to store key/value pairs.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "MapCacheConstructor",
            "type": "MapCacheConstructor",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Collection",
            "type": "Collection<T>",
            "properties": [
              {
                "name": "pop",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...items: T[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: T, b: T) => number) => Collection<T>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "(start: number, deleteCount?: number, ...items: T[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: T[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "(size?: number) => Collection<T[]>",
                "optional": false
              },
              {
                "name": "compact",
                "type": "() => Collection<Truthy<T>>",
                "optional": false
              },
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "difference",
                "type": "(...values: List<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "differenceBy",
                "type": "{ <T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "differenceWith",
                "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>; <T2, T3, T4>(...values: (List<unknown> | Comparator2<T, never>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(n?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "dropRight",
                "type": "(n?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "dropRightWhile",
                "type": "(predicate?: ListIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "dropWhile",
                "type": "(predicate?: ListIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "fill",
                "type": "<U>(value: U, start?: number, end?: number) => Collection<T | U>",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "first",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "() => T extends Many<infer U> ? Collection<U> : Collection<T>",
                "optional": false
              },
              {
                "name": "flattenDeep",
                "type": "() => T extends ListOfRecursiveArraysOrValues<infer U> ? Collection<Flat<U>> : Collection<T>",
                "optional": false
              },
              {
                "name": "flattenDepth",
                "type": "(depth?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "fromPairs",
                "type": "() => Object<Dictionary<T extends [PropertyName, infer U] ? U : any>>",
                "optional": false
              },
              {
                "name": "head",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(value: T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "initial",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "(...arrays: List<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "intersectionBy",
                "type": "{ <T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): Collection<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "intersectionWith",
                "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>; (...values: (List<unknown> | Comparator2<T, never>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => string",
                "optional": false
              },
              {
                "name": "last",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(value: T, fromIndex?: number | true) => number",
                "optional": false
              },
              {
                "name": "nth",
                "type": "(n?: number) => T",
                "optional": false
              },
              {
                "name": "pull",
                "type": "(...values: T[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "pullAll",
                "type": "(values?: List<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "pullAllBy",
                "type": "<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>) => Collection<T>",
                "optional": false
              },
              {
                "name": "pullAllWith",
                "type": "<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>) => Collection<T>",
                "optional": false
              },
              {
                "name": "pullAt",
                "type": "(...indexes: Many<number>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "remove",
                "type": "(predicate?: ListIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start?: number, end?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "{ (value: T): number; (value: T): number; }",
                "optional": false
              },
              {
                "name": "sortedIndexBy",
                "type": "(value: T, iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedIndexOf",
                "type": "(value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndex",
                "type": "(value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexBy",
                "type": "(value: T, iteratee: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexOf",
                "type": "(value: T) => number",
                "optional": false
              },
              {
                "name": "sortedUniq",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "sortedUniqBy",
                "type": "(iteratee: ValueIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "tail",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "take",
                "type": "(n?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "takeRight",
                "type": "(n?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "takeRightWhile",
                "type": "(predicate?: ListIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "takeWhile",
                "type": "(predicate?: ListIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "union",
                "type": "(...arrays: List<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "unionBy",
                "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): Collection<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "unionWith",
                "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): Collection<T>; (...comparator: (List<T> | Comparator<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "uniqBy",
                "type": "(iteratee: ValueIteratee<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "uniqWith",
                "type": "(comparator?: Comparator<T>) => Collection<T>",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "() => T extends List<infer U> ? Collection<U[]> : unknown",
                "optional": false
              },
              {
                "name": "unzipWith",
                "type": "{ <TResult>(iteratee: (...values: (T extends List<infer U> ? U : unknown)[]) => TResult): Collection<TResult>; (): T extends List<infer U> ? Collection<...> : unknown; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "(...values: T[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "xor",
                "type": "(...arrays: List<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "xorBy",
                "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): Collection<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "xorWith",
                "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): Collection<T>; (...comparator: (List<T> | Comparator<T>)[]): Collection<...>; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ <T2>(arrays2: List<T2>): Collection<[T, T2]>; (...arrays: List<T>[]): Collection<T[]>; }",
                "optional": false
              },
              {
                "name": "zipObject",
                "type": "{ <U>(values: List<U>): Object<Dictionary<U>>; (): Object<Dictionary<undefined>>; }",
                "optional": false
              },
              {
                "name": "zipObjectDeep",
                "type": "(values?: List<any>) => Object<object>",
                "optional": false
              },
              {
                "name": "zipWith",
                "type": "{ <T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): Collection<TResult>; <T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): Collection<...>; <TResult>(...iteratee: (List<...> | ((...group: T[]) => TResult))[]): Collection<....",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => boolean",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>): Collection<S>; (predicate?: ListIterateeCustom<T, boolean>): Collection<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; }",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; }",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, Many<TResult>>): Collection<TResult>; (iteratee: object | [...]): Collection<...>; (): T extends Many<...> ? Collection<...> : Collection<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<...>; (iteratee: object | [...], depth?: number): Collection<...>; (depth?: number): Collection<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: ListIterator<T, any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<T[]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: T, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<T, PropertyName>) => Object<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <K extends keyof T>(key: K): Collection<T[K]>; <TResult>(iteratee: ListIterator<T, TResult>): Collection<TResult>; (iteratee: PropertyName): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "(iteratees?: Many<PropertyName | PartialShallow<T> | ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => Collection<...>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "{ <U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashImplicitWrapper<[U[], Exclude<T, U>[]]>; (callback: ValueIteratee<T>): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult; (callback: MemoListIterator<T, T, List<T>>): T; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): TResult; (callback: MemoListIterator<T, T, List<T>>): T; }",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => Collection<T>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => Collection<T>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => boolean",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(...iteratees: Many<ListIteratee<T>>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "max",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "maxBy",
                "type": "(iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "meanBy",
                "type": "(iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "min",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "minBy",
                "type": "(iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "sumBy",
                "type": "(iteratee?: string | ((value: T) => number)) => number",
                "optional": false
              },
              {
                "name": "at",
                "type": "(...props: PropertyPath[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: number): T; <TDefault>(path: number, defaultValue: TDefault): T | TDefault; }",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<T>) => Object<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "(iteratee?: ListIteratee<T>) => Object<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: ArrayIterator<T, TResult>): NumericDictionary<TResult>; <TKey extends keyof T>(iteratee: TKey): Object<Dictionary<T[TKey]>>; (iteratee: object): Object<...>; (iteratee: string): Object<...>; (): Object<...>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "(...paths: Many<PropertyName>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "(predicate?: ValueKeyIteratee<T>) => Object<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): Object<Dictionary<S>>; (predicate?: ValueKeyIteratee<T>): Object<...>; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ImpChain<TResult>; (): Collection<any>; }",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => Function<(o: object) => boolean>",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => Function<(...args: any[]) => TResult[]>",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => Collection<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): Collection<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): Collection<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => Collection<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => Collection<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => never",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Collection<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CollectionChain",
            "type": "CollectionChain<T>",
            "properties": [
              {
                "name": "pop",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...items: T[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: T, b: T) => number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "(start: number, deleteCount?: number, ...items: T[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: T[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "(size?: number) => CollectionChain<T[]>",
                "optional": false
              },
              {
                "name": "compact",
                "type": "() => CollectionChain<Truthy<T>>",
                "optional": false
              },
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "difference",
                "type": "(...values: List<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "differenceBy",
                "type": "{ <T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "differenceWith",
                "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>; <T2, T3, T4>(...values: (List<unknown> | Comparator2<T, never>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "drop",
                "type": "(n?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "dropRight",
                "type": "(n?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "dropRightWhile",
                "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "dropWhile",
                "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "fill",
                "type": "<U>(value: U, start?: number, end?: number) => CollectionChain<T | U>",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "first",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "() => T extends Many<infer U> ? CollectionChain<U> : CollectionChain<T>",
                "optional": false
              },
              {
                "name": "flattenDeep",
                "type": "() => T extends ListOfRecursiveArraysOrValues<infer U> ? CollectionChain<Flat<U>> : CollectionChain<T>",
                "optional": false
              },
              {
                "name": "flattenDepth",
                "type": "(depth?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "fromPairs",
                "type": "() => ObjectChain<Dictionary<T extends [PropertyName, infer U] ? U : any>>",
                "optional": false
              },
              {
                "name": "head",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(value: T, fromIndex?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "initial",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "(...arrays: List<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "intersectionBy",
                "type": "{ <T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): CollectionChain<T>; (...values: (List<unknown> | ValueIteratee<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "intersectionWith",
                "type": "{ <T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>; (...values: (List<unknown> | Comparator2<T, never>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "last",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(value: T, fromIndex?: number | true) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "nth",
                "type": "(n?: number) => ExpChain<T>",
                "optional": false
              },
              {
                "name": "pull",
                "type": "(...values: T[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "pullAll",
                "type": "(values?: List<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "pullAllBy",
                "type": "<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "pullAllWith",
                "type": "<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "pullAt",
                "type": "(...indexes: Many<number>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "remove",
                "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start?: number, end?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "{ (value: T): PrimitiveChain<number>; (value: T): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "sortedIndexBy",
                "type": "(value: T, iteratee?: ValueIteratee<T>) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sortedIndexOf",
                "type": "(value: T) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sortedLastIndex",
                "type": "(value: T) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sortedLastIndexBy",
                "type": "(value: T, iteratee: ValueIteratee<T>) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sortedLastIndexOf",
                "type": "(value: T) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sortedUniq",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "sortedUniqBy",
                "type": "(iteratee: ValueIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "tail",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "take",
                "type": "(n?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "takeRight",
                "type": "(n?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "takeRightWhile",
                "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "takeWhile",
                "type": "(predicate?: ListIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "union",
                "type": "(...arrays: List<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "unionBy",
                "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): CollectionChain<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "unionWith",
                "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): CollectionChain<T>; (...comparator: (List<T> | Comparator<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "uniqBy",
                "type": "(iteratee: ValueIteratee<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "uniqWith",
                "type": "(comparator?: Comparator<T>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "() => T extends List<infer U> ? CollectionChain<U[]> : unknown",
                "optional": false
              },
              {
                "name": "unzipWith",
                "type": "{ <TResult>(iteratee: (...values: (T extends List<infer U> ? U : unknown)[]) => TResult): CollectionChain<TResult>; (): T extends List<infer U> ? CollectionChain<...> : unknown; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "(...values: T[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "xor",
                "type": "(...arrays: List<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "xorBy",
                "type": "{ (arrays2: List<T>, iteratee?: ValueIteratee<T>): CollectionChain<T>; (...iteratee: (List<T> | ValueIteratee<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "xorWith",
                "type": "{ (arrays2: List<T>, comparator?: Comparator<T>): CollectionChain<T>; (...comparator: (List<T> | Comparator<T>)[]): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ <T2>(arrays2: List<T2>): CollectionChain<[T, T2]>; (...arrays: List<T>[]): CollectionChain<T[]>; }",
                "optional": false
              },
              {
                "name": "zipObject",
                "type": "{ <U>(values: List<U>): ObjectChain<Dictionary<U>>; (): ObjectChain<Dictionary<undefined>>; }",
                "optional": false
              },
              {
                "name": "zipObjectDeep",
                "type": "(values?: List<any>) => ObjectChain<object>",
                "optional": false
              },
              {
                "name": "zipWith",
                "type": "{ <T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): CollectionChain<TResult>; <T2, T3, TResult>(arrays2: List<T2>, arrays3: List<...>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): CollectionChain<...>; <TResult>(...iteratee: (List<...> | ((...group: T[]) => TResult))[]): C...",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>): CollectionChain<S>; (predicate?: ListIterateeCustom<T, boolean>): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <S extends T>(predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, Many<TResult>>): CollectionChain<TResult>; (iteratee: object | [...]): CollectionChain<...>; (): T extends Many<...> ? CollectionChain<...> : CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult = any>(iteratee: PropertyName | ListIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<...>; (iteratee: object | [...], depth?: number): CollectionChain<...>; (depth?: number): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: ListIterator<T, any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<T[]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: T, fromIndex?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<T, PropertyName>) => ObjectChain<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <K extends keyof T>(key: K): CollectionChain<T[K]>; <TResult>(iteratee: ListIterator<T, TResult>): CollectionChain<TResult>; (iteratee: PropertyName): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "(iteratees?: Many<PropertyName | PartialShallow<T> | ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => CollectionChain<...>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "{ <U extends T>(callback: ValueIteratorTypeGuard<T, U>): LoDashExplicitWrapper<[U[], Exclude<T, U>[]]>; (callback: ValueIteratee<T>): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>; (callback: MemoListIterator<T, T, List<...>>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(callback: MemoListIterator<T, TResult, List<T>>, accumulator: TResult): ExpChain<TResult>; (callback: MemoListIterator<T, T, List<...>>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate?: ListIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(...iteratees: Many<ListIteratee<T>>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "max",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "maxBy",
                "type": "(iteratee?: ValueIteratee<T>) => ExpChain<T>",
                "optional": false
              },
              {
                "name": "meanBy",
                "type": "(iteratee?: ValueIteratee<T>) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "min",
                "type": "() => ExpChain<T>",
                "optional": false
              },
              {
                "name": "minBy",
                "type": "(iteratee?: ValueIteratee<T>) => ExpChain<T>",
                "optional": false
              },
              {
                "name": "sumBy",
                "type": "(iteratee?: string | ((value: T) => number)) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "at",
                "type": "(...props: PropertyPath[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: number): ExpChain<T>; <TDefault>(path: number, defaultValue: TDefault): ExpChain<T> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<T>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "(iteratee?: ListIteratee<T>) => ObjectChain<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: ArrayIterator<T, TResult>): ObjectChain<NumericDictionary<TResult>>; <TKey extends keyof T>(iteratee: TKey): ObjectChain<...>; (iteratee: object): ObjectChain<...>; (iteratee: string): ObjectChain<...>; (): ObjectChain<...>; }",
                "optional": false
              },
              {
                "name": "omit",
                "type": "(...paths: Many<PropertyName>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "(predicate?: ValueKeyIteratee<T>) => ObjectChain<Dictionary<T>>",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): ObjectChain<Dictionary<S>>; (predicate?: ValueKeyIteratee<T>): ObjectChain<...>; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ExpChain<TResult>; (): CollectionChain<any>; }",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => FunctionChain<(o: object) => boolean>",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => FunctionChain<(...args: any[]) => TResult[]>",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): CollectionChain<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): CollectionChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): CollectionChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<never>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): CollectionChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function",
            "type": "Function<T>",
            "properties": [
              {
                "name": "ary",
                "type": "(n?: number) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "curry",
                "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? Function<CurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, ar...",
                "optional": false
              },
              {
                "name": "curryRight",
                "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? Function<RightCurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T...",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "{ (wait: number, options: DebounceSettingsLeading): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never; (wait?: number, options?: DebounceSettings): T extends (...args: any[]) => any ? Function<...> : never; }",
                "optional": false
              },
              {
                "name": "flip",
                "type": "() => Function<T>",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "(resolver?: (...args: any[]) => any) => Function<T & MemoizedFunction>",
                "optional": false
              },
              {
                "name": "negate",
                "type": "() => Function<(...args: Parameters<T>) => boolean>",
                "optional": false
              },
              {
                "name": "once",
                "type": "() => Function<T>",
                "optional": false
              },
              {
                "name": "overArgs",
                "type": "(...transforms: Many<(...args: any[]) => any>[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "partial",
                "type": "{ <T2>(plc1: LoDashStatic, arg2: T2): Function<T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : T extends Function3<...> ? Function2<...> : T extends Function4<...> ? Function3<...> : any>; <T3>(plc1: LoDashStatic, plc2: LoDashStatic, arg3: T3): Function<...>; <T1, T3>(arg1: T1, plc2: LoDashStatic, ar...",
                "optional": false
              },
              {
                "name": "partialRight",
                "type": "{ <T1>(arg1: T1, plc2: LoDashStatic): Function<T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> : any>; <T2>(arg2: T2): Function<...>; <T1>(arg1: T1, plc2: LoDashStatic, plc3: LoDashStatic): Function<...>; <T2>(arg2: T2, plc3: LoDashStatic): Function<...>; <T1, T2>(arg1: T1, arg2: T2, plc3: LoDashStatic...",
                "optional": false
              },
              {
                "name": "rearg",
                "type": "(...indexes: Many<number>[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(start?: number) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "spread",
                "type": "(start?: number) => Function<(...args: any[]) => ReturnType<T>>",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "{ (wait?: number, options?: ThrottleSettingsLeading): T extends (...args: any[]) => any ? Function<DebouncedFuncLeading<T>> : never; (wait?: number, options?: ThrottleSettings): T extends (...args: any[]) => any ? Function<...> : never; }",
                "optional": false
              },
              {
                "name": "unary",
                "type": "() => Function<(arg1: Parameters<T>[\"0\"]) => ReturnType<T>>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "flow",
                "type": "{ <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): Function<...>; <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<...>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R...",
                "optional": false
              },
              {
                "name": "flowRight",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>[\"0\"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): Function<...>; <A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<...>[\"0\"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2...",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => Function<T>",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => Function<(...args: any[]) => (ReturnType<T> | TResult)[]>",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: Parameters<T> | TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => Function<(...args: Parameters<T> | TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Function<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): Function<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Function<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => Function<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => Function<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => Function<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => Function<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => Function<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Function<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [
              "LoDashImplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "String",
            "type": "String<T>",
            "properties": [
              {
                "name": "first",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "head",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => string",
                "optional": false
              },
              {
                "name": "last",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: StringIterator<any>) => String<string>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: StringIterator<any>) => String<string>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(predicate?: StringIterator<boolean>) => Collection<string>",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): Collection<TResult>; (): Collection<string>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<TResult>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<TResult>; (depth?: number): Collection<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: StringIterator<any>) => String<string>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: StringIterator<any>) => String<string>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: string, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <TResult>(iteratee: StringIterator<TResult>): Collection<TResult>; (): Collection<string>; }",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(callback: StringIterator<unknown>) => LoDashImplicitWrapper<[string[], string[]]>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: StringIterator<boolean>) => Collection<string>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: number | number[]): string; (path: number | number[], defaultValue: string): string; }",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<string>) => Object<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: StringIterator<TResult>): Object<NumericDictionary<TResult>>; (): Object<NumericDictionary<string>>; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "<T extends string>() => StringChain<T>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => Function<(o: object) => any>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => String<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): String<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): String<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => String<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => String<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => String<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => String<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => String<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): String<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [
              "LoDashImplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Object",
            "type": "Object<T>",
            "properties": [
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => boolean",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): Collection<S>; (predicate?: ObjectIterateeCustom<T, boolean>): Collection<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): S; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, Many<TResult>>): Collection<TResult>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): Collection<...>; (iteratee: object | [...], depth?: number): Collection<...>; (depth?: number): Collection<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<T[keyof T][]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: T[keyof T], fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>) => Object<Dictionary<T[keyof T]>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <K extends keyof T[keyof T]>(key: K): Collection<T[keyof T][K]>; <TResult>(iteratee: ObjectIterator<T, TResult>): Collection<TResult>; (iteratee: PropertyName): Collection<...>; (iteratee: object | [...]): Collection<...>; (): Collection<...>; }",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "(iteratees?: Many<ObjectIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(callback: ValueIteratee<T[keyof T]>) => LoDashImplicitWrapper<[T[keyof T][], T[keyof T][]]>",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult; (callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): TResult; (callback: MemoObjectIterator<T[keyof T], T[keyof T], T>): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => T[keyof T]",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => boolean",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(...iteratees: Many<ObjectIteratee<T>>[]) => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "assign",
                "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
                "optional": false
              },
              {
                "name": "assignIn",
                "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
                "optional": false
              },
              {
                "name": "assignInWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
                "optional": false
              },
              {
                "name": "assignWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
                "optional": false
              },
              {
                "name": "at",
                "type": "(...props: Many<keyof T>[]) => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "create",
                "type": "<U extends object>(properties?: U) => Object<T & U>",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "{ <TSource>(source: TSource): Object<NonNullable<TSource & T>>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<NonNullable<TSource2 & TSource1 & T>>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(sour...",
                "optional": false
              },
              {
                "name": "defaultsDeep",
                "type": "(...sources: any[]) => Object<any>",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, T[keyof T]]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, T[keyof T]]>",
                "optional": false
              },
              {
                "name": "extend",
                "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
                "optional": false
              },
              {
                "name": "extendWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<...>; <...",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ <TKey extends keyof T>(path: TKey | [TKey]): T[TKey]; <TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): TDefault | Exclude<T[TKey], undefined>; <TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [...]): T[TKey1][TKey2]; <TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDe...",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => Object<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "(iteratee?: ObjectIteratee<T>) => Object<Dictionary<T[keyof T]>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: ObjectIterator<T, TResult>): Object<{ [P in keyof T]: TResult; }>; <TResult>(callback: DictionaryIterator<T[keyof T], TResult>): Object<...>; (iteratee: object): Object<...>; <TKey extends keyof T[keyof T]>(iteratee: TKey): Object<...>; (iteratee: string): Object<...>; (): Object<...>; }",
                "optional": false
              },
              {
                "name": "merge",
                "type": "{ <TSource>(source: TSource): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TS...",
                "optional": false
              },
              {
                "name": "mergeWith",
                "type": "{ <TSource>(source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Object<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Object<....",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <K extends keyof T>(...paths: Many<K>[]): Object<Omit<T, K>>; (...paths: Many<string | number | symbol | [PropertyName, any] | PartialShallow<T>>[]): Object<...>; }",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "(predicate: ValueKeyIteratee<T[keyof T]>) => Object<Partial<T>>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <U extends keyof T>(...props: Many<U>[]): Object<Pick<T, U>>; (...props: Many<PropertyPath>[]): Object<Partial<T>>; }",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): Object<NumericDictionary<unknown> extends T ? NumericDictionary<...> : Dictionary<...>>; (predicate?: ValueKeyIteratee<...>): Object<...>; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ImpChain<TResult>; <TResult>(iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): ImpChain<...>; (): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "updateWith",
                "type": "{ (path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): Object<T>; <TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): Object<...>; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "() => Collection<T[keyof T]>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => Function<(o: T) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Object<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): Object<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Object<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => Object<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => Object<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => Object<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => Object<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => Object<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Object<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [
              "LoDashImplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Primitive",
            "type": "Primitive<T>",
            "properties": [
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => Collection<T>",
                "optional": false
              },
              {
                "name": "after",
                "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => Function<TFunc>",
                "optional": false
              },
              {
                "name": "before",
                "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => Function<TFunc>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => Collection<T>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => Primitive<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): Primitive<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): Primitive<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => Primitive<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => Primitive<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => Primitive<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => Primitive<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => Primitive<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): Primitive<T>; (options?: MixinOptions): LoDashImplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [
              "LoDashImplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "FunctionChain",
            "type": "FunctionChain<T>",
            "properties": [
              {
                "name": "ary",
                "type": "(n?: number) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "curry",
                "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? FunctionChain<CurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg...",
                "optional": false
              },
              {
                "name": "curryRight",
                "type": "(arity?: number) => T extends (arg1: infer T1) => infer R ? FunctionChain<RightCurriedFunction1<T1, R>> : T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<...> : T extends (arg1: infer T1, arg2: infer T2...",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "{ (wait: number, options: DebounceSettingsLeading): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never; (wait?: number, options?: DebounceSettings): T extends (...args: any[]) => any ? FunctionChain<...> : never; }",
                "optional": false
              },
              {
                "name": "flip",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "(resolver?: (...args: any[]) => any) => FunctionChain<T & MemoizedFunction>",
                "optional": false
              },
              {
                "name": "negate",
                "type": "() => FunctionChain<(...args: Parameters<T>) => boolean>",
                "optional": false
              },
              {
                "name": "once",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "overArgs",
                "type": "(...transforms: Many<(...args: any[]) => any>[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "partial",
                "type": "{ <T2>(plc1: LoDashStatic, arg2: T2): FunctionChain<T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : T extends Function3<...> ? Function2<...> : T extends Function4<...> ? Function3<...> : any>; <T3>(plc1: LoDashStatic, plc2: LoDashStatic, arg3: T3): FunctionChain<...>; <T1, T3>(arg1: T1, plc2: LoDash...",
                "optional": false
              },
              {
                "name": "partialRight",
                "type": "{ <T1>(arg1: T1, plc2: LoDashStatic): FunctionChain<T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> : any>; <T2>(arg2: T2): FunctionChain<...>; <T1>(arg1: T1, plc2: LoDashStatic, plc3: LoDashStatic): FunctionChain<...>; <T2>(arg2: T2, plc3: LoDashStatic): FunctionChain<...>; <T1, T2>(arg1: T1, arg2: T2...",
                "optional": false
              },
              {
                "name": "rearg",
                "type": "(...indexes: Many<number>[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(start?: number) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "spread",
                "type": "(start?: number) => FunctionChain<(...args: any[]) => ReturnType<T>>",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "{ (wait?: number, options?: ThrottleSettingsLeading): T extends (...args: any[]) => any ? FunctionChain<DebouncedFuncLeading<T>> : never; (wait?: number, options?: ThrottleSettings): T extends (...args: any[]) => any ? FunctionChain<...> : never; }",
                "optional": false
              },
              {
                "name": "unary",
                "type": "() => FunctionChain<(arg1: Parameters<T>[\"0\"]) => ReturnType<T>>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "flow",
                "type": "{ <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<T>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): FunctionChain<...>; <R2, R3, R4, R5, R6, R7>(f2: (a: ReturnType<...>) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6)...",
                "optional": false
              },
              {
                "name": "flowRight",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5>(f6: (a: R5) => Parameters<T>[\"0\"], f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): FunctionChain<...>; <A extends any[], R1, R2, R3, R4>(f5: (a: R4) => Parameters<...>[\"0\"], f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) ...",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => FunctionChain<(...args: any[]) => (ReturnType<T> | TResult)[]>",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "<TArgs>(...iteratees: Many<(...args: TArgs[]) => boolean>[]) => FunctionChain<(...args: Parameters<T> | TArgs[]) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): FunctionChain<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): FunctionChain<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): FunctionChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): FunctionChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => FunctionChain<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): FunctionChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [
              "LoDashExplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "StringChain",
            "type": "StringChain<T>",
            "properties": [
              {
                "name": "first",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "head",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "last",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>; (): CollectionChain<string>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<TResult>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<TResult>; (depth?: number): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: StringIterator<any>) => StringChain<string>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: string, fromIndex?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>; (): CollectionChain<string>; }",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(callback: StringIterator<unknown>) => LoDashExplicitWrapper<[string[], string[]]>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: number | number[]): StringChain<string>; (path: number | number[], defaultValue: string): StringChain<string>; }",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>; (): ObjectChain<NumericDictionary<string>>; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => FunctionChain<(o: object) => any>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): StringChain<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => StringChain<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): StringChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): StringChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => StringChain<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => StringChain<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => StringChain<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => StringChain<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): StringChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [
              "LoDashExplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "StringNullableChain",
            "type": "StringNullableChain",
            "properties": [
              {
                "name": "first",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "head",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "last",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "filter",
                "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult>(iteratee: StringIterator<Many<TResult>>): CollectionChain<TResult>; (): CollectionChain<string>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<TResult>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult>(iteratee: StringIterator<TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<TResult>; (depth?: number): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: StringIterator<any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<string, PropertyName>) => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <TResult>(iteratee: StringIterator<TResult>): CollectionChain<TResult>; (): CollectionChain<string>; }",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(callback: StringIterator<unknown>) => LoDashExplicitWrapper<[string[], string[]]>",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: StringIterator<boolean>) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ (path: number | number[]): StringNullableChain; (path: number | number[], defaultValue: string): StringChain<string>; }",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<string>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>; (): ObjectChain<NumericDictionary<string>>; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => FunctionChain<(o: object) => any>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<string>): LoDashExplicitWrapper<any>; (): StringNullableChain; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): StringChain<...> | ExpChain<...>; (): StringNullableChain; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: string) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): StringNullableChain; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): StringNullableChain; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, string]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, string]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => StringNullableChain",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: string) => void) => StringNullableChain",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: string) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<Uncapitalize<string>>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<Lowercase<string>>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<Uppercase<string>>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<Capitalize<string>>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => StringNullableChain",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: string) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => string>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: string): StringChain<string>; <TDefault>(defaultValue: TDefault): StringChain<string> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => StringNullableChain",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): StringNullableChain; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [
              "LoDashExplicitWrapper<string | undefined>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectChain",
            "type": "ObjectChain<T>",
            "properties": [
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<number>>",
                "optional": false
              },
              {
                "name": "each",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "every",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>): CollectionChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <S extends T[keyof T]>(predicate: ObjectIteratorTypeGuard<T, S>, fromIndex?: number): ExpChain<S>; (predicate?: ObjectIterateeCustom<T, boolean>, fromIndex?: number): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, Many<TResult>>): CollectionChain<TResult>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <TResult = any>(iteratee: PropertyName | ObjectIterator<T, TResult | ListOfRecursiveArraysOrValues<TResult>>, depth?: number): CollectionChain<...>; (iteratee: object | [...], depth?: number): CollectionChain<...>; (depth?: number): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<T[keyof T][]>>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(target: T[keyof T], fromIndex?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "(iteratee?: ValueIterateeCustom<T[keyof T], PropertyName>) => ObjectChain<Dictionary<T[keyof T]>>",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <K extends keyof T[keyof T]>(key: K): CollectionChain<T[keyof T][K]>; <TResult>(iteratee: ObjectIterator<T, TResult>): CollectionChain<TResult>; (iteratee: PropertyName): CollectionChain<...>; (iteratee: object | [...]): CollectionChain<...>; (): CollectionChain<...>; }",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "(iteratees?: Many<ObjectIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">) => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "partition",
                "type": "(callback: ValueIteratee<T[keyof T]>) => LoDashExplicitWrapper<[T[keyof T][], T[keyof T][]]>",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>; (callback: MemoObjectIterator<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <TResult>(callback: MemoObjectIterator<T[keyof T], TResult, T>, accumulator: TResult): ExpChain<TResult>; (callback: MemoObjectIterator<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "reject",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "sample",
                "type": "() => ExpChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "(n?: number) => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "() => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate?: ObjectIterateeCustom<T, boolean>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "(...iteratees: Many<ObjectIteratee<T>>[]) => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "() => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "assign",
                "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
                "optional": false
              },
              {
                "name": "assignIn",
                "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
                "optional": false
              },
              {
                "name": "assignInWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
                "optional": false
              },
              {
                "name": "assignWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
                "optional": false
              },
              {
                "name": "at",
                "type": "(...props: Many<keyof T>[]) => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "create",
                "type": "<U extends object>(properties?: U) => ObjectChain<T & U>",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "{ <TSource>(source: TSource): ObjectChain<NonNullable<TSource & T>>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSource1, sou...",
                "optional": false
              },
              {
                "name": "defaultsDeep",
                "type": "(...sources: any[]) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, T[keyof T]]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, T[keyof T]]>",
                "optional": false
              },
              {
                "name": "extend",
                "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
                "optional": false
              },
              {
                "name": "extendWith",
                "type": "{ <TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<...>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Obje...",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ <TKey extends keyof T>(path: TKey | [TKey]): ExpChain<T[TKey]>; <TKey extends keyof T>(path: TKey | [TKey], defaultValue: never[]): T[TKey] extends any[] ? ExpChain<...> : CollectionChain<...> | ExpChain<...>; <TKey extends keyof T, TDefault>(path: TKey | [...], defaultValue: TDefault): ExpChain<...> | ExpChain<.....",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "(iteratee?: ValueIteratee<T[keyof T]>) => ObjectChain<Dictionary<string[]>>",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "(iteratee?: ObjectIteratee<T>) => ObjectChain<Dictionary<T[keyof T]>>",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(callback: ObjectIterator<T, TResult>): ObjectChain<{ [P in keyof T]: TResult; }>; <TResult>(callback: DictionaryIterator<T[keyof T], TResult>): ObjectChain<...>; (iteratee: object): ObjectChain<...>; <TKey extends keyof T[keyof T]>(iteratee: TKey): ObjectChain<...>; (iteratee: string): ObjectChain<...>; ...",
                "optional": false
              },
              {
                "name": "merge",
                "type": "{ <TSource>(source: TSource): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>; <TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<...>; <TSource1, TSource2, TSource3, TSource4>(source1: TSourc...",
                "optional": false
              },
              {
                "name": "mergeWith",
                "type": "{ <TSource>(source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): ObjectChain<T & TSource>; <TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): Obj...",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <K extends keyof T>(...paths: Many<K>[]): ObjectChain<Omit<T, K>>; (...paths: Many<PropertyName>[]): ObjectChain<Partial<T>>; }",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "(predicate: ValueKeyIteratee<T[keyof T]>) => ObjectChain<Partial<T>>",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <U extends keyof T>(...props: Many<U>[]): ObjectChain<Pick<T, U>>; (...props: Many<PropertyPath>[]): ObjectChain<Partial<T>>; }",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): ObjectChain<NumericDictionary<unknown> extends T ? NumericDictionary<...> : Dictionary<...>>; (predicate?: ValueKeyIteratee<...>): ObjectChain<...>; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ExpChain<TResult>; <TResult>(iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): ExpChain<...>; (): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "updateWith",
                "type": "{ (path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): ObjectChain<T>; <TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): ObjectChain<...>; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "() => CollectionChain<T[keyof T]>",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "() => FunctionChain<(o: T) => boolean>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): ObjectChain<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): ObjectChain<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): ObjectChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): ObjectChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => ObjectChain<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): ObjectChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<LoDashStatic>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [
              "LoDashExplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PrimitiveChain",
            "type": "PrimitiveChain<T>",
            "properties": [
              {
                "name": "concat",
                "type": "(...values: Many<T>[]) => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "after",
                "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => FunctionChain<TFunc>",
                "optional": false
              },
              {
                "name": "before",
                "type": "<TFunc extends (...args: any[]) => any>(func: TFunc) => FunctionChain<TFunc>",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "() => CollectionChain<T>",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): PrimitiveChain<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): PrimitiveChain<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): PrimitiveChain<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): PrimitiveChain<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => PrimitiveChain<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): PrimitiveChain<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [
              "LoDashExplicitWrapper<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NotVoid",
            "type": "unknown",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IterateeShorthand",
            "type": "IterateeShorthand<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ArrayIterator",
            "type": "ArrayIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TupleIterator",
            "type": "TupleIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListIterator",
            "type": "ListIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListIteratee",
            "type": "ListIteratee<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListIterateeCustom",
            "type": "ListIterateeCustom<T, TResult>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListIteratorTypeGuard",
            "type": "ListIteratorTypeGuard<T, S>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectIterator",
            "type": "ObjectIterator<TObject, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectIteratee",
            "type": "ObjectIteratee<TObject>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectIterateeCustom",
            "type": "ObjectIterateeCustom<TObject, TResult>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ObjectIteratorTypeGuard",
            "type": "ObjectIteratorTypeGuard<TObject, S>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "StringIterator",
            "type": "StringIterator<TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoVoidIterator",
            "type": "MemoVoidIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "",
              "params": [],
              "deprecated": true
            },
            "isExported": false
          },
          {
            "name": "MemoIterator",
            "type": "MemoIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "",
              "params": [],
              "deprecated": true
            },
            "isExported": false
          },
          {
            "name": "MemoListIterator",
            "type": "MemoListIterator<T, TResult, TList>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoObjectIterator",
            "type": "MemoObjectIterator<T, TResult, TList>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoIteratorCapped",
            "type": "MemoIteratorCapped<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoIteratorCappedRight",
            "type": "MemoIteratorCappedRight<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoVoidArrayIterator",
            "type": "MemoVoidArrayIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoVoidDictionaryIterator",
            "type": "MemoVoidDictionaryIterator<T, K, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoVoidIteratorCapped",
            "type": "MemoVoidIteratorCapped<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ValueIteratee",
            "type": "ValueIteratee<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ValueIterateeCustom",
            "type": "ValueIterateeCustom<T, TResult>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ValueIteratorTypeGuard",
            "type": "ValueIteratorTypeGuard<T, S>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ValueKeyIteratee",
            "type": "ValueKeyIteratee<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ValueKeyIterateeTypeGuard",
            "type": "ValueKeyIterateeTypeGuard<T, S>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Comparator",
            "type": "Comparator<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Comparator2",
            "type": "Comparator2<T1, T2>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PropertyName",
            "type": "PropertyName",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PropertyPath",
            "type": "PropertyPath",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "List",
            "type": "List<T>",
            "properties": [
              {
                "name": "length",
                "type": "number",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": {
              "description": "Common interface between Arrays and jQuery objects",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "Dictionary",
            "type": "Dictionary<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NumericDictionary",
            "type": "NumericDictionary<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "AnyKindOfDictionary",
            "type": "AnyKindOfDictionary",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PartialShallow",
            "type": "PartialShallow<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "StringToNumber",
            "type": "StringToNumber<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(radix?: number) => string",
                "optional": false
              },
              {
                "name": "toFixed",
                "type": "(fractionDigits?: number) => string",
                "optional": false
              },
              {
                "name": "toExponential",
                "type": "(fractionDigits?: number) => string",
                "optional": false
              },
              {
                "name": "toPrecision",
                "type": "(precision?: number) => string",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "{ (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitArrayWrapper",
            "type": "LoDashImplicitArrayWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashImplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => never",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitArrayWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitNillableArrayWrapper",
            "type": "LoDashImplicitNillableArrayWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): any; (): T[]; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T[], TResult>): T[] | TResult; (): T[]; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashImplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => never",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): T[]; <TDefault>(defaultValue: TDefault): T[] | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNillableArrayWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitObjectWrapper",
            "type": "LoDashImplicitObjectWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashImplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitObjectWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitNillableObjectWrapper",
            "type": "LoDashImplicitNillableObjectWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): any; (): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<T, TResult>): T | TResult; (): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashImplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => T extends string ? Uncapitalize<T> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => T extends string ? Lowercase<T> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => T extends string ? Uppercase<T> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => T extends string ? Capitalize<T> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): T; <TDefault>(defaultValue: TDefault): T extends null ? TDefault : T | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNillableObjectWrapper<T>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitNumberArrayWrapper",
            "type": "LoDashImplicitNumberArrayWrapper",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: number[], ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<number[]>): any; (): number[]; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<number[], TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<number[], TResult>): number[] | TResult; (): number[]; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: any[]) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<number[]>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<number[]>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<number[]>): LoDashImplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, number]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, number]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: number[]) => void) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: number[]) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => never",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: any[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => number[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: number[]): number[]; <TDefault>(defaultValue: TDefault): number[] | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitNumberArrayWrapper; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitStringWrapper",
            "type": "LoDashImplicitStringWrapper",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<string>): any; (): string; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<string, TResult>): string | TResult; (): string; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: string) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<string>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<string>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitStringWrapper; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): LoDashImplicitStringWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, string]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, string]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: string) => void) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: string) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => Uncapitalize<string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => Lowercase<string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => Uppercase<string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => Capitalize<string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitStringWrapper",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: string) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => string>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: string): string; <TDefault>(defaultValue: TDefault): string | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitStringWrapper; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitArrayWrapper",
            "type": "LoDashExplicitArrayWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitArrayWrapper<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitArrayWrapper<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashExplicitArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<never>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitArrayWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitNillableArrayWrapper",
            "type": "LoDashExplicitNillableArrayWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitNillableArrayWrapper<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitNillableArrayWrapper<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: (T extends (arg: infer A) => any ? A : any)[]) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T[], any>) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T[]>): LoDashExplicitNillableArrayWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T[]) => void) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T[]) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<never>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: (T extends (arg: infer A) => any ? A : any)[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T[]): CollectionChain<T>; <TDefault>(defaultValue: TDefault): CollectionChain<T> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitNillableArrayWrapper<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNillableArrayWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitObjectWrapper",
            "type": "LoDashExplicitObjectWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): LoDashExplicitObjectWrapper<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitObjectWrapper<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashExplicitObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitObjectWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitNillableObjectWrapper",
            "type": "LoDashExplicitNillableObjectWrapper<T>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: T, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<T>): LoDashExplicitWrapper<any>; (): LoDashExplicitNillableObjectWrapper<T>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<T, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitNillableObjectWrapper<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<T>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<T>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<T, any>) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): LoDashExplicitNillableObjectWrapper<T>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, T extends Dictionary<infer U> ? U : T extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => T",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: T) => void) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: T) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends T ? T & string : Capitalize<Lowercase<T extends string ? T : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<T extends string ? Uncapitalize<T> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<T extends string ? Lowercase<T> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<T extends string ? Uppercase<T> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<T extends string ? Capitalize<T> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<T>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => T>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: T): ExpChain<T>; <TDefault>(defaultValue: TDefault): ExpChain<T extends null ? TDefault : T | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitNillableObjectWrapper<T>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNillableObjectWrapper<T>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitNumberArrayWrapper",
            "type": "LoDashExplicitNumberArrayWrapper",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: number[], ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<number[]>): LoDashExplicitWrapper<any>; (): LoDashExplicitNumberArrayWrapper; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<number[], TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): CollectionChain<...> | ExpChain<...>; (): LoDashExplicitNumberArrayWrapper; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: any[]) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<number[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<number[]>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<number[], any>) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<number[]>): LoDashExplicitNumberArrayWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, number]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, number]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => number[]",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: number[]) => void) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: number[]) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<never>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: any[]) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => number[]>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: number[]): CollectionChain<number>; <TDefault>(defaultValue: TDefault): CollectionChain<number> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitNumberArrayWrapper",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitNumberArrayWrapper; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitStringWrapper",
            "type": "LoDashExplicitStringWrapper",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: string, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<string>): LoDashExplicitWrapper<any>; (): LoDashExplicitStringWrapper; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<string, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): StringChain<...> | ExpChain<...>; (): LoDashExplicitStringWrapper; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: string) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<string>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<string, any>) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitStringWrapper; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<string>): LoDashExplicitStringWrapper; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, string]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, string]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: string) => void) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: string) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<Uncapitalize<string>>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<Lowercase<string>>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<Uppercase<string>>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<Capitalize<string>>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: string) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => string>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: string): StringChain<string>; <TDefault>(defaultValue: TDefault): StringChain<string> | ExpChain<TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitStringWrapper",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitStringWrapper; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DictionaryIterator",
            "type": "DictionaryIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DictionaryIteratee",
            "type": "DictionaryIteratee<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DictionaryIteratorTypeGuard",
            "type": "DictionaryIteratorTypeGuard<T, S>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NumericDictionaryIterator",
            "type": "NumericDictionaryIterator<T, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NumericDictionaryIteratee",
            "type": "NumericDictionaryIteratee<T>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "NumericDictionaryIterateeCustom",
            "type": "NumericDictionaryIterateeCustom<T, TResult>",
            "properties": [
              {
                "name": "toString",
                "type": "(() => string) | ((radix?: number) => string) | (() => string) | (() => string) | (() => string) | (() => string)",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => symbol) | (() => Object)",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "(() => string) | { (locales?: string | string[], options?: NumberFormatOptions): string; (locales?: LocalesArgument, options?: NumberFormatOptions): string; } | { ...; }",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Falsey",
            "type": "Falsey",
            "properties": [
              {
                "name": "valueOf",
                "type": "(() => string) | (() => number) | (() => boolean) | (() => bigint)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Truthy",
            "type": "Truthy<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RecursiveArray",
            "type": "RecursiveArray<T>",
            "properties": [
              {
                "name": "length",
                "type": "number",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
                "optional": false
              },
              {
                "name": "pop",
                "type": "() => RecursiveArray<T> | T",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...items: (RecursiveArray<T> | T)[]) => number",
                "optional": false
              },
              {
                "name": "concat",
                "type": "{ (...items: ConcatArray<RecursiveArray<T> | T>[]): (RecursiveArray<T> | T)[]; (...items: (RecursiveArray<T> | T | ConcatArray<...>)[]): (RecursiveArray<...> | T)[]; }",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => string",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => (RecursiveArray<T> | T)[]",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => RecursiveArray<T> | T",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start?: number, end?: number) => (RecursiveArray<T> | T)[]",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: RecursiveArray<T> | T, b: RecursiveArray<T> | T) => number) => RecursiveArray<T>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "{ (start: number, deleteCount?: number): (RecursiveArray<T> | T)[]; (start: number, deleteCount: number, ...items: (RecursiveArray<T> | T)[]): (RecursiveArray<...> | T)[]; }",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: (RecursiveArray<T> | T)[]) => number",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "every",
                "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: RecursiveArray<...> | T, index: number, array: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): boolean; }",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => unknown, thisArg?: any) => boolean",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(callbackfn: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => void, thisArg?: any) => void",
                "optional": false
              },
              {
                "name": "map",
                "type": "<U>(callbackfn: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => U, thisArg?: any) => U[]",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): S[]; (predicate: (value: RecursiveArray<...> | T, index: number, array: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): (RecursiveArray<...> | T)[]; }",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ (callbackfn: (previousValue: RecursiveArray<T> | T, currentValue: RecursiveArray<T> | T, currentIndex: number, array: (RecursiveArray<T> | T)[]) => RecursiveArray<...> | T): RecursiveArray<...> | T; (callbackfn: (previousValue: RecursiveArray<...> | T, currentValue: RecursiveArray<...> | T, currentIndex: number, a...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ (callbackfn: (previousValue: RecursiveArray<T> | T, currentValue: RecursiveArray<T> | T, currentIndex: number, array: (RecursiveArray<T> | T)[]) => RecursiveArray<...> | T): RecursiveArray<...> | T; (callbackfn: (previousValue: RecursiveArray<...> | T, currentValue: RecursiveArray<...> | T, currentIndex: number, a...",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends RecursiveArray<T> | T>(predicate: (value: RecursiveArray<T> | T, index: number, obj: (RecursiveArray<T> | T)[]) => value is S, thisArg?: any): S; (predicate: (value: RecursiveArray<...> | T, index: number, obj: (RecursiveArray<...> | T)[]) => unknown, thisArg?: any): RecursiveArray<...> | T; }",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(predicate: (value: RecursiveArray<T> | T, index: number, obj: (RecursiveArray<T> | T)[]) => unknown, thisArg?: any) => number",
                "optional": false
              },
              {
                "name": "fill",
                "type": "(value: RecursiveArray<T> | T, start?: number, end?: number) => RecursiveArray<T>",
                "optional": false
              },
              {
                "name": "copyWithin",
                "type": "(target: number, start: number, end?: number) => RecursiveArray<T>",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => ArrayIterator<[number, RecursiveArray<T> | T]>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => ArrayIterator<number>",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => ArrayIterator<RecursiveArray<T> | T>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(searchElement: RecursiveArray<T> | T, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "<U, This = undefined>(callback: (this: This, value: RecursiveArray<T> | T, index: number, array: (RecursiveArray<T> | T)[]) => U | readonly U[], thisArg?: This) => U[]",
                "optional": false
              },
              {
                "name": "flat",
                "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
                "optional": false
              },
              {
                "name": "__@iterator@4630",
                "type": "() => ArrayIterator<RecursiveArray<T> | T>",
                "optional": false
              },
              {
                "name": "__@unscopables@4632",
                "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
                "optional": false
              },
              {
                "name": "at",
                "type": "(index: number) => RecursiveArray<T> | T",
                "optional": false
              }
            ],
            "extends": [
              "Array<T|RecursiveArray<T>>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ListOfRecursiveArraysOrValues",
            "type": "ListOfRecursiveArraysOrValues<T>",
            "properties": [
              {
                "name": "length",
                "type": "number",
                "optional": false
              }
            ],
            "extends": [
              "List<T|RecursiveArray<T>>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Flat",
            "type": "Flat<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashImplicitWrapper",
            "type": "LoDashImplicitWrapper<TValue>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): Collection<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): Collection<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => Primitive<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult) => Function<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<TValue>): any; (): TValue; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): TResult; <TResult>(customizer: CloneWithCustomizer<TValue, TResult>): TValue | TResult; (): TValue; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<TValue>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => this is LoDashImplicitWrapper<object>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => boolean",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => Object<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): number; (upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => Collection<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<TValue>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<TValue>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => Object<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashImplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any): ImpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): LoDashImplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ImpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => Primitive<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => Object<any>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: TValue) => void) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: TValue) => TResult) => ImpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => string extends TValue ? TValue & string : Capitalize<Lowercase<TValue extends string ? TValue : never>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => TValue extends string ? Uncapitalize<TValue> : string",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): string; (replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => Collection<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => TValue extends string ? Lowercase<TValue> : string",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => TValue extends string ? Uppercase<TValue> : string",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => string",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => TValue extends string ? Capitalize<TValue> : string",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => Collection<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashImplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => Function<(value: ConformsPredicateObject<TValue>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => Function<() => TValue>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: TValue): TValue; <TDefault>(defaultValue: TDefault): TValue extends null ? TDefault : TValue | TDefault; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => Function<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): Function<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): Function<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => Function<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashImplicitWrapper<TValue>; (options?: MixinOptions): LoDashImplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => Function<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => Function<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashImplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => Collection<number>",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): TResult[]; (): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => Collection<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashExplicitWrapper",
            "type": "LoDashExplicitWrapper<TValue>",
            "properties": [
              {
                "name": "invokeMap",
                "type": "{ (methodName: string, ...args: any[]): CollectionChain<any>; <TResult>(method: (...args: any[]) => TResult, ...args: any[]): CollectionChain<TResult>; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(thisArg: any, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "(key: string, ...partials: any[]) => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(wait: number, ...args: any[]) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult) => FunctionChain<(...args: TArgs[]) => TResult>",
                "optional": false
              },
              {
                "name": "clone",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ (customizer: CloneDeepWithCustomizer<TValue>): LoDashExplicitWrapper<any>; (): LoDashExplicitWrapper<TValue>; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <TResult extends object | string | number | boolean | null>(customizer: CloneWithCustomizer<TValue, TResult>): ExpChain<TResult>; <TResult>(customizer: CloneWithCustomizer<...>): ExpChain<...> | ExpChain<...>; (): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "(source: ConformsPredicateObject<TValue>) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(other: any, customizer?: IsEqualCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isError",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(source: object) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(source: object, customizer: isMatchWithCustomizer) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "() => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(other: any) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "() => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "add",
                "type": "(addend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(divisor: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "mean",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplicand: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "round",
                "type": "(precision?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(subtrahend: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "sum",
                "type": "() => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (lower: number, upper: number): PrimitiveChain<number>; (upper: number): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(start: number, end?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): PrimitiveChain<number>; (max: number, floating?: boolean): PrimitiveChain<number>; }",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "() => CollectionChain<[string, any]>",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "(predicate?: ObjectIteratee<TValue>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "(predicate?: ObjectIteratee<TValue>) => StringNullableChain",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "(iteratee?: ObjectIterator<TValue, any>) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "functions",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "has",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "invert",
                "type": "() => ObjectChain<Dictionary<string>>",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(path: PropertyPath, ...args: any[]) => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ (path: PropertyPath, value: any): LoDashExplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any): ExpChain<TResult>; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ (path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): LoDashExplicitWrapper<TValue>; <TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): ExpChain<...>; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "() => CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "() => CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(path: PropertyPath) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "update",
                "type": "(path: PropertyPath, updater: (value: any) => any) => ObjectChain<any>",
                "optional": false
              },
              {
                "name": "chain",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "commit",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "plant",
                "type": "(value: unknown) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "toJSON",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "value",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "valueOf",
                "type": "() => TValue",
                "optional": false
              },
              {
                "name": "tap",
                "type": "(interceptor: (value: TValue) => void) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<TResult>(interceptor: (value: TValue) => TResult) => ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "() => StringChain<string extends TValue ? TValue & string : Capitalize<Lowercase<TValue extends string ? TValue : never>>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "escape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "() => StringChain<TValue extends string ? Uncapitalize<TValue> : string>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(length?: number, chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(radix?: number) => PrimitiveChain<number>",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(n?: number) => StringChain<string>",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (pattern: string | RegExp, replacement: string | ReplaceFunction): StringChain<string>; (replacement: string | ReplaceFunction): StringChain<...>; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "split",
                "type": "(separator?: string | RegExp, limit?: number) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(target?: string, position?: number) => PrimitiveChain<boolean>",
                "optional": false
              },
              {
                "name": "template",
                "type": "(options?: TemplateOptions) => FunctionChain<TemplateExecutor>",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "() => StringChain<TValue extends string ? Lowercase<TValue> : string>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "() => StringChain<TValue extends string ? Uppercase<TValue> : string>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "(chars?: string) => StringChain<string>",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(options?: TruncateOptions) => StringChain<string>",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "() => StringChain<TValue extends string ? Capitalize<TValue> : string>",
                "optional": false
              },
              {
                "name": "words",
                "type": "(pattern?: string | RegExp) => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(...args: any[]) => ObjectChain<Error> | ExpChain<TResult>",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "(...methodNames: Many<string>[]) => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "() => FunctionChain<(value: ConformsPredicateObject<TValue>) => boolean>",
                "optional": false
              },
              {
                "name": "constant",
                "type": "() => FunctionChain<() => TValue>",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ (defaultValue: TValue): ExpChain<TValue>; <TDefault>(defaultValue: TDefault): ExpChain<TValue extends null ? TDefault : TValue | TDefault>; }",
                "optional": false
              },
              {
                "name": "identity",
                "type": "() => LoDashExplicitWrapper<TValue>",
                "optional": false
              },
              {
                "name": "matches",
                "type": "<V>() => FunctionChain<(value: V) => boolean>",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <SrcValue>(srcValue: SrcValue): FunctionChain<(value: any) => boolean>; <SrcValue, Value>(srcValue: SrcValue): FunctionChain<(value: Value) => boolean>; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(...args: any[]) => FunctionChain<(object: any) => any>",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(...args: any[]) => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ (source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashExplicitWrapper<TValue>; (options?: MixinOptions): LoDashExplicitWrapper<...>; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashExplicitWrapper<LoDashStatic>",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => PrimitiveChain<undefined>",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "() => FunctionChain<(...args: any[]) => any>",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>() => FunctionChain<(obj: TObj) => TResult>",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "() => LoDashExplicitWrapper<(path: PropertyPath) => any>",
                "optional": false
              },
              {
                "name": "range",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "(end?: number, step?: number) => CollectionChain<number>",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => CollectionChain<any>",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): PrimitiveChain<false>; (): LoDashExplicitWrapper<false>; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => LoDashExplicitWrapper<any>",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => StringChain<string>",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): PrimitiveChain<true>; (): LoDashExplicitWrapper<true>; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(iteratee: (num: number) => TResult): CollectionChain<TResult>; (): CollectionChain<number>; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "() => CollectionChain<string>",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "() => StringChain<string>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "FunctionBind",
            "type": "FunctionBind",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "FunctionBindKey",
            "type": "FunctionBindKey",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Curry",
            "type": "Curry",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurriedFunction1",
            "type": "CurriedFunction1<T1, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurriedFunction2",
            "type": "CurriedFunction2<T1, T2, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurriedFunction3",
            "type": "CurriedFunction3<T1, T2, T3, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurriedFunction4",
            "type": "CurriedFunction4<T1, T2, T3, T4, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurriedFunction5",
            "type": "CurriedFunction5<T1, T2, T3, T4, T5, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RightCurriedFunction1",
            "type": "RightCurriedFunction1<T1, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RightCurriedFunction2",
            "type": "RightCurriedFunction2<T1, T2, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RightCurriedFunction3",
            "type": "RightCurriedFunction3<T1, T2, T3, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RightCurriedFunction4",
            "type": "RightCurriedFunction4<T1, T2, T3, T4, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "RightCurriedFunction5",
            "type": "RightCurriedFunction5<T1, T2, T3, T4, T5, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CurryRight",
            "type": "CurryRight",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DebounceSettings",
            "type": "DebounceSettings",
            "properties": [
              {
                "name": "leading",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "maxWait",
                "type": "number",
                "optional": true
              },
              {
                "name": "trailing",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DebounceSettingsLeading",
            "type": "DebounceSettingsLeading",
            "properties": [
              {
                "name": "leading",
                "type": "true",
                "optional": false
              },
              {
                "name": "maxWait",
                "type": "number",
                "optional": true
              },
              {
                "name": "trailing",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [
              "DebounceSettings"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DebouncedFunc",
            "type": "DebouncedFunc<T>",
            "properties": [
              {
                "name": "cancel",
                "type": "() => void",
                "optional": false
              },
              {
                "name": "flush",
                "type": "() => ReturnType<T>",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "DebouncedFuncLeading",
            "type": "DebouncedFuncLeading<T>",
            "properties": [
              {
                "name": "flush",
                "type": "() => ReturnType<T>",
                "optional": false
              },
              {
                "name": "cancel",
                "type": "() => void",
                "optional": false
              }
            ],
            "extends": [
              "DebouncedFunc<T>"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MemoizedFunction",
            "type": "MemoizedFunction",
            "properties": [
              {
                "name": "cache",
                "type": "MapCache",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "__",
            "type": "LoDashStatic",
            "properties": [
              {
                "name": "VERSION",
                "type": "string",
                "optional": false
              },
              {
                "name": "templateSettings",
                "type": "TemplateSettings",
                "optional": false
              },
              {
                "name": "chunk",
                "type": "<T>(array: List<T>, size?: number) => T[][]",
                "optional": false
              },
              {
                "name": "compact",
                "type": "<T>(array: List<T | Falsey>) => T[]",
                "optional": false
              },
              {
                "name": "concat",
                "type": "<T>(...values: Many<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "difference",
                "type": "<T>(array: List<T>, ...values: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "differenceBy",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, values3: List<...>, iteratee: ValueIteratee<...>)...",
                "optional": false
              },
              {
                "name": "differenceWith",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
                "optional": false
              },
              {
                "name": "drop",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "dropRight",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "dropRightWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "dropWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "fill",
                "type": "{ <T>(array: any[], value: T): T[]; <T>(array: List<any>, value: T): List<T>; <T, U>(array: U[], value: T, start?: number, end?: number): (T | U)[]; <T, U>(array: List<U>, value: T, start?: number, end?: number): List<...>; }",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "findLastIndex",
                "type": "<T>(array: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "first",
                "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
                "optional": false
              },
              {
                "name": "flatten",
                "type": "<T>(array: List<Many<T>>) => T[]",
                "optional": false
              },
              {
                "name": "flattenDeep",
                "type": "<T>(array: ListOfRecursiveArraysOrValues<T>) => Flat<T>[]",
                "optional": false
              },
              {
                "name": "flattenDepth",
                "type": "<T>(array: ListOfRecursiveArraysOrValues<T>, depth?: number) => T[]",
                "optional": false
              },
              {
                "name": "fromPairs",
                "type": "{ <T>(pairs: List<[PropertyName, T]>): Dictionary<T>; (pairs: List<any[]>): Dictionary<any>; }",
                "optional": false
              },
              {
                "name": "head",
                "type": "{ <T>(array: readonly [T, ...unknown[]]): T; <T>(array: List<T>): T; }",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "<T>(array: List<T>, value: T, fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "initial",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "intersection",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "intersectionBy",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | ValueIteratee<...>)[]): T...",
                "optional": false
              },
              {
                "name": "intersectionWith",
                "type": "{ <T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): T1[]; <T1, T2, T3>(array: List<T1>, values1: List<T2>, values2: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2, T3, T4>(array: List<...>, values1: List<...>, values2: List<...>, ...values: (List<...> | Comparator2<...>)[]): T1[]...",
                "optional": false
              },
              {
                "name": "join",
                "type": "(array: List<any>, separator?: string) => string",
                "optional": false
              },
              {
                "name": "last",
                "type": "<T>(array: List<T>) => T",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "<T>(array: List<T>, value: T, fromIndex?: number | true) => number",
                "optional": false
              },
              {
                "name": "nth",
                "type": "<T>(array: List<T>, n?: number) => T",
                "optional": false
              },
              {
                "name": "pull",
                "type": "{ <T>(array: T[], ...values: T[]): T[]; <T>(array: List<T>, ...values: T[]): List<T>; }",
                "optional": false
              },
              {
                "name": "pullAll",
                "type": "{ <T>(array: T[], values?: List<T>): T[]; <T>(array: List<T>, values?: List<T>): List<T>; }",
                "optional": false
              },
              {
                "name": "pullAllBy",
                "type": "{ <T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, iteratee: ValueIteratee<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, iteratee: ValueIteratee<...>): List<...>; }",
                "optional": false
              },
              {
                "name": "pullAllWith",
                "type": "{ <T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[]; <T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<...>; <T1, T2>(array: T1[], values: List<...>, comparator: Comparator2<...>): T1[]; <T1, T2>(array: List<...>, values: List<...>, comparator: Comparator2<...>): List<...>; }",
                "optional": false
              },
              {
                "name": "pullAt",
                "type": "{ <T>(array: T[], ...indexes: Many<number>[]): T[]; <T>(array: List<T>, ...indexes: Many<number>[]): List<T>; }",
                "optional": false
              },
              {
                "name": "remove",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "<TList extends List<any>>(array: TList) => TList",
                "optional": false
              },
              {
                "name": "slice",
                "type": "<T>(array: List<T>, start?: number, end?: number) => T[]",
                "optional": false
              },
              {
                "name": "sortedIndex",
                "type": "{ <T>(array: List<T>, value: T): number; <T>(array: List<T>, value: T): number; }",
                "optional": false
              },
              {
                "name": "sortedIndexBy",
                "type": "<T>(array: List<T>, value: T, iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedIndexOf",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndex",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexBy",
                "type": "<T>(array: List<T>, value: T, iteratee: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "sortedLastIndexOf",
                "type": "<T>(array: List<T>, value: T) => number",
                "optional": false
              },
              {
                "name": "sortedUniq",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "sortedUniqBy",
                "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "tail",
                "type": "{ <T extends unknown[]>(array: readonly [unknown, ...T]): T; <T>(array: List<T>): T[]; }",
                "optional": false
              },
              {
                "name": "take",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "takeRight",
                "type": "<T>(array: List<T>, n?: number) => T[]",
                "optional": false
              },
              {
                "name": "takeRightWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "takeWhile",
                "type": "<T>(array: List<T>, predicate?: ListIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "union",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "unionBy",
                "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee?: ValueIteratee<...>): T[]; <T>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>,...",
                "optional": false
              },
              {
                "name": "unionWith",
                "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "uniq",
                "type": "<T>(array: List<T>) => T[]",
                "optional": false
              },
              {
                "name": "uniqBy",
                "type": "<T>(array: List<T>, iteratee: ValueIteratee<T>) => T[]",
                "optional": false
              },
              {
                "name": "uniqWith",
                "type": "<T>(array: List<T>, comparator?: Comparator<T>) => T[]",
                "optional": false
              },
              {
                "name": "unzip",
                "type": "<T>(array: T[][] | List<List<T>>) => T[][]",
                "optional": false
              },
              {
                "name": "unzipWith",
                "type": "{ <T, TResult>(array: List<List<T>>, iteratee: (...values: T[]) => TResult): TResult[]; <T>(array: List<List<T>>): T[][]; }",
                "optional": false
              },
              {
                "name": "without",
                "type": "<T>(array: List<T>, ...values: T[]) => T[]",
                "optional": false
              },
              {
                "name": "xor",
                "type": "<T>(...arrays: List<T>[]) => T[]",
                "optional": false
              },
              {
                "name": "xorBy",
                "type": "{ <T>(arrays: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, iteratee?: ValueIteratee<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...iteratee: (ValueIteratee<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "xorWith",
                "type": "{ <T>(arrays: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<T>, arrays2: List<T>, comparator?: Comparator<T>): T[]; <T>(arrays: List<...>, arrays2: List<...>, arrays3: List<...>, ...comparator: (Comparator<...> | List<...>)[]): T[]; }",
                "optional": false
              },
              {
                "name": "zip",
                "type": "{ <T1, T2>(arrays1: List<T1>, arrays2: List<T2>): [T1, T2][]; <T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): [...][]; <T1, T2, T3, T4>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, arrays4: List<...>): [...][]; <T1, T2, T3, T4, T5>(arrays1: List<...>, arrays2: List<...>, arrays3...",
                "optional": false
              },
              {
                "name": "zipObject",
                "type": "{ <T>(props: List<PropertyName>, values: List<T>): Dictionary<T>; (props?: List<PropertyName>): Dictionary<undefined>; }",
                "optional": false
              },
              {
                "name": "zipObjectDeep",
                "type": "(paths?: List<PropertyPath>, values?: List<any>) => object",
                "optional": false
              },
              {
                "name": "zipWith",
                "type": "{ <T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[]; <T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[]; <T1, T2, T3, TResult>(arrays1: List<...>, arrays2: List<...>, arrays3: List<...>, iteratee: (value1: T1, value2: T2, value3:...",
                "optional": false
              },
              {
                "name": "countBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<number>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "each",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "eachRight",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "every",
                "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>): S[]; <T>(collection: List<...>, predicate?: ListIterateeCustom<...>): T[]; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<....",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
                "optional": false
              },
              {
                "name": "findLast",
                "type": "{ <T, S extends T>(collection: List<T>, predicate: ListIteratorTypeGuard<T, S>, fromIndex?: number): S; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): T; <T extends object, S extends T[keyof T]>(collection: T, predicate: ObjectIteratorTypeGuard<...>, fromIndex?: number): S;...",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "{ <T>(collection: Dictionary<Many<T>> | NumericDictionary<Many<T>>): T[]; (collection: object): any[]; <T, TResult>(collection: List<T>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, iteratee: string): any[]; (colle...",
                "optional": false
              },
              {
                "name": "flatMapDeep",
                "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>): TResult[]; (collection: object, i...",
                "optional": false
              },
              {
                "name": "flatMapDepth",
                "type": "{ <T>(collection: Dictionary<T | ListOfRecursiveArraysOrValues<T>> | NumericDictionary<T | ListOfRecursiveArraysOrValues<T>>): T[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>, depth?: number): TResult[]; <T extends object, TResult>(collection: T, iteratee: ObjectIterator<...>, depth?: number): T...",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "forEachRight",
                "type": "{ <T>(collection: T[], iteratee?: ArrayIterator<T, any>): T[]; (collection: string, iteratee?: StringIterator<any>): string; <T>(collection: List<T>, iteratee?: ListIterator<...>): List<...>; <T extends object>(collection: T, iteratee?: ObjectIterator<...>): T; <T, TArray extends T[] | null | undefined>(collection: ...",
                "optional": false
              },
              {
                "name": "groupBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIteratee<T>): Dictionary<T[]>; <T extends object>(collection: T, iteratee?: ValueIteratee<T[keyof T]>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "includes",
                "type": "<T>(collection: Dictionary<T> | NumericDictionary<T>, target: T, fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "invokeMap",
                "type": "{ (collection: object, methodName: string, ...args: any[]): any[]; <TResult>(collection: object, method: (...args: any[]) => TResult, ...args: any[]): TResult[]; }",
                "optional": false
              },
              {
                "name": "keyBy",
                "type": "{ <T>(collection: List<T>, iteratee?: ValueIterateeCustom<T, PropertyName>): Dictionary<T>; <T extends object>(collection: T, iteratee?: ValueIterateeCustom<...>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "map",
                "type": "{ <T extends readonly [unknown, ...unknown[]], TResult>(collection: T, iteratee: TupleIterator<T, TResult>): { [K in keyof T]: TResult; }; <T, TResult>(collection: T[], iteratee: ArrayIterator<...>): TResult[]; <T, TResult>(collection: List<...>, iteratee: ListIterator<...>): TResult[]; <T>(collection: Dictionary<.....",
                "optional": false
              },
              {
                "name": "orderBy",
                "type": "{ <T>(collection: List<T>, iteratees?: Many<ListIterator<T, unknown>>, orders?: Many<boolean | \"asc\" | \"desc\">): T[]; <T>(collection: List<T>, iteratees?: Many<...>, orders?: Many<...>): T[]; <T extends object>(collection: T, iteratees?: Many<...>, orders?: Many<...>): T[keyof T][]; <T extends object>(collection: T,...",
                "optional": false
              },
              {
                "name": "partition",
                "type": "{ <T, U extends T>(collection: List<T>, callback: ValueIteratorTypeGuard<T, U>): [U[], Exclude<T, U>[]]; <T>(collection: List<T>, callback: ValueIteratee<...>): [...]; <T extends object>(collection: T, callback: ValueIteratee<...>): [...]; }",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ <T, TResult>(collection: T[], callback: MemoListIterator<T, TResult, T[]>, accumulator: TResult): TResult; <T, TResult>(collection: List<T>, callback: MemoListIterator<...>, accumulator: TResult): TResult; <T extends object, TResult>(collection: T, callback: MemoObjectIterator<...>, accumulator: TResult): TResult;...",
                "optional": false
              },
              {
                "name": "reject",
                "type": "{ (collection: string, predicate?: StringIterator<boolean>): string[]; <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): T[]; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<...>): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "sample",
                "type": "{ <T>(collection: readonly [T, ...T[]]): T; <T>(collection: Dictionary<T> | NumericDictionary<T>): T; <T extends object>(collection: T): T[keyof T]; }",
                "optional": false
              },
              {
                "name": "sampleSize",
                "type": "{ <T>(collection: Dictionary<T> | NumericDictionary<T>, n?: number): T[]; <T extends object>(collection: T, n?: number): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "shuffle",
                "type": "{ <T>(collection: List<T>): T[]; <T extends object>(collection: T): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "size",
                "type": "(collection: string | object) => number",
                "optional": false
              },
              {
                "name": "some",
                "type": "{ <T>(collection: List<T>, predicate?: ListIterateeCustom<T, boolean>): boolean; <T extends object>(collection: T, predicate?: ObjectIterateeCustom<T, boolean>): boolean; }",
                "optional": false
              },
              {
                "name": "sortBy",
                "type": "{ <T>(collection: List<T>, ...iteratees: Many<ListIteratee<T>>[]): T[]; <T extends object>(collection: T, ...iteratees: Many<ObjectIteratee<T>>[]): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "now",
                "type": "() => number",
                "optional": false
              },
              {
                "name": "after",
                "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
                "optional": false
              },
              {
                "name": "ary",
                "type": "(func: (...args: any[]) => any, n?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "before",
                "type": "<TFunc extends (...args: any[]) => any>(n: number, func: TFunc) => TFunc",
                "optional": false
              },
              {
                "name": "bind",
                "type": "FunctionBind",
                "optional": false
              },
              {
                "name": "bindKey",
                "type": "FunctionBindKey",
                "optional": false
              },
              {
                "name": "curry",
                "type": "Curry",
                "optional": false
              },
              {
                "name": "curryRight",
                "type": "CurryRight",
                "optional": false
              },
              {
                "name": "debounce",
                "type": "{ <T extends (...args: any) => any>(func: T, wait: number, options: DebounceSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<...>; }",
                "optional": false
              },
              {
                "name": "defer",
                "type": "(func: (...args: any[]) => any, ...args: any[]) => number",
                "optional": false
              },
              {
                "name": "delay",
                "type": "(func: (...args: any[]) => any, wait: number, ...args: any[]) => number",
                "optional": false
              },
              {
                "name": "flip",
                "type": "<T extends (...args: any) => any>(func: T) => T",
                "optional": false
              },
              {
                "name": "memoize",
                "type": "{ <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction; Cache: MapCacheConstructor; }",
                "optional": false
              },
              {
                "name": "negate",
                "type": "<T extends any[]>(predicate: (...args: T) => boolean) => (...args: T) => boolean",
                "optional": false
              },
              {
                "name": "once",
                "type": "<T extends (...args: any) => any>(func: T) => T",
                "optional": false
              },
              {
                "name": "overArgs",
                "type": "(func: (...args: any[]) => any, ...transforms: Many<(...args: any[]) => any>[]) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "partial",
                "type": "Partial",
                "optional": false
              },
              {
                "name": "partialRight",
                "type": "PartialRight",
                "optional": false
              },
              {
                "name": "rearg",
                "type": "(func: (...args: any[]) => any, ...indexes: Many<number>[]) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "rest",
                "type": "(func: (...args: any[]) => any, start?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "spread",
                "type": "<TResult>(func: (...args: any[]) => TResult, start?: number) => (...args: any[]) => TResult",
                "optional": false
              },
              {
                "name": "throttle",
                "type": "{ <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettingsLeading): DebouncedFuncLeading<T>; <T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<...>; }",
                "optional": false
              },
              {
                "name": "unary",
                "type": "<T, TResult>(func: (arg1: T, ...args: any[]) => TResult) => (arg1: T) => TResult",
                "optional": false
              },
              {
                "name": "wrap",
                "type": "<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult) => (...args: TArgs[]) => TResult",
                "optional": false
              },
              {
                "name": "castArray",
                "type": "<T>(value?: Many<T>) => T[]",
                "optional": false
              },
              {
                "name": "clone",
                "type": "<T>(value: T) => T",
                "optional": false
              },
              {
                "name": "cloneDeep",
                "type": "<T>(value: T) => T",
                "optional": false
              },
              {
                "name": "cloneDeepWith",
                "type": "{ <T>(value: T, customizer: CloneDeepWithCustomizer<T>): any; <T>(value: T): T; }",
                "optional": false
              },
              {
                "name": "cloneWith",
                "type": "{ <T, TResult extends object | string | number | boolean | null>(value: T, customizer: CloneWithCustomizer<T, TResult>): TResult; <T, TResult>(value: T, customizer: CloneWithCustomizer<...>): T | TResult; <T>(value: T): T; }",
                "optional": false
              },
              {
                "name": "conformsTo",
                "type": "<T>(object: T, source: ConformsPredicateObject<T>) => boolean",
                "optional": false
              },
              {
                "name": "eq",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "gt",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "gte",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "isArguments",
                "type": "(value?: any) => value is IArguments",
                "optional": false
              },
              {
                "name": "isArray",
                "type": "{ (value?: any): value is any[]; <T>(value?: any): value is any[]; }",
                "optional": false
              },
              {
                "name": "isArrayBuffer",
                "type": "(value?: any) => value is ArrayBuffer",
                "optional": false
              },
              {
                "name": "isArrayLike",
                "type": "{ <T extends { __lodashAnyHack: any; }>(t: T): boolean; (value: (...args: any[]) => any): value is never; (value: any): value is { length: number; }; }",
                "optional": false
              },
              {
                "name": "isArrayLikeObject",
                "type": "{ <T extends { __lodashAnyHack: any; }>(value: T): boolean; (value: string | number | boolean | Function | ((...args: any[]) => any)): value is never; (value: any): value is object & { length: number; }; }",
                "optional": false
              },
              {
                "name": "isBoolean",
                "type": "(value?: any) => value is boolean",
                "optional": false
              },
              {
                "name": "isBuffer",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isDate",
                "type": "(value?: any) => value is Date",
                "optional": false
              },
              {
                "name": "isElement",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isEmpty",
                "type": "{ <T extends { __trapAny: any; }>(value?: T): boolean; (value: string): value is \"\"; (value: List<any> | Map<any, any> | Set<any>): boolean; (value: object): boolean; <T extends object>(value: T): value is EmptyObjectOf<...>; (value?: any): boolean; }",
                "optional": false
              },
              {
                "name": "isEqual",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "isEqualWith",
                "type": "(value: any, other: any, customizer?: IsEqualCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isError",
                "type": "(value: any) => value is Error",
                "optional": false
              },
              {
                "name": "isFinite",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isFunction",
                "type": "(value: any) => value is (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "isInteger",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isLength",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isMap",
                "type": "(value?: any) => value is Map<any, any>",
                "optional": false
              },
              {
                "name": "isMatch",
                "type": "(object: object, source: object) => boolean",
                "optional": false
              },
              {
                "name": "isMatchWith",
                "type": "(object: object, source: object, customizer: isMatchWithCustomizer) => boolean",
                "optional": false
              },
              {
                "name": "isNaN",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isNative",
                "type": "(value: any) => value is (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "isNil",
                "type": "(value: any) => value is null",
                "optional": false
              },
              {
                "name": "isNull",
                "type": "(value: any) => value is null",
                "optional": false
              },
              {
                "name": "isNumber",
                "type": "(value?: any) => value is number",
                "optional": false
              },
              {
                "name": "isObject",
                "type": "(value?: any) => value is object",
                "optional": false
              },
              {
                "name": "isObjectLike",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isPlainObject",
                "type": "(value?: any) => boolean",
                "optional": false
              },
              {
                "name": "isRegExp",
                "type": "(value?: any) => value is RegExp",
                "optional": false
              },
              {
                "name": "isSafeInteger",
                "type": "(value: any) => boolean",
                "optional": false
              },
              {
                "name": "isSet",
                "type": "(value?: any) => value is Set<any>",
                "optional": false
              },
              {
                "name": "isString",
                "type": "(value?: any) => value is string",
                "optional": false
              },
              {
                "name": "isSymbol",
                "type": "(value: any) => value is symbol",
                "optional": false
              },
              {
                "name": "isTypedArray",
                "type": "(value: any) => boolean",
                "optional": false
              },
              {
                "name": "isUndefined",
                "type": "(value: any) => value is undefined",
                "optional": false
              },
              {
                "name": "isWeakMap",
                "type": "(value?: any) => value is WeakMap<object, any>",
                "optional": false
              },
              {
                "name": "isWeakSet",
                "type": "(value?: any) => value is WeakSet<object>",
                "optional": false
              },
              {
                "name": "lt",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "lte",
                "type": "(value: any, other: any) => boolean",
                "optional": false
              },
              {
                "name": "toArray",
                "type": "{ <T>(value: Dictionary<T> | NumericDictionary<T>): T[]; <T>(value: T): T[keyof T][]; (): any[]; }",
                "optional": false
              },
              {
                "name": "toFinite",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toInteger",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toLength",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toNumber",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toPlainObject",
                "type": "(value?: any) => any",
                "optional": false
              },
              {
                "name": "toSafeInteger",
                "type": "(value: any) => number",
                "optional": false
              },
              {
                "name": "toString",
                "type": "(value: any) => string",
                "optional": false
              },
              {
                "name": "add",
                "type": "(augend: number, addend: number) => number",
                "optional": false
              },
              {
                "name": "ceil",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "divide",
                "type": "(dividend: number, divisor: number) => number",
                "optional": false
              },
              {
                "name": "floor",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "max",
                "type": "<T>(collection: List<T>) => T",
                "optional": false
              },
              {
                "name": "maxBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "mean",
                "type": "(collection: List<any>) => number",
                "optional": false
              },
              {
                "name": "meanBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => number",
                "optional": false
              },
              {
                "name": "min",
                "type": "<T>(collection: List<T>) => T",
                "optional": false
              },
              {
                "name": "minBy",
                "type": "<T>(collection: List<T>, iteratee?: ValueIteratee<T>) => T",
                "optional": false
              },
              {
                "name": "multiply",
                "type": "(multiplier: number, multiplicand: number) => number",
                "optional": false
              },
              {
                "name": "round",
                "type": "(n: number, precision?: number) => number",
                "optional": false
              },
              {
                "name": "subtract",
                "type": "(minuend: number, subtrahend: number) => number",
                "optional": false
              },
              {
                "name": "sum",
                "type": "(collection: List<any>) => number",
                "optional": false
              },
              {
                "name": "sumBy",
                "type": "<T>(collection: List<T>, iteratee?: string | ((value: T) => number)) => number",
                "optional": false
              },
              {
                "name": "clamp",
                "type": "{ (number: number, lower: number, upper: number): number; (number: number, upper: number): number; }",
                "optional": false
              },
              {
                "name": "inRange",
                "type": "(n: number, start: number, end?: number) => boolean",
                "optional": false
              },
              {
                "name": "random",
                "type": "{ (floating?: boolean): number; (max: number, floating?: boolean): number; (min: number, max: number, floating?: boolean): number; (min: number, index: string | number, guard: object): number; }",
                "optional": false
              },
              {
                "name": "assign",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "assignIn",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "assignInWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "assignWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "at",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, ...props: PropertyPath[]): T[]; <T extends object>(object: T, ...props: Many<keyof T>[]): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "create",
                "type": "<T extends object, U extends object>(prototype: T, properties?: U) => T & U",
                "optional": false
              },
              {
                "name": "defaults",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<...>; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullabl...",
                "optional": false
              },
              {
                "name": "defaultsDeep",
                "type": "(object: any, ...sources: any[]) => any",
                "optional": false
              },
              {
                "name": "entries",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "entriesIn",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "extend",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "extendWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, so...",
                "optional": false
              },
              {
                "name": "findKey",
                "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "findLastKey",
                "type": "<T>(object: T, predicate?: ObjectIteratee<T>) => string",
                "optional": false
              },
              {
                "name": "forIn",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forInRight",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forOwn",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "forOwnRight",
                "type": "{ <T>(object: T, iteratee?: ObjectIterator<T, any>): T; <T>(object: T, iteratee?: ObjectIterator<T, any>): T; }",
                "optional": false
              },
              {
                "name": "functions",
                "type": "(object: any) => string[]",
                "optional": false
              },
              {
                "name": "functionsIn",
                "type": "<T extends {}>(object: any) => string[]",
                "optional": false
              },
              {
                "name": "get",
                "type": "{ <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [...]): TObject[TKey]; <TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject, path: TKey | [...], de...",
                "optional": false
              },
              {
                "name": "has",
                "type": "{ <T, K extends PropertyName>(object: T, path: K): object is T & { [P in K]: P extends keyof T ? T[P] : Record<string, unknown> extends T ? T[keyof T] : unknown; } & { ...; }; <T>(object: T, path: PropertyPath): boolean; }",
                "optional": false
              },
              {
                "name": "hasIn",
                "type": "<T>(object: T, path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "invert",
                "type": "(object: object) => Dictionary<string>",
                "optional": false
              },
              {
                "name": "invertBy",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T>, interatee?: ValueIteratee<T>): Dictionary<string[]>; <T extends object>(object: T, interatee?: ValueIteratee<...>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "invoke",
                "type": "(object: any, path: PropertyPath, ...args: any[]) => any",
                "optional": false
              },
              {
                "name": "keys",
                "type": "(object?: any) => string[]",
                "optional": false
              },
              {
                "name": "keysIn",
                "type": "(object?: any) => string[]",
                "optional": false
              },
              {
                "name": "mapKeys",
                "type": "{ <T>(object: List<T>, iteratee?: ListIteratee<T>): Dictionary<T>; <T extends object>(object: T, iteratee?: ObjectIteratee<T>): Dictionary<...>; }",
                "optional": false
              },
              {
                "name": "mapValues",
                "type": "{ <TResult>(obj: string, callback: StringIterator<TResult>): NumericDictionary<TResult>; <T, TResult>(array: T[], callback: ArrayIterator<T, TResult>): NumericDictionary<...>; <T extends object, TResult>(obj: T, callback: ObjectIterator<...>): { [P in keyof T]: TResult; }; <T>(obj: Dictionary<...> | NumericDictionar...",
                "optional": false
              },
              {
                "name": "merge",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & ... 1 more ... & TSource2; <TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObj...",
                "optional": false
              },
              {
                "name": "mergeWith",
                "type": "{ <TObject, TSource>(object: TObject, source: TSource, customizer: (value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any): TObject & TSource; <TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: (value: any, srcValue: any, key: string, objec...",
                "optional": false
              },
              {
                "name": "omit",
                "type": "{ <T extends object, K extends PropertyName[]>(object: T, ...paths: K): Pick<T, Exclude<keyof T, K[number]>>; <T extends object, K extends keyof T>(object: T, ...paths: Many<K>[]): Omit<...>; <T extends object>(object: T, ...paths: Many<...>[]): Partial<...>; }",
                "optional": false
              },
              {
                "name": "omitBy",
                "type": "{ <T>(object: Dictionary<T>, predicate?: ValueKeyIteratee<T>): Dictionary<T>; <T>(object: NumericDictionary<T>, predicate?: ValueKeyIteratee<...>): NumericDictionary<...>; <T extends object>(object: T, predicate: ValueKeyIteratee<...>): Partial<...>; }",
                "optional": false
              },
              {
                "name": "pick",
                "type": "{ <T extends object, U extends keyof T>(object: T, ...props: Many<U>[]): Pick<T, U>; <T>(object: T, ...props: Many<PropertyPath>[]): Partial<T>; }",
                "optional": false
              },
              {
                "name": "pickBy",
                "type": "{ <T, S extends T>(object: Dictionary<T>, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>; <T, S extends T>(object: NumericDictionary<T>, predicate: ValueKeyIterateeTypeGuard<...>): NumericDictionary<...>; <T>(object: Dictionary<...>, predicate?: ValueKeyIteratee<...>): Dictionary<...>; <T>(object: Numeri...",
                "optional": false
              },
              {
                "name": "result",
                "type": "<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)) => TResult",
                "optional": false
              },
              {
                "name": "set",
                "type": "{ <T extends object>(object: T, path: PropertyPath, value: any): T; <TResult>(object: object, path: PropertyPath, value: any): TResult; }",
                "optional": false
              },
              {
                "name": "setWith",
                "type": "{ <T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<...>): TResult; }",
                "optional": false
              },
              {
                "name": "toPairs",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "toPairsIn",
                "type": "{ <T>(object?: Dictionary<T> | NumericDictionary<T>): [string, T][]; (object?: object): [string, any][]; }",
                "optional": false
              },
              {
                "name": "transform",
                "type": "{ <T, TResult>(object: readonly T[], iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult; <T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<...>, accumulator?: TResult): TResult; <T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<...>, accumula...",
                "optional": false
              },
              {
                "name": "unset",
                "type": "(object: any, path: PropertyPath) => boolean",
                "optional": false
              },
              {
                "name": "update",
                "type": "(object: object, path: PropertyPath, updater: (value: any) => any) => any",
                "optional": false
              },
              {
                "name": "updateWith",
                "type": "{ <T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T; <T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<...>): TResult; }",
                "optional": false
              },
              {
                "name": "values",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; (object: any): any[]; }",
                "optional": false
              },
              {
                "name": "valuesIn",
                "type": "{ <T>(object: Dictionary<T> | NumericDictionary<T> | List<T>): T[]; <T extends object>(object: T): T[keyof T][]; }",
                "optional": false
              },
              {
                "name": "chain",
                "type": "{ <TrapAny extends { __lodashAnyHack: any; }>(value: TrapAny): CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain<...>; <T extends null | undefined>(value: T): PrimitiveChain<...>; <T extends string>(value: T): StringChain<...>; (value: string): StringNullableChain; <T e...",
                "optional": false
              },
              {
                "name": "tap",
                "type": "<T>(value: T, interceptor: (value: T) => void) => T",
                "optional": false
              },
              {
                "name": "thru",
                "type": "<T, TResult>(value: T, interceptor: (value: T) => TResult) => TResult",
                "optional": false
              },
              {
                "name": "camelCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "capitalize",
                "type": "<T extends string>(string?: T) => string extends T ? string : Capitalize<Lowercase<T>>",
                "optional": false
              },
              {
                "name": "deburr",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "endsWith",
                "type": "(string?: string, target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "escape",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "escapeRegExp",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "kebabCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "lowerCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "lowerFirst",
                "type": "<T extends string = string>(string?: T) => Uncapitalize<T>",
                "optional": false
              },
              {
                "name": "pad",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padEnd",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "padStart",
                "type": "(string?: string, length?: number, chars?: string) => string",
                "optional": false
              },
              {
                "name": "parseInt",
                "type": "(string: string, radix?: number) => number",
                "optional": false
              },
              {
                "name": "repeat",
                "type": "(string?: string, n?: number) => string",
                "optional": false
              },
              {
                "name": "replace",
                "type": "{ (string: string, pattern: string | RegExp, replacement: string | ReplaceFunction): string; (pattern: string | RegExp, replacement: string | ReplaceFunction): string; }",
                "optional": false
              },
              {
                "name": "snakeCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "split",
                "type": "{ (string: string, separator?: string | RegExp, limit?: number): string[]; (string: string, index: string | number, guard: object): string[]; }",
                "optional": false
              },
              {
                "name": "startCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "startsWith",
                "type": "(string?: string, target?: string, position?: number) => boolean",
                "optional": false
              },
              {
                "name": "template",
                "type": "(string?: string, options?: TemplateOptions) => TemplateExecutor",
                "optional": false
              },
              {
                "name": "toLower",
                "type": "<T extends string = string>(string?: T) => Lowercase<T>",
                "optional": false
              },
              {
                "name": "toUpper",
                "type": "<T extends string = string>(string?: T) => Uppercase<T>",
                "optional": false
              },
              {
                "name": "trim",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "trimEnd",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "trimStart",
                "type": "{ (string?: string, chars?: string): string; (string: string, index: string | number, guard: object): string; }",
                "optional": false
              },
              {
                "name": "truncate",
                "type": "(string?: string, options?: TruncateOptions) => string",
                "optional": false
              },
              {
                "name": "unescape",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "upperCase",
                "type": "(string?: string) => string",
                "optional": false
              },
              {
                "name": "upperFirst",
                "type": "<T extends string = string>(string?: T) => Capitalize<T>",
                "optional": false
              },
              {
                "name": "words",
                "type": "{ (string?: string, pattern?: string | RegExp): string[]; (string: string, index: string | number, guard: object): string[]; }",
                "optional": false
              },
              {
                "name": "attempt",
                "type": "<TResult>(func: (...args: any[]) => TResult, ...args: any[]) => Error | TResult",
                "optional": false
              },
              {
                "name": "bindAll",
                "type": "<T>(object: T, ...methodNames: Many<string>[]) => T",
                "optional": false
              },
              {
                "name": "cond",
                "type": "{ <R>(pairs: CondPairNullary<R>[]): () => R; <T, R>(pairs: CondPairUnary<T, R>[]): (Target: T) => R; }",
                "optional": false
              },
              {
                "name": "conforms",
                "type": "<T>(source: ConformsPredicateObject<T>) => (value: T) => boolean",
                "optional": false
              },
              {
                "name": "constant",
                "type": "<T>(value: T) => () => T",
                "optional": false
              },
              {
                "name": "defaultTo",
                "type": "{ <T>(value: T, defaultValue: T): T; <T, TDefault>(value: T, defaultValue: TDefault): T | TDefault; }",
                "optional": false
              },
              {
                "name": "flow",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4: (a: R3) => R4, f5: (a: R4) => R5, f6: (a: R5) => R6, f7: (a: R6) => R7): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f1: (...args: A) => R1, f2: (a: R1) => R2, f3: (a: R2) => R3, f4...",
                "optional": false
              },
              {
                "name": "flowRight",
                "type": "{ <A extends any[], R1, R2, R3, R4, R5, R6, R7>(f7: (a: R6) => R7, f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2) => R3, f2: (a: R1) => R2, f1: (...args: A) => R1): (...args: A) => R7; <A extends any[], R1, R2, R3, R4, R5, R6>(f6: (a: R5) => R6, f5: (a: R4) => R5, f4: (a: R3) => R4, f3: (a: R2)...",
                "optional": false
              },
              {
                "name": "identity",
                "type": "{ <T>(value: T): T; (): undefined; }",
                "optional": false
              },
              {
                "name": "iteratee",
                "type": "{ <TFunction extends (...args: any[]) => any>(func: TFunction): TFunction; (func: string | number | symbol | object): (...args: any[]) => any; }",
                "optional": false
              },
              {
                "name": "matches",
                "type": "{ <T>(source: T): (value: any) => boolean; <T, V>(source: T): (value: V) => boolean; }",
                "optional": false
              },
              {
                "name": "matchesProperty",
                "type": "{ <T>(path: PropertyPath, srcValue: T): (value: any) => boolean; <T, V>(path: PropertyPath, srcValue: T): (value: V) => boolean; }",
                "optional": false
              },
              {
                "name": "method",
                "type": "(path: PropertyPath, ...args: any[]) => (object: any) => any",
                "optional": false
              },
              {
                "name": "methodOf",
                "type": "(object: object, ...args: any[]) => (path: PropertyPath) => any",
                "optional": false
              },
              {
                "name": "mixin",
                "type": "{ <TObject>(object: TObject, source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): TObject; <TResult>(source: Dictionary<(...args: any[]) => any>, options?: MixinOptions): LoDashStatic; }",
                "optional": false
              },
              {
                "name": "noConflict",
                "type": "() => LoDashStatic",
                "optional": false
              },
              {
                "name": "noop",
                "type": "(...args: any[]) => void",
                "optional": false
              },
              {
                "name": "nthArg",
                "type": "(n?: number) => (...args: any[]) => any",
                "optional": false
              },
              {
                "name": "over",
                "type": "<TResult>(...iteratees: Many<(...args: any[]) => TResult>[]) => (...args: any[]) => TResult[]",
                "optional": false
              },
              {
                "name": "overEvery",
                "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 & Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
                "optional": false
              },
              {
                "name": "overSome",
                "type": "{ <T, Result1 extends T, Result2 extends T>(predicates_0: (arg: T) => arg is Result1, predicates_1: (arg: T) => arg is Result2): (arg: T) => arg is Result1 | Result2; <T>(...predicates: Many<(...args: T[]) => boolean>[]): (...args: T[]) => boolean; }",
                "optional": false
              },
              {
                "name": "property",
                "type": "<TObj, TResult>(path: PropertyPath) => (obj: TObj) => TResult",
                "optional": false
              },
              {
                "name": "propertyOf",
                "type": "<T extends {}>(object: T) => (path: PropertyPath) => any",
                "optional": false
              },
              {
                "name": "range",
                "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
                "optional": false
              },
              {
                "name": "rangeRight",
                "type": "{ (start: number, end?: number, step?: number): number[]; (end: number, index: string | number, guard: object): number[]; }",
                "optional": false
              },
              {
                "name": "runInContext",
                "type": "(context?: object) => LoDashStatic",
                "optional": false
              },
              {
                "name": "stubArray",
                "type": "() => any[]",
                "optional": false
              },
              {
                "name": "stubFalse",
                "type": "{ (): false; (): false; }",
                "optional": false
              },
              {
                "name": "stubObject",
                "type": "() => any",
                "optional": false
              },
              {
                "name": "stubString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "stubTrue",
                "type": "{ (): true; (): true; }",
                "optional": false
              },
              {
                "name": "times",
                "type": "{ <TResult>(n: number, iteratee: (num: number) => TResult): TResult[]; (n: number): number[]; }",
                "optional": false
              },
              {
                "name": "toPath",
                "type": "(value: any) => string[]",
                "optional": false
              },
              {
                "name": "uniqueId",
                "type": "(prefix?: string) => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function0",
            "type": "Function0<R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function1",
            "type": "Function1<T1, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function2",
            "type": "Function2<T1, T2, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function3",
            "type": "Function3<T1, T2, T3, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Function4",
            "type": "Function4<T1, T2, T3, T4, R>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "Partial",
            "type": "Partial",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "PartialRight",
            "type": "PartialRight",
            "properties": [
              {
                "name": "placeholder",
                "type": "LoDashStatic",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ThrottleSettings",
            "type": "ThrottleSettings",
            "properties": [
              {
                "name": "leading",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "trailing",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ThrottleSettingsLeading",
            "type": "ThrottleSettingsLeading",
            "properties": [
              {
                "name": "trailing",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "FunctionBase",
            "type": "Function",
            "properties": [
              {
                "name": "apply",
                "type": "(this: Function, thisArg: any, argArray?: any) => any",
                "optional": false
              },
              {
                "name": "call",
                "type": "(this: Function, thisArg: any, ...argArray: any[]) => any",
                "optional": false
              },
              {
                "name": "bind",
                "type": "(this: Function, thisArg: any, ...argArray: any[]) => any",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "prototype",
                "type": "any",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": false
              },
              {
                "name": "arguments",
                "type": "any",
                "optional": false
              },
              {
                "name": "caller",
                "type": "Function",
                "optional": false
              },
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "__@hasInstance@19411",
                "type": "(value: any) => boolean",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CloneDeepWithCustomizer",
            "type": "CloneDeepWithCustomizer<TObject>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CloneWithCustomizer",
            "type": "CloneWithCustomizer<TValue, TResult>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CondPairNullary",
            "type": "CondPairNullary<R>",
            "properties": [
              {
                "name": "0",
                "type": "() => boolean",
                "optional": false
              },
              {
                "name": "1",
                "type": "() => R",
                "optional": false
              },
              {
                "name": "length",
                "type": "2",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
                "optional": false
              },
              {
                "name": "pop",
                "type": "() => (() => boolean) | (() => R)",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...items: ((() => boolean) | (() => R))[]) => number",
                "optional": false
              },
              {
                "name": "concat",
                "type": "{ (...items: ConcatArray<(() => boolean) | (() => R)>[]): ((() => boolean) | (() => R))[]; (...items: ((() => boolean) | (() => R) | ConcatArray<(() => boolean) | (() => R)>)[]): ((() => boolean) | (() => R))[]; }",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => string",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => ((() => boolean) | (() => R))[]",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => (() => boolean) | (() => R)",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start?: number, end?: number) => ((() => boolean) | (() => R))[]",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: (() => boolean) | (() => R), b: (() => boolean) | (() => R)) => number) => CondPairNullary<R>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "{ (start: number, deleteCount?: number): ((() => boolean) | (() => R))[]; (start: number, deleteCount: number, ...items: ((() => boolean) | (() => R))[]): ((() => boolean) | (() => R))[]; }",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: ((() => boolean) | (() => R))[]) => number",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "every",
                "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: an...",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any) => boolean",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(callbackfn: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => void, thisArg?: any) => void",
                "optional": false
              },
              {
                "name": "map",
                "type": "<U>(callbackfn: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => U, thisArg?: any) => U[]",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): S[]; (predicate: (value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any): ((()...",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | (() => R), currentIndex: number, array: ((() => boolean) | (() => R))[]) => (() => boolean) | (() => R)): (() => boolean) | (() => R); (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | ...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | (() => R), currentIndex: number, array: ((() => boolean) | (() => R))[]) => (() => boolean) | (() => R)): (() => boolean) | (() => R); (callbackfn: (previousValue: (() => boolean) | (() => R), currentValue: (() => boolean) | ...",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends (() => boolean) | (() => R)>(predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => value is S, thisArg?: any): S; (predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any): (() => boo...",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(predicate: (value: (() => boolean) | (() => R), index: number, obj: ((() => boolean) | (() => R))[]) => unknown, thisArg?: any) => number",
                "optional": false
              },
              {
                "name": "fill",
                "type": "(value: (() => boolean) | (() => R), start?: number, end?: number) => CondPairNullary<R>",
                "optional": false
              },
              {
                "name": "copyWithin",
                "type": "(target: number, start: number, end?: number) => CondPairNullary<R>",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => ArrayIterator<[number, (() => boolean) | (() => R)]>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => ArrayIterator<number>",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => ArrayIterator<(() => boolean) | (() => R)>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(searchElement: (() => boolean) | (() => R), fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "<U, This = undefined>(callback: (this: This, value: (() => boolean) | (() => R), index: number, array: ((() => boolean) | (() => R))[]) => U | readonly U[], thisArg?: This) => U[]",
                "optional": false
              },
              {
                "name": "flat",
                "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
                "optional": false
              },
              {
                "name": "__@iterator@4630",
                "type": "() => ArrayIterator<(() => boolean) | (() => R)>",
                "optional": false
              },
              {
                "name": "__@unscopables@4632",
                "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
                "optional": false
              },
              {
                "name": "at",
                "type": "(index: number) => (() => boolean) | (() => R)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "CondPairUnary",
            "type": "CondPairUnary<T, R>",
            "properties": [
              {
                "name": "0",
                "type": "(val: T) => boolean",
                "optional": false
              },
              {
                "name": "1",
                "type": "(val: T) => R",
                "optional": false
              },
              {
                "name": "length",
                "type": "2",
                "optional": false
              },
              {
                "name": "toString",
                "type": "() => string",
                "optional": false
              },
              {
                "name": "toLocaleString",
                "type": "{ (): string; (locales: string | string[], options?: NumberFormatOptions & DateTimeFormatOptions): string; }",
                "optional": false
              },
              {
                "name": "pop",
                "type": "() => ((val: T) => boolean) | ((val: T) => R)",
                "optional": false
              },
              {
                "name": "push",
                "type": "(...items: (((val: T) => boolean) | ((val: T) => R))[]) => number",
                "optional": false
              },
              {
                "name": "concat",
                "type": "{ (...items: ConcatArray<((val: T) => boolean) | ((val: T) => R)>[]): (((val: T) => boolean) | ((val: T) => R))[]; (...items: (((val: T) => boolean) | ((val: T) => R) | ConcatArray<...>)[]): (((val: T) => boolean) | ((val: T) => R))[]; }",
                "optional": false
              },
              {
                "name": "join",
                "type": "(separator?: string) => string",
                "optional": false
              },
              {
                "name": "reverse",
                "type": "() => (((val: T) => boolean) | ((val: T) => R))[]",
                "optional": false
              },
              {
                "name": "shift",
                "type": "() => ((val: T) => boolean) | ((val: T) => R)",
                "optional": false
              },
              {
                "name": "slice",
                "type": "(start?: number, end?: number) => (((val: T) => boolean) | ((val: T) => R))[]",
                "optional": false
              },
              {
                "name": "sort",
                "type": "(compareFn?: (a: ((val: T) => boolean) | ((val: T) => R), b: ((val: T) => boolean) | ((val: T) => R)) => number) => CondPairUnary<T, R>",
                "optional": false
              },
              {
                "name": "splice",
                "type": "{ (start: number, deleteCount?: number): (((val: T) => boolean) | ((val: T) => R))[]; (start: number, deleteCount: number, ...items: (((val: T) => boolean) | ((val: T) => R))[]): (((val: T) => boolean) | ((val: T) => R))[]; }",
                "optional": false
              },
              {
                "name": "unshift",
                "type": "(...items: (((val: T) => boolean) | ((val: T) => R))[]) => number",
                "optional": false
              },
              {
                "name": "indexOf",
                "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "lastIndexOf",
                "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => number",
                "optional": false
              },
              {
                "name": "every",
                "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): this is S[]; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T...",
                "optional": false
              },
              {
                "name": "some",
                "type": "(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => unknown, thisArg?: any) => boolean",
                "optional": false
              },
              {
                "name": "forEach",
                "type": "(callbackfn: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => void, thisArg?: any) => void",
                "optional": false
              },
              {
                "name": "map",
                "type": "<U>(callbackfn: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => U, thisArg?: any) => U[]",
                "optional": false
              },
              {
                "name": "filter",
                "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): S[]; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boo...",
                "optional": false
              },
              {
                "name": "reduce",
                "type": "{ (callbackfn: (previousValue: ((val: T) => boolean) | ((val: T) => R), currentValue: ((val: T) => boolean) | ((val: T) => R), currentIndex: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => ((val: T) => boolean) | ((val: T) => R)): ((val: T) => boolean) | ((val: T) => R); (callbackfn: (previousValue: (...",
                "optional": false
              },
              {
                "name": "reduceRight",
                "type": "{ (callbackfn: (previousValue: ((val: T) => boolean) | ((val: T) => R), currentValue: ((val: T) => boolean) | ((val: T) => R), currentIndex: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => ((val: T) => boolean) | ((val: T) => R)): ((val: T) => boolean) | ((val: T) => R); (callbackfn: (previousValue: (...",
                "optional": false
              },
              {
                "name": "find",
                "type": "{ <S extends ((val: T) => boolean) | ((val: T) => R)>(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) | ((val: T) => R))[]) => value is S, thisArg?: any): S; (predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) ...",
                "optional": false
              },
              {
                "name": "findIndex",
                "type": "(predicate: (value: ((val: T) => boolean) | ((val: T) => R), index: number, obj: (((val: T) => boolean) | ((val: T) => R))[]) => unknown, thisArg?: any) => number",
                "optional": false
              },
              {
                "name": "fill",
                "type": "(value: ((val: T) => boolean) | ((val: T) => R), start?: number, end?: number) => CondPairUnary<T, R>",
                "optional": false
              },
              {
                "name": "copyWithin",
                "type": "(target: number, start: number, end?: number) => CondPairUnary<T, R>",
                "optional": false
              },
              {
                "name": "entries",
                "type": "() => ArrayIterator<[number, ((val: T) => boolean) | ((val: T) => R)]>",
                "optional": false
              },
              {
                "name": "keys",
                "type": "() => ArrayIterator<number>",
                "optional": false
              },
              {
                "name": "values",
                "type": "() => ArrayIterator<((val: T) => boolean) | ((val: T) => R)>",
                "optional": false
              },
              {
                "name": "includes",
                "type": "(searchElement: ((val: T) => boolean) | ((val: T) => R), fromIndex?: number) => boolean",
                "optional": false
              },
              {
                "name": "flatMap",
                "type": "<U, This = undefined>(callback: (this: This, value: ((val: T) => boolean) | ((val: T) => R), index: number, array: (((val: T) => boolean) | ((val: T) => R))[]) => U | readonly U[], thisArg?: This) => U[]",
                "optional": false
              },
              {
                "name": "flat",
                "type": "<A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[]",
                "optional": false
              },
              {
                "name": "__@iterator@4630",
                "type": "() => ArrayIterator<((val: T) => boolean) | ((val: T) => R)>",
                "optional": false
              },
              {
                "name": "__@unscopables@4632",
                "type": "{ [x: number]: boolean; length?: boolean; toString?: boolean; toLocaleString?: boolean; pop?: boolean; push?: boolean; concat?: boolean; join?: boolean; reverse?: boolean; shift?: boolean; slice?: boolean; sort?: boolean; ... 23 more ...; at?: boolean; }",
                "optional": false
              },
              {
                "name": "at",
                "type": "(index: number) => ((val: T) => boolean) | ((val: T) => R)",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "EmptyObject",
            "type": "EmptyObject<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "EmptyObjectOf",
            "type": "EmptyObjectOf<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "IsEqualCustomizer",
            "type": "IsEqualCustomizer",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "isMatchWithCustomizer",
            "type": "isMatchWithCustomizer",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "AssignCustomizer",
            "type": "AssignCustomizer",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfArrayLikeByKey",
            "type": "GetFieldTypeOfArrayLikeByKey<T, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfStringByKey",
            "type": "GetFieldTypeOfStringByKey<T, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfNarrowedByKey",
            "type": "GetFieldTypeOfNarrowedByKey<T, K>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfNarrowedByDotPath",
            "type": "GetFieldTypeOfNarrowedByDotPath<T, P>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. Assumes P is a dot-delimited path.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfNarrowedByLcKR",
            "type": "GetFieldTypeOfNarrowedByLcKR<T, Lc, K, R>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. This is a piece of GetFieldTypeOfNarrowedByLKR logic,\nassuming that Lc isn't to be ignored, and does not end with dot.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfNarrowedByLKR",
            "type": "GetFieldTypeOfNarrowedByLKR<T, L, K, R>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. Assumes T has been narrowed; L is a dot-delimited path,\nand should be ignored if an empty string; K is a key name; and R is\na dot-delimetered path, to be ignored if an empty string. Also if\nL has a tail dot, or R has a front dot, these dots should be discarded,\nhowever when L or R is just a dot, they should be interpreted as empty\nkey name (rather than ignored).",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfNarrowed",
            "type": "GetFieldTypeOfNarrowed<T, X, XT>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. Assumes T has been narrowed.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfObject",
            "type": "GetFieldTypeOfObject<T, X, XT>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. Assumes T has been narrowed to an object type.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldTypeOfPrimitive",
            "type": "GetFieldTypeOfPrimitive<T, X, XT>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Internal. Assumes T has been narrowed to a primitive type.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "GetFieldType",
            "type": "GetFieldType<T, X, XT>",
            "properties": [],
            "extends": [],
            "jsdoc": {
              "description": "Deduces the type of value at the path P of type T,\nso that _.get<T, P>(t: T, p: P): GetFieldType<T, P>.\nXT specifies the exact meaning of X:\n- 'Path' (default) - X is a path type to be fully parsed;\n- 'DotPath - X is a dot-delimitered path, without square (indexing) brackets;\n- 'Key' - X is a simple key, and needs no parsing.",
              "deprecated": false
            },
            "isExported": false
          },
          {
            "name": "MergeWithCustomizer",
            "type": "(value: any, srcValue: any, key: string, object: any, source: any, stack: any) => any",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "SetWithCustomizer",
            "type": "SetWithCustomizer<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "LoDashWrapper",
            "type": "LoDashWrapper<TValue>",
            "properties": [
              {
                "name": "toString",
                "type": "() => string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ReplaceFunction",
            "type": "ReplaceFunction",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TemplateOptions",
            "type": "TemplateOptions",
            "properties": [
              {
                "name": "sourceURL",
                "type": "string",
                "optional": true
              },
              {
                "name": "escape",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "evaluate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "imports",
                "type": "Dictionary<any>",
                "optional": true
              },
              {
                "name": "interpolate",
                "type": "RegExp",
                "optional": true
              },
              {
                "name": "variable",
                "type": "string",
                "optional": true
              }
            ],
            "extends": [
              "TemplateSettings"
            ],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TemplateExecutor",
            "type": "TemplateExecutor",
            "properties": [
              {
                "name": "source",
                "type": "string",
                "optional": false
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "TruncateOptions",
            "type": "TruncateOptions",
            "properties": [
              {
                "name": "length",
                "type": "number",
                "optional": true
              },
              {
                "name": "omission",
                "type": "string",
                "optional": true
              },
              {
                "name": "separator",
                "type": "string | RegExp",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "ConformsPredicateObject",
            "type": "ConformsPredicateObject<T>",
            "properties": [],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          },
          {
            "name": "MixinOptions",
            "type": "MixinOptions",
            "properties": [
              {
                "name": "chain",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": null,
            "isExported": false
          }
        ],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": true
    },
    {
      "name": "_",
      "contents": {
        "functions": [],
        "enums": [],
        "types": [],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": false
    }
  ],
  "version": "4.14.191"
}