{
  "functions": [
    {
      "name": "Router",
      "parameters": [
        {
          "name": "options",
          "type": "RouterOptions",
          "optional": true
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Creates a new router instance. Uses RouterOptions."
    },
    {
      "name": "json",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsJson",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null,
      "xaiDescription": "Parses JSON request bodies. Uses OptionsJson."
    },
    {
      "name": "raw",
      "parameters": [
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null,
      "xaiDescription": "Parses raw request bodies. Uses Options."
    },
    {
      "name": "text",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsText",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": null,
      "xaiDescription": "Parses text request bodies. Uses OptionsText."
    },
    {
      "name": "application",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null,
      "xaiDescription": "Handles application-level requests. Uses Request and Response types."
    },
    {
      "name": "init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null,
      "xaiDescription": "Retrieves the value of a setting."
    },
    {
      "name": "param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Adds custom logic for route parameters. Uses RequestParamHandler."
    },
    {
      "name": "path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null,
      "xaiDescription": "Handles routing for incoming requests. Uses Request, Response, and NextFunction."
    },
    {
      "name": "use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Mounts middleware functions. Uses RequestHandler."
    },
    {
      "name": "on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "__@captureRejectionSymbol@69398",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Handles promise rejections. Uses Error type."
    },
    {
      "name": "addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\njs\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\njs\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles POST requests. Uses Route and RequestHandler."
    },
    {
      "name": "put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles PUT requests. Uses Route and RequestHandler."
    },
    {
      "name": "delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles DELETE requests. Uses Route and RequestHandler."
    },
    {
      "name": "patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles PATCH requests. Uses Route and RequestHandler."
    },
    {
      "name": "options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles OPTIONS requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles HEAD requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles CHECKOUT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles CONNECT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles COPY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles LOCK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles MERGE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles MKACTIVITY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles MKCOL requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles MOVE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles M-SEARCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles NOTIFY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles PROPFIND requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles PROPPATCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles PURGE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles REPORT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles SEARCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles SUBSCRIBE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles TRACE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles UNLOCK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles UNSUBSCRIBE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles LINK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Handles UNLINK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null,
      "xaiDescription": "Creates a new route with the specified prefix. Returns IRoute<T>."
    },
    {
      "name": "application.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "application.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "application.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "application.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "application.get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null,
      "xaiDescription": "Retrieves the value of the specified setting."
    },
    {
      "name": "application.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Defines a parameter handler for the specified route parameter(s). Uses RequestParamHandler."
    },
    {
      "name": "application.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "application.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "application.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "application.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "application.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "application.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "application.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "application.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null,
      "xaiDescription": "Handles routing for the application. Uses Request, Response, and NextFunction."
    },
    {
      "name": "application.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "application.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles POST requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles PUT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles DELETE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles PATCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles OPTIONS requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles HEAD requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles CHECKOUT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles CONNECT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles COPY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles LOCK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles MERGE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles MKACTIVITY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles MKCOL requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles MOVE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles M-SEARCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles NOTIFY requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles PROPFIND requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles PROPPATCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles PURGE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles REPORT requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles SEARCH requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles SUBSCRIBE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles TRACE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles UNLOCK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles UNSUBSCRIBE requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles LINK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Handles UNLINK requests for the specified route. Uses RequestHandler."
    },
    {
      "name": "application.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Router",
      "jsdoc": null,
      "xaiDescription": "Adds middleware to the application. Uses RequestHandler."
    },
    {
      "name": "application.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null,
      "xaiDescription": "Creates a new route with the specified prefix. Returns IRoute<T>."
    },
    {
      "name": "application.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "application.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": null,
      "xaiDescription": "Returns a string representation of the application."
    },
    {
      "name": "application.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string | string[]",
      "jsdoc": null,
      "xaiDescription": "Concatenates the given strings to the application."
    },
    {
      "name": "application.indexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": null,
      "xaiDescription": "Returns the index of the first occurrence of the specified string."
    },
    {
      "name": "application.lastIndexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": null,
      "xaiDescription": "Returns the index of the last occurrence of the specified string."
    },
    {
      "name": "application.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string | string[]",
      "jsdoc": null,
      "xaiDescription": "Extracts a section of the application string."
    },
    {
      "name": "application.valueOf",
      "parameters": [],
      "returnType": "string | Object",
      "jsdoc": null,
      "xaiDescription": "Returns the primitive value of the application."
    },
    {
      "name": "application.includes",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": null,
      "xaiDescription": "Determines whether the application string includes the specified string."
    },
    {
      "name": "application.__@iterator@69548",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": null,
      "xaiDescription": "Returns an iterator for the application string."
    },
    {
      "name": "application.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": null,
      "xaiDescription": "Returns the character at the specified index in the application string."
    },
    {
      "name": "application.toLocaleString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": null,
      "xaiDescription": "Returns a locale-specific string representation of the application."
    },
    {
      "name": "request.toExponential",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented in exponential notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toPrecision",
      "parameters": [
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
        "params": [
          {
            "name": "precision",
            "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.destroySoon",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.pause",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Pauses the reading of data. That is, `'data'` events will not be emitted.\nUseful to throttle back an upload.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.resetAndDestroy",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.resume",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Resumes reading after a call to `socket.pause()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setNoDelay",
      "parameters": [
        {
          "name": "noDelay",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
        "params": [
          {
            "name": "noDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setKeepAlive",
      "parameters": [
        {
          "name": "enable",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "initialDelay",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
        "params": [
          {
            "name": "enable"
          },
          {
            "name": "initialDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.address",
      "parameters": [],
      "returnType": "{} | AddressInfo",
      "jsdoc": {
        "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.unref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.ref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Internal method to read data from the stream."
      }
    },
    {
      "name": "request.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\njs\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\njs\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "request.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "request.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "request.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "request.__@asyncIterator@70027",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "xaiDescription": "Internal async iterator for the stream."
      }
    },
    {
      "name": "request.__@asyncDispose@70029",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false
      }
    },
    {
      "name": "attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      }
    },
    {
      "name": "clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      }
    },
    {
      "name": "cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false
      }
    },
    {
      "name": "location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false
      }
    },
    {
      "name": "redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false
      }
    },
    {
      "name": "vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Assigns a socket to the response. Uses Socket."
      }
    },
    {
      "name": "detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Detaches a socket from the response. Uses Socket."
      }
    },
    {
      "name": "writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Writes data to the stream. Uses BufferEncoding."
      }
    },
    {
      "name": "_writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Writes multiple chunks to the stream. Uses BufferEncoding."
      }
    },
    {
      "name": "_final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Called when no more data will be written. Uses callback."
      }
    },
    {
      "name": "write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\njs\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding, if `chunk` is a string."
          },
          {
            "name": "callback",
            "description": "Callback for when this chunk of data is flushed."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\njs\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false,
        "xaiDescription": "Sets the HTTP status code of the response."
      }
    },
    {
      "name": "response.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false,
        "xaiDescription": "Sets status code and sends it as the response body."
      }
    },
    {
      "name": "response.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false,
        "xaiDescription": "Sets the Link header field with provided links."
      }
    },
    {
      "name": "response.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false,
        "xaiDescription": "Sends a response with the provided body."
      }
    },
    {
      "name": "response.json",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
        "deprecated": false,
        "xaiDescription": "Sends a JSON response with the provided body."
      }
    },
    {
      "name": "response.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false,
        "xaiDescription": "Sends a JSONP response with the provided body."
      }
    },
    {
      "name": "response.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false,
        "xaiDescription": "Transfers a file at the specified path."
      }
    },
    {
      "name": "response.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false,
        "xaiDescription": "Transfers a file as an attachment."
      }
    },
    {
      "name": "response.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false,
        "xaiDescription": "Sets the Content-Type header based on the provided type."
      }
    },
    {
      "name": "response.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false,
        "xaiDescription": "Sets the Content-Type header based on the provided type."
      }
    },
    {
      "name": "response.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
        "deprecated": false,
        "xaiDescription": "Responds based on the Accept header using provided callbacks."
      }
    },
    {
      "name": "response.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false,
        "xaiDescription": "Sets the Content-Disposition header to attachment."
      }
    },
    {
      "name": "response.set",
      "parameters": [
        {
          "name": "field",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set header `field` to `val`, or pass\nan object of header fields.\n\nExamples:\n\n   res.set('Foo', ['bar', 'baz']);\n   res.set('Accept', 'application/json');\n   res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n\nAliased as `res.header()`.",
        "deprecated": false,
        "xaiDescription": "Sets one or more response headers."
      }
    },
    {
      "name": "response.header",
      "parameters": [
        {
          "name": "field",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": null,
      "xaiDescription": "Alias for setting response headers."
    },
    {
      "name": "response.valueOf",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false,
        "xaiDescription": "Returns the primitive value of the response object."
      }
    },
    {
      "name": "response.get",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Get value for header `field`.",
        "deprecated": false,
        "xaiDescription": "Retrieves the value of a specified header field."
      }
    },
    {
      "name": "response.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false,
        "xaiDescription": "Clears a cookie with the specified name."
      }
    },
    {
      "name": "response.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "deprecated": false,
        "xaiDescription": "Sets a cookie with the specified name and value."
      }
    },
    {
      "name": "response.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
        "deprecated": false,
        "xaiDescription": "Sets the Location header to the specified URL."
      }
    },
    {
      "name": "response.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "deprecated": false,
        "xaiDescription": "Redirects to the specified URL."
      }
    },
    {
      "name": "response.render",
      "parameters": [
        {
          "name": "view",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render `view` with the given `options` and optional callback `fn`.\nWhen a callback function is given a response will _not_ be made\nautomatically, otherwise a response of _200_ and _text/html_ is given.\n\nOptions:\n\n - `cache`     boolean hinting to the engine it should cache\n - `filename`  filename of the view being rendered",
        "deprecated": false,
        "xaiDescription": "Renders a view with the provided options."
      }
    },
    {
      "name": "response.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of a string.",
        "deprecated": false,
        "xaiDescription": "Returns a string representation of the response."
      }
    },
    {
      "name": "response.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Returns the character at the specified position."
      }
    },
    {
      "name": "response.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Returns the Unicode value of the character at the specified index."
      }
    },
    {
      "name": "response.concat",
      "parameters": [
        {
          "name": "strings",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string that contains the concatenation of two or more strings.",
        "params": [
          {
            "name": "strings",
            "description": "The strings to append to the end of the string."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Concatenates the response with the provided strings."
      }
    },
    {
      "name": "response.indexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the position of the first occurrence of a substring.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for in the string"
          },
          {
            "name": "position",
            "description": "The index at which to begin searching the String object. If omitted, search starts at the beginning of the string."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Finds the first occurrence of a substring in the response."
      }
    },
    {
      "name": "response.lastIndexOf",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the last occurrence of a substring in the string.",
        "params": [
          {
            "name": "searchString",
            "description": "The substring to search for."
          },
          {
            "name": "position",
            "description": "The index at which to begin searching. If omitted, the search begins at the end of the string."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Finds the last occurrence of a substring in the response."
      }
    },
    {
      "name": "response.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false,
        "xaiDescription": "Compares the response string with another string."
      }
    },
    {
      "name": "response.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Matches the response against a regular expression."
      }
    },
    {
      "name": "response.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Replaces text in the response using a search value."
      }
    },
    {
      "name": "response.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Searches the response for a match using a regular expression."
      }
    },
    {
      "name": "response.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a section of a string.",
        "params": [
          {
            "name": "start",
            "description": "The index to the beginning of the specified portion of stringObj."
          },
          {
            "name": "end",
            "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Extracts a section of the response string."
      }
    },
    {
      "name": "response.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Splits the response string into an array of substrings."
      }
    },
    {
      "name": "response.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Extracts a substring from the response string."
      }
    },
    {
      "name": "response.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false,
        "xaiDescription": "Converts the response string to lowercase."
      }
    },
    {
      "name": "response.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false,
        "xaiDescription": "Converts the response string to lowercase based on locale."
      }
    },
    {
      "name": "response.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false,
        "xaiDescription": "Converts the response string to uppercase."
      }
    },
    {
      "name": "response.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false,
        "xaiDescription": "Converts the response string to uppercase based on locale."
      }
    },
    {
      "name": "response.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false,
        "xaiDescription": "Removes whitespace from the start and end of the response."
      }
    },
    {
      "name": "response.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true,
        "xaiDescription": "Extracts a substring from the response string (deprecated)."
      }
    },
    {
      "name": "response.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false,
        "xaiDescription": "Returns the Unicode code point at the specified position."
      }
    },
    {
      "name": "response.includes",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if searchString appears as a substring of the result of converting this\nobject to a String, at one or more positions that are\ngreater than or equal to position; otherwise, returns false.",
        "params": [
          {
            "name": "searchString",
            "description": "search string"
          },
          {
            "name": "position",
            "description": "If position is undefined, 0 is assumed, so as to search all of the String."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Checks if the response includes a specified substring."
      }
    },
    {
      "name": "response.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition – length(this). Otherwise returns false.",
        "deprecated": false,
        "xaiDescription": "Checks if the response ends with a specified substring."
      }
    },
    {
      "name": "response.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default is \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0, the empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at position. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "response.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length. The padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded. If this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with. If this string is too long, it will be truncated and the left-most part will be applied. The default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length. The padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded. If this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with. If this string is too long, it will be truncated and the left-most part will be applied. The default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "response.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "response.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.__@iterator@69548",
      "parameters": [],
      "returnType": "StringIterator<string>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "response.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "xaiDescription": "Returns the character at the specified index in the string."
      }
    },
    {
      "name": "response.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already. Examples: res.vary('User-Agent').render('docs');",
        "deprecated": false
      }
    },
    {
      "name": "response.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "xaiDescription": "Handles the request and response objects for the application."
      }
    },
    {
      "name": "response.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server. - setup default configuration - setup default middleware - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "response.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "response.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Register the given template engine callback `fn` as `ext`. By default will `require()` the engine based on the file extension. For example if you try to render a \"foo.jade\" file Express will invoke the following internally: app.engine('jade', require('jade').__express); For engines that do not provide `.__express` out of the box, or if you wish to \"map\" a different extension to the template engine you may use this method. For example mapping the EJS template engine to \".html\" files: app.engine('html', require('ejs').renderFile); In this case EJS provides a `.renderFile()` method with the same signature that Express expects: `(path, options, callback)`, though note that it aliases this method as `ejs.__express` internally so if you're using \".ejs\" extensions you dont need to do anything. Some template engines do not follow this convention, the [Consolidate.js](https://github.com/visionmedia/consolidate.js) library was created to map all of node's popular template engines to follow this convention, thus allowing them to work seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "response.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Registers a parameter handler for the specified name(s)."
      }
    },
    {
      "name": "response.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname based on the parent(s) that have mounted it. For example if the application was mounted as \"/admin\", which itself was mounted as \"/blog\" then the return value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "response.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy). app.enabled('foo') // => false app.enable('foo') app.enabled('foo') // => true",
        "deprecated": false
      }
    },
    {
      "name": "response.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled. app.disabled('foo') // => true app.enable('foo') app.disabled('foo') // => false",
        "deprecated": false
      }
    },
    {
      "name": "response.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "response.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "response.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections. A node `http.Server` is returned, with this application (which is a `Function`) as its callback. If you wish to create both an HTTP and HTTPS server you may do so with the \"http\" and \"https\" modules as shown here: var http = require('http') , https = require('https') , express = require('express') , app = express(); http.createServer(app).listen(80); https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "response.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": {
        "xaiDescription": "Handles routing for the application."
      }
    },
    {
      "name": "response.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Adds middleware handlers to the application."
      }
    },
    {
      "name": "response.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function. NOTE: Sub-apps will: - Not inherit the value of settings that have a default value. You must set the value in the sub-app. - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "response.__@captureRejectionSymbol@69398",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Handles error capture for the application."
      }
    },
    {
      "name": "response.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The next time `eventName` is triggered, this listener is removed and then invoked. js server.once('connection', (stream) => { console.log('Ah, we have our first user!'); });  Returns a reference to the `EventEmitter`, so that calls can be chained. By default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the event listener to the beginning of the listeners array. js import { EventEmitter } from 'node:events'; const myEE = new EventEmitter(); myEE.once('foo', () => console.log('a')); myEE.prependOnceListener('foo', () => console.log('b')); myEE.emit('foo'); // Prints: //   b //   a ",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`. js const callback = (stream) => { console.log('someone connected!'); }; server.on('connection', callback); // ... server.removeListener('connection', callback);  `removeListener()` will remove, at most, one instance of a listener from the listener array. If any single listener has been added multiple times to the listener array for the specified `eventName`, then `removeListener()` must be called multiple times to remove each instance. Once an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution will not remove them from`emit()` in progress. Subsequent events behave as expected. js import { EventEmitter } from 'node:events'; class MyEmitter extends EventEmitter {} const myEmitter = new MyEmitter(); const callbackA = () => { console.log('A'); myEmitter.removeListener('event', callbackB); }; const callbackB = () => { console.log('B'); }; myEmitter.on('event', callbackA); myEmitter.on('event', callbackB); // callbackA removes listener callbackB but it will still be called. // Internal listener array at time of emit [callbackA, callbackB] myEmitter.emit('event'); // Prints: //   A //   B // callbackB is now removed. // Internal listener array [callbackA] myEmitter.emit('event'); // Prints: //   A  Because listeners are managed using an internal array, calling this will change the position indices of any listener registered _after_ the listener being removed. This will not impact the order in which listeners are called, but it means that any copies of the listener array as returned by the `emitter.listeners()` method will need to be recreated. When a single function has been added as a handler multiple times for a single event (as in the example below), `removeListener()` will remove the most recently added instance. In the example the `once('ping')` listener is removed: js import { EventEmitter } from 'node:events'; const ee = new EventEmitter(); function pong() { console.log('pong'); } ee.on('ping', pong); ee.once('ping', pong); ee.removeListener('ping', pong); ee.emit('ping'); ee.emit('ping');  Returns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`. It is bad practice to remove listeners added elsewhere in the code, particularly when the `EventEmitter` instance was created by some other component or module (e.g. sockets or file streams). Returns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are added for a particular event. This is a useful default that helps finding memory leaks. The `emitter.setMaxListeners()` method allows the limit to be modified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners. Returns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either set by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`. js server.on('connection', (stream) => { console.log('someone connected!'); }); console.log(util.inspect(server.listeners('connection'))); // Prints: [ [Function] ] ",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`, including any wrappers (such as those created by `.once()`). js import { EventEmitter } from 'node:events'; const emitter = new EventEmitter(); emitter.once('log', () => console.log('log once')); // Returns a new Array with a function `onceWrapper` which has a property // `listener` which contains the original listener bound above const listeners = emitter.rawListeners('log'); const logFnWrapper = listeners[0]; // Logs \"log once\" to the console and does not unbind the `once` event logFnWrapper.listener(); // Logs \"log once\" to the console and removes the listener logFnWrapper(); emitter.on('log', () => console.log('log persistently')); // Will return a new Array with a single function bound by `.on()` above const newListeners = emitter.rawListeners('log'); // Logs \"log persistently\" twice newListeners[0](); emitter.emit('log'); ",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments to each.\n\nReturns `true` if the event had listeners, `false` otherwise.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`. If `listener` is provided, it will return how many times the listener is found in the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds the `listener` function to the beginning of the listeners array for the event named `eventName`. No checks are made to see if the `listener` has already been added. Multiple calls passing the same combination of `eventName` and `listener` will result in the `listener` being added, and called, multiple times.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a one-time `listener` function for the event named `eventName` to the beginning of the listeners array. The next time `eventName` is triggered, this listener is removed, and then invoked.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered listeners. The values in the array are strings or `Symbol`s.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`, middleware, and callback to every HTTP method.",
        "deprecated": false,
        "xaiDescription": "Applies route to all HTTP methods."
      }
    },
    {
      "name": "response.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles POST requests for the given route."
      }
    },
    {
      "name": "response.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PUT requests for the given route."
      }
    },
    {
      "name": "response.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles DELETE requests for the given route."
      }
    },
    {
      "name": "response.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PATCH requests for the given route."
      }
    },
    {
      "name": "response.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles OPTIONS requests for the given route."
      }
    },
    {
      "name": "response.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles HEAD requests for the given route."
      }
    },
    {
      "name": "response.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles CHECKOUT requests for the given route."
      }
    },
    {
      "name": "response.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles CONNECT requests for the given route."
      }
    },
    {
      "name": "response.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles COPY requests for the given route."
      }
    },
    {
      "name": "response.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles LOCK requests for the given route."
      }
    },
    {
      "name": "response.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MERGE requests for the given route."
      }
    },
    {
      "name": "response.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MKACTIVITY requests for the given route."
      }
    },
    {
      "name": "response.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MKCOL requests for the given route."
      }
    },
    {
      "name": "response.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MOVE requests for the given route."
      }
    },
    {
      "name": "response.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles M-SEARCH requests for the given route."
      }
    },
    {
      "name": "response.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles NOTIFY requests for the given route."
      }
    },
    {
      "name": "response.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PROPFIND requests for the given route."
      }
    },
    {
      "name": "response.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PROPPATCH requests for the given route."
      }
    },
    {
      "name": "response.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PURGE requests for the given route."
      }
    },
    {
      "name": "response.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles REPORT requests for the given route."
      }
    },
    {
      "name": "response.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles SUBSCRIBE requests for the given route."
      }
    },
    {
      "name": "response.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles TRACE requests for the given route."
      }
    },
    {
      "name": "response.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNLOCK requests for the given route."
      }
    },
    {
      "name": "response.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNSUBSCRIBE requests for the given route."
      }
    },
    {
      "name": "response.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNLINK requests for the given route."
      }
    },
    {
      "name": "response.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": {
        "xaiDescription": "Creates a new route with the given prefix."
      }
    },
    {
      "name": "response.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field. If the header is not already set, it creates the header with the specified value. The value parameter can be a string or an array.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning the best match when true, otherwise `undefined`, in which case you should respond with 406 \"Not Acceptable\".",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets, based on the request's Accept-Charset HTTP header field. If none of the specified charsets is accepted, returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings, based on the request's Accept-Encoding HTTP header field. If none of the specified encodings is accepted, returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages, based on the request's Accept-Language HTTP header field. If none of the specified languages is accepted, returns false.",
        "deprecated": false
      }
    },
    {
      "name": "response.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`. If the Range header field is not given `undefined` is returned. If the Range header field is given, return value is a result of range-parser.",
        "deprecated": false
      }
    },
    {
      "name": "response.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\" header field, and it contains the given mime `type`.",
        "deprecated": false
      }
    },
    {
      "name": "response.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Passes control to the next matching route."
      }
    },
    {
      "name": "response.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed as an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Initializes the response object."
      }
    },
    {
      "name": "response._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Reads data from the response stream."
      }
    },
    {
      "name": "response.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and returns it. If no data is available to be read, `null` is returned. By default, the data is returned as a `Buffer` object unless an encoding has been specified using the `readable.setEncoding()` method or the stream is operating in object mode.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for data read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\njs\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\njs\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "xaiDescription": "Pushes a chunk of data into the stream. Returns true if successful.",
        "params": [
          {
            "name": "chunk",
            "description": "The data to push into the stream."
          },
          {
            "name": "encoding",
            "description": "The encoding of the chunk if it's a string."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "response.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "response.some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "response.find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "response.every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "response.flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "response.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "response.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "response.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "response.reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "response._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Destroys the stream, calling the callback with an error if provided.",
        "params": [
          {
            "name": "error",
            "description": "The error to pass to the callback."
          },
          {
            "name": "callback",
            "description": "The function to call after destruction."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.__@asyncIterator@70027",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "xaiDescription": "Returns an async iterator for the stream.",
        "deprecated": false
      }
    },
    {
      "name": "response.__@asyncDispose@70029",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Pipes the readable stream into a writable stream. Returns the destination.",
        "params": [
          {
            "name": "destination",
            "description": "The writable stream to pipe into."
          },
          {
            "name": "options",
            "description": "Options for piping, including whether to end the destination when the source ends."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Composes the stream with another stream or iterable. Returns the composed stream.",
        "params": [
          {
            "name": "stream",
            "description": "The stream or iterable to compose with."
          },
          {
            "name": "options",
            "description": "Options for composition, including an abort signal."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toFixed",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representing a number in fixed-point notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toExponential",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented in exponential notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toPrecision",
      "parameters": [
        {
          "name": "precision",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
        "params": [
          {
            "name": "precision",
            "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.toLocaleString",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        },
        {
          "name": "options",
          "type": "NumberFormatOptions",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts a number to a string by using the current or specified locale.",
        "params": [
          {
            "name": "locales",
            "description": "A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used."
          },
          {
            "name": "options",
            "description": "An object that contains one or more properties that specify comparison options."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Assigns a socket to the response. Uses Socket."
      }
    },
    {
      "name": "response.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Detaches a socket from the response. Uses Socket."
      }
    },
    {
      "name": "response.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.destroySoon",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.write",
      "parameters": [
        {
          "name": "buffer",
          "type": "string | Uint8Array<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "cb",
          "type": "(err?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string. It defaults to UTF8 encoding.\n\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.\n\nThe optional `callback` parameter will be executed when the data is finally\nwritten out, which may not be immediately.\n\nSee `Writable` stream `write()` method for more\ninformation.",
        "params": [
          {
            "name": "encoding",
            "description": "Only used when data is `string`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.resetAndDestroy",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setNoDelay",
      "parameters": [
        {
          "name": "noDelay",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
        "params": [
          {
            "name": "noDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setKeepAlive",
      "parameters": [
        {
          "name": "enable",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "initialDelay",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
        "params": [
          {
            "name": "enable"
          },
          {
            "name": "initialDelay"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.address",
      "parameters": [],
      "returnType": "{} | AddressInfo",
      "jsdoc": {
        "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.unref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.ref",
      "parameters": [],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.end",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n\nSee `writable.end()` for further details.",
        "params": [
          {
            "name": "encoding",
            "description": "Only used when data is `string`."
          },
          {
            "name": "callback",
            "description": "Optional callback for when the socket is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Internal method to write data to the response. Uses BufferEncoding."
      }
    },
    {
      "name": "response._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Internal method to write multiple chunks to the response. Uses BufferEncoding."
      }
    },
    {
      "name": "response._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Internal method called when the response is finished. Uses Error."
      }
    },
    {
      "name": "response.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Socket",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "response.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "response.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "static",
      "parameters": [
        {
          "name": "root",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
          "optional": true
        }
      ],
      "returnType": "RequestHandler<Response<any, Record<string, any>>>",
      "jsdoc": {
        "xaiDescription": "Serves static files from the given root directory. Uses ServeStaticOptions."
      }
    },
    {
      "name": "static.lookup",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fallback",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Look up a mime type based on extension.\n\nIf not found, uses the fallback argument if provided, and otherwise\nuses `default_type`.",
        "deprecated": false
      }
    },
    {
      "name": "static.extension",
      "parameters": [
        {
          "name": "mime",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Return a file extensions associated with a mime type.",
        "deprecated": false
      }
    },
    {
      "name": "static.load",
      "parameters": [
        {
          "name": "filepath",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Load an Apache2-style \".types\" file.",
        "deprecated": false
      }
    },
    {
      "name": "static.define",
      "parameters": [
        {
          "name": "mimes",
          "type": "TypeMap",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Defines custom MIME types. Uses TypeMap."
      }
    },
    {
      "name": "urlencoded",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsUrlencoded",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": {
        "xaiDescription": "Parses URL-encoded bodies. Uses OptionsUrlencoded."
      }
    },
    {
      "name": "e.Router",
      "parameters": [
        {
          "name": "options",
          "type": "RouterOptions",
          "optional": true
        }
      ],
      "returnType": "Router",
      "jsdoc": {
        "xaiDescription": "Creates a new router instance. Uses RouterOptions."
      }
    },
    {
      "name": "e",
      "parameters": [],
      "returnType": "Express",
      "jsdoc": {
        "description": "Creates an Express application. The express() function is a top-level function exported by the express module.",
        "deprecated": false
      }
    },
    {
      "name": "e.json",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsJson",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": {
        "xaiDescription": "Parses JSON request bodies. Uses OptionsJson.",
        "deprecated": false
      }
    },
    {
      "name": "e.raw",
      "parameters": [
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": {
        "xaiDescription": "Parses raw request bodies. Uses Options.",
        "deprecated": false
      }
    },
    {
      "name": "e.text",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsText",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": {
        "xaiDescription": "Parses text request bodies. Uses OptionsText.",
        "deprecated": false
      }
    },
    {
      "name": "e.application",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "xaiDescription": "Handles application-level requests. Uses Request and Response types.",
        "deprecated": false
      }
    },
    {
      "name": "e.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "e.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "e.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Register the given template engine callback `fn` as `ext`.",
        "deprecated": false
      }
    },
    {
      "name": "e.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.",
        "deprecated": false
      }
    },
    {
      "name": "e.get",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "xaiDescription": "Retrieves the value of a setting.",
        "deprecated": false
      }
    },
    {
      "name": "e.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "xaiDescription": "Defines route parameter middleware. Uses RequestParamHandler.",
        "deprecated": false
      }
    },
    {
      "name": "e.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname based on the parent(s) that have mounted it.",
        "deprecated": false
      }
    },
    {
      "name": "e.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).",
        "deprecated": false
      }
    },
    {
      "name": "e.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.",
        "deprecated": false
      }
    },
    {
      "name": "e.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "e.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "e.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options` and a callback accepting an error and the rendered template string.",
        "deprecated": false
      }
    },
    {
      "name": "e.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.",
        "deprecated": false
      }
    },
    {
      "name": "e.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": {
        "xaiDescription": "Handles routing for requests. Uses Request, Response, and NextFunction types.",
        "deprecated": false
      }
    },
    {
      "name": "e.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "xaiDescription": "Mounts middleware functions. Uses RequestHandler.",
        "deprecated": false
      }
    },
    {
      "name": "e.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.",
        "deprecated": false
      }
    },
    {
      "name": "e.__@captureRejectionSymbol@69398",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Handles promise rejections. Uses Error type.",
        "deprecated": false
      }
    },
    {
      "name": "e.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "deprecated": false
      }
    },
    {
      "name": "e.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "deprecated": false
      }
    },
    {
      "name": "e.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are added for a particular event.",
        "deprecated": false
      }
    },
    {
      "name": "e.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either set by `emitter.setMaxListeners(n)` or defaults to   .",
        "deprecated": false
      }
    },
    {
      "name": "e.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`, including any wrappers (such as those created by `.once()`).",
        "deprecated": false
      }
    },
    {
      "name": "e.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments to each.",
        "deprecated": false
      }
    },
    {
      "name": "e.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the event named `eventName`.",
        "deprecated": false
      }
    },
    {
      "name": "e.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array.",
        "deprecated": false
      }
    },
    {
      "name": "e.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered listeners.",
        "deprecated": false
      }
    },
    {
      "name": "e.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Special-cased \"all\" method, applying the given route `path`, middleware, and callback to _every_ HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "e.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "xaiDescription": "Handles POST requests. Uses Route and RequestHandler types.",
        "deprecated": false
      }
    },
    {
      "name": "e.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "xaiDescription": "Handles PUT requests. Uses Route and RequestHandler types.",
        "deprecated": false
      }
    },
    {
      "name": "e.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "xaiDescription": "Handles DELETE requests. Uses Route and RequestHandler types.",
        "deprecated": false
      }
    },
    {
      "name": "e.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers PATCH route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers OPTIONS route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers HEAD route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers CHECKOUT route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers CONNECT route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers COPY route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers LOCK route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers MERGE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers MKACTIVITY route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers MKCOL route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers MOVE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers M-SEARCH route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers NOTIFY route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers PROPFIND route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers PROPPATCH route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers PURGE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers REPORT route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers SEARCH route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers SUBSCRIBE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers TRACE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers UNLOCK route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers UNSUBSCRIBE route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.link",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers LINK route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": null,
      "xaiDescription": "Registers UNLINK route. Uses Route and RequestHandler types."
    },
    {
      "name": "e.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": null,
      "xaiDescription": "Creates a new route with the given prefix. Returns IRoute<T>."
    },
    {
      "name": "e.header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": null,
      "xaiDescription": "Retrieves the 'set-cookie' header values as an array of strings."
    },
    {
      "name": "e.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      },
      "xaiDescription": "Checks if given type(s) are acceptable, returns best match or undefined."
    },
    {
      "name": "e.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      },
      "xaiDescription": "Returns first accepted charset based on Accept-Charset header."
    },
    {
      "name": "e.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      },
      "xaiDescription": "Returns first accepted encoding based on Accept-Encoding header."
    },
    {
      "name": "e.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      },
      "xaiDescription": "Returns first accepted language based on Accept-Language header."
    },
    {
      "name": "e.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      },
      "xaiDescription": "Parses Range header, caps to given size. Returns Ranges or Result."
    },
    {
      "name": "e.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      },
      "xaiDescription": "Checks if request's Content-Type matches given MIME type(s)."
    },
    {
      "name": "e.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null,
      "xaiDescription": "Handles request and response objects. Returns any type."
    },
    {
      "name": "e.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Passes control to the next matching route. Optional error parameter."
    },
    {
      "name": "e.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      },
      "xaiDescription": "Sets timeout for the request socket. Returns Request object."
    },
    {
      "name": "e.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      },
      "xaiDescription": "Destroys the request socket. Optional error parameter. Returns Request."
    },
    {
      "name": "e._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Constructs the request object. Calls callback with optional error."
    },
    {
      "name": "e._read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Reads data from the request stream. Size parameter specifies amount."
    },
    {
      "name": "e.read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\njs\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\njs\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      },
      "xaiDescription": "Reads data from the request stream. Optional size parameter."
    },
    {
      "name": "e.setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      },
      "xaiDescription": "Sets encoding for data read from the request stream. Returns Request."
    },
    {
      "name": "e.pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      },
      "xaiDescription": "Pauses the request stream. Returns Request object."
    },
    {
      "name": "e.resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\njs\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      },
      "xaiDescription": "Resumes the request stream. Returns Request object."
    },
    {
      "name": "e.isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
        "params": [],
        "deprecated": false
      },
      "xaiDescription": "Checks if the request stream is paused. Returns boolean."
    },
    {
      "name": "e.unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      },
      "xaiDescription": "Detaches a WritableStream from the request stream. Returns Request."
    },
    {
      "name": "application.__@captureRejectionSymbol@69398",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Handles rejection events, capturing errors and event details."
    },
    {
      "name": "application.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application",
      "jsdoc": {
        "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\njs\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\njs\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "application.pop",
      "parameters": [],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "application.push",
      "parameters": [
        {
          "name": "items",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Appends new elements to the end of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "New elements to add to the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.join",
      "parameters": [
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
        "params": [
          {
            "name": "separator",
            "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reverse",
      "parameters": [],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "deprecated": false
      }
    },
    {
      "name": "application.shift",
      "parameters": [],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "application.sort",
      "parameters": [
        {
          "name": "compareFn",
          "type": "(a: ILayer, b: ILayer) => number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "params": [
          {
            "name": "compareFn",
            "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\nts\n[11,2,22,1].sort((a, b) => a - b)\n"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.splice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "deleteCount",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based location in the array from which to start removing elements."
          },
          {
            "name": "deleteCount",
            "description": "The number of elements to remove."
          }
        ],
        "returns": "An array containing the elements that were deleted.",
        "deprecated": false
      }
    },
    {
      "name": "application.unshift",
      "parameters": [
        {
          "name": "items",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "Elements to insert at the start of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.every",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether all the members of an array satisfy the specified test.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.some",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether the specified callback function returns true for any element of an array.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.forEach",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: ILayer, index: number, array: ILayer[]) => void",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Performs the specified action for each element in an array.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.map",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: ILayer, index: number, array: ILayer[]) => U",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.filter",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S[]",
      "jsdoc": {
        "description": "Returns the elements of an array that meet the condition specified in a callback function.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reduce",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
          "optional": false
        }
      ],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.reduceRight",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
          "optional": false
        }
      ],
      "returnType": "ILayer",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.find",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, obj: ILayer[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\njs\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "xaiDescription": "Pushes a chunk onto the stream. Returns true if successful."
      }
    },
    {
      "name": "e.iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "e.toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "e.some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "e.find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "e.every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "e.flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "e.drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "e.take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "e.asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "e.reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "e._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Destroys the stream with an error, calls callback when done."
      }
    },
    {
      "name": "e.__@asyncIterator@70027",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "xaiDescription": "Returns an async iterator for the stream."
      }
    },
    {
      "name": "e.__@asyncDispose@70029",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Pipes the stream to a destination. Returns the destination."
      }
    },
    {
      "name": "e.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Composes the stream with another stream or iterable. Returns the composed stream."
      }
    },
    {
      "name": "e.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set status `code`.",
        "deprecated": false
      }
    },
    {
      "name": "e.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
        "deprecated": false
      }
    },
    {
      "name": "e.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
        "deprecated": false
      }
    },
    {
      "name": "e.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
        "deprecated": false
      }
    },
    {
      "name": "e.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
        "deprecated": false
      }
    },
    {
      "name": "e.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "e.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
        "deprecated": false
      }
    },
    {
      "name": "e.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Respond to Acceptable formats using mime-type callbacks.",
        "deprecated": false
      },
      "xaiDescription": "Responds to Acceptable formats using mime-type callbacks."
    },
    {
      "name": "e.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
        "deprecated": false
      },
      "xaiDescription": "Sets Content-Disposition header to attachment with optional filename."
    },
    {
      "name": "e.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Clear cookie `name`.",
        "deprecated": false
      },
      "xaiDescription": "Clears a cookie by name."
    },
    {
      "name": "e.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set cookie `name` to `val`, with the given `options`.",
        "deprecated": false
      },
      "xaiDescription": "Sets a cookie with name, value, and options."
    },
    {
      "name": "e.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Set the location header to `url`.",
        "deprecated": false
      },
      "xaiDescription": "Sets the location header to the specified URL."
    },
    {
      "name": "e.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given `url` with optional response `status` defaulting to 302.",
        "deprecated": false
      },
      "xaiDescription": "Redirects to the given URL with optional status."
    },
    {
      "name": "e.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.",
        "deprecated": false
      },
      "xaiDescription": "Adds a field to the Vary response header."
    },
    {
      "name": "e.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.",
        "deprecated": false
      },
      "xaiDescription": "Appends a value to an HTTP response header field."
    },
    {
      "name": "e.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Assigns a socket to the response."
    },
    {
      "name": "e.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Detaches a socket from the response."
    },
    {
      "name": "e.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client.",
        "deprecated": false
      },
      "xaiDescription": "Sends an HTTP/1.1 100 Continue message to the client."
    },
    {
      "name": "e.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client.",
        "deprecated": false
      },
      "xaiDescription": "Sends an HTTP/1.1 103 Early Hints message to the client."
    },
    {
      "name": "e.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sends a response header to the request.",
        "deprecated": false
      },
      "xaiDescription": "Sends a response header to the request."
    },
    {
      "name": "e.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client.",
        "deprecated": false
      },
      "xaiDescription": "Sends a HTTP/1.1 102 Processing message to the client."
    },
    {
      "name": "e.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets a single header value.",
        "deprecated": false
      },
      "xaiDescription": "Sets a single header value."
    },
    {
      "name": "e.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers.",
        "deprecated": false
      },
      "xaiDescription": "Sets multiple header values for implicit headers."
    },
    {
      "name": "e.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Append a single header value to the header object.",
        "deprecated": false
      },
      "xaiDescription": "Appends a single header value to the header object."
    },
    {
      "name": "e.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name.",
        "deprecated": false
      },
      "xaiDescription": "Gets the value of the HTTP header with the given name."
    },
    {
      "name": "e.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers.",
        "deprecated": false
      },
      "xaiDescription": "Returns a shallow copy of the current outgoing headers."
    },
    {
      "name": "e.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.",
        "deprecated": false
      },
      "xaiDescription": "Returns unique names of the current outgoing headers."
    },
    {
      "name": "e.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set.",
        "deprecated": false
      },
      "xaiDescription": "Checks if a header is currently set."
    },
    {
      "name": "e.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.",
        "deprecated": false
      },
      "xaiDescription": "Removes a header queued for implicit sending."
    },
    {
      "name": "e.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers to the message.",
        "deprecated": false
      },
      "xaiDescription": "Adds HTTP trailers to the message."
    },
    {
      "name": "e.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.",
        "deprecated": false
      },
      "xaiDescription": "Flushes the message headers."
    },
    {
      "name": "e._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Writes a chunk of data to the stream."
    },
    {
      "name": "e._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Writes multiple chunks of data to the stream."
    },
    {
      "name": "e._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Finalizes the stream."
    },
    {
      "name": "e.write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream.",
        "deprecated": false
      },
      "xaiDescription": "Writes data to the stream."
    },
    {
      "name": "e.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "deprecated": false
      },
      "xaiDescription": "Sets the default encoding for a Writable stream."
    },
    {
      "name": "e.end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\njs\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "e.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "e.static",
      "parameters": [
        {
          "name": "root",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
          "optional": true
        }
      ],
      "returnType": "RequestHandler<Response<any, Record<string, any>>>",
      "jsdoc": {
        "description": "Serve static files from the given root directory. Uses ServeStaticOptions.",
        "params": [
          {
            "name": "root",
            "description": "The root directory from which to serve static files."
          },
          {
            "name": "options",
            "description": "Optional configuration options for serving static files."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Serve static files from root directory. Uses ServeStaticOptions."
      }
    },
    {
      "name": "e.urlencoded",
      "parameters": [
        {
          "name": "options",
          "type": "OptionsUrlencoded",
          "optional": true
        }
      ],
      "returnType": "NextHandleFunction",
      "jsdoc": {
        "description": "Middleware to parse URL-encoded bodies. Uses OptionsUrlencoded.",
        "params": [
          {
            "name": "options",
            "description": "Optional configuration options for parsing URL-encoded bodies."
          }
        ],
        "deprecated": false,
        "xaiDescription": "Parse URL-encoded bodies. Uses OptionsUrlencoded."
      }
    },
    {
      "name": "application.findIndex",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: ILayer, index: number, obj: ILayer[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.fill",
      "parameters": [
        {
          "name": "value",
          "type": "ILayer",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
        "params": [
          {
            "name": "value",
            "description": "value to fill array section with"
          },
          {
            "name": "start",
            "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
          },
          {
            "name": "end",
            "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.copyWithin",
      "parameters": [
        {
          "name": "target",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "ILayer[]",
      "jsdoc": {
        "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
        "params": [
          {
            "name": "target",
            "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
          },
          {
            "name": "start",
            "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
          },
          {
            "name": "end",
            "description": "If not specified, length of the this object is used as its default value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.entries",
      "parameters": [],
      "returnType": "ArrayIterator<[number, ILayer]>",
      "jsdoc": {
        "description": "Returns an iterable of key, value pairs for every entry in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.keys",
      "parameters": [],
      "returnType": "ArrayIterator<number>",
      "jsdoc": {
        "description": "Returns an iterable of keys in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.values",
      "parameters": [],
      "returnType": "ArrayIterator<ILayer>",
      "jsdoc": {
        "description": "Returns an iterable of values in the array",
        "deprecated": false
      }
    },
    {
      "name": "application.flatMap",
      "parameters": [
        {
          "name": "callback",
          "type": "(this: This, value: ILayer, index: number, array: ILayer[]) => U | readonly U[]",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "This",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
        "params": [
          {
            "name": "callback",
            "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "application.flat",
      "parameters": [
        {
          "name": "depth",
          "type": "D",
          "optional": true
        }
      ],
      "returnType": "FlatArray<A, D>[]",
      "jsdoc": {
        "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
        "params": [
          {
            "name": "depth",
            "description": "The maximum recursion depth"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "xaiDescription": "Retrieves 'set-cookie' header values. Returns array of strings."
      }
    },
    {
      "name": "accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "xaiDescription": "Handles request and response. Returns any type."
      }
    },
    {
      "name": "next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Passes control to next middleware. Optional error parameter."
      }
    },
    {
      "name": "setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "_construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Initializes stream. Calls callback with optional error."
      }
    },
    {
      "name": "_read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Reads data from stream. Size parameter specifies amount."
      }
    },
    {
      "name": "read",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "any",
      "jsdoc": {
        "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\njs\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\njs\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
        "params": [
          {
            "name": "size",
            "description": "Optional argument to specify how much data to read."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "setEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n",
        "params": [
          {
            "name": "encoding",
            "description": "The encoding to use."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "pause",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "resume",
      "parameters": [],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\njs\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "isPaused",
      "parameters": [],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "unpipe",
      "parameters": [
        {
          "name": "destination",
          "type": "WritableStream",
          "optional": true
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
        "params": [
          {
            "name": "destination",
            "description": "Optional specific stream to unpipe"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "unshift",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\njs\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
        "params": [
          {
            "name": "chunk",
            "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
          },
          {
            "name": "encoding",
            "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "wrap",
      "parameters": [
        {
          "name": "stream",
          "type": "ReadableStream",
          "optional": false
        }
      ],
      "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
      "jsdoc": {
        "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
        "params": [
          {
            "name": "stream",
            "description": "An \"old style\" readable stream"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "push",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "xaiDescription": "Adds a chunk to the stream. Returns if the stream is still readable.",
        "deprecated": false
      }
    },
    {
      "name": "iterator",
      "parameters": [
        {
          "name": "options",
          "type": "{ destroyOnReturn?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
        "params": [
          {
            "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "map",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. Async or not."
          }
        ],
        "returns": "a stream mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "filter",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
        "params": [
          {
            "name": "fn",
            "description": "a function to filter chunks from the stream. Async or not."
          }
        ],
        "returns": "a stream filtered with the predicate *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "forEach",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise for when the stream has finished.",
        "deprecated": false
      }
    },
    {
      "name": "toArray",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<any[]>",
      "jsdoc": {
        "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
        "params": [],
        "returns": "a promise containing an array with the contents of the stream.",
        "deprecated": false
      }
    },
    {
      "name": "some",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "find",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
        "deprecated": false
      }
    },
    {
      "name": "every",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<boolean>",
      "jsdoc": {
        "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
        "params": [
          {
            "name": "fn",
            "description": "a function to call on each chunk of the stream. Async or not."
          }
        ],
        "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
        "deprecated": false
      }
    },
    {
      "name": "flatMap",
      "parameters": [
        {
          "name": "fn",
          "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
          "optional": false
        },
        {
          "name": "options",
          "type": "ArrayOptions",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
        "params": [
          {
            "name": "fn",
            "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
          }
        ],
        "returns": "a stream flat-mapped with the function *fn*.",
        "deprecated": false
      }
    },
    {
      "name": "drop",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to drop from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks dropped from the start.",
        "deprecated": false
      }
    },
    {
      "name": "take",
      "parameters": [
        {
          "name": "limit",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with the first *limit* chunks.",
        "params": [
          {
            "name": "limit",
            "description": "the number of chunks to take from the readable."
          }
        ],
        "returns": "a stream with *limit* chunks taken.",
        "deprecated": false
      }
    },
    {
      "name": "asIndexedPairs",
      "parameters": [
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Readable",
      "jsdoc": {
        "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
        "params": [],
        "returns": "a stream of indexed pairs.",
        "deprecated": false
      }
    },
    {
      "name": "reduce",
      "parameters": [
        {
          "name": "fn",
          "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
          "optional": false
        },
        {
          "name": "initial",
          "type": "undefined",
          "optional": true
        },
        {
          "name": "options",
          "type": "Pick<ArrayOptions, \"signal\">",
          "optional": true
        }
      ],
      "returnType": "Promise<T>",
      "jsdoc": {
        "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
        "params": [
          {
            "name": "fn",
            "description": "a reducer function to call over every chunk in the stream. Async or not."
          },
          {
            "name": "initial",
            "description": "the initial value to use in the reduction."
          }
        ],
        "returns": "a promise for the final value of the reduction.",
        "deprecated": false
      }
    },
    {
      "name": "_destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Destroys the stream, calling the callback with any error.",
        "deprecated": false
      }
    },
    {
      "name": "__@asyncIterator@70027",
      "parameters": [],
      "returnType": "AsyncIterator<any, any, any>",
      "jsdoc": {
        "xaiDescription": "Returns an async iterator for the stream.",
        "deprecated": false
      }
    },
    {
      "name": "__@asyncDispose@70029",
      "parameters": [],
      "returnType": "Promise<void>",
      "jsdoc": {
        "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Pipes the readable stream to a destination. Returns the destination.",
        "deprecated": false
      }
    },
    {
      "name": "compose",
      "parameters": [
        {
          "name": "stream",
          "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Composes multiple streams into one. Returns the composed stream.",
        "deprecated": false
      }
    },
    {
      "name": "request.get",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Return request header.\n\nThe `Referrer` header field is special-cased,\nboth `Referrer` and `Referer` are interchangeable.\n\nExamples:\n\n    req.get('Content-Type');\n    // => \"text/plain\"\n\n    req.get('content-type');\n    // => \"text/plain\"\n\n    req.get('Something');\n    // => undefined\n\nAliased as `req.header()`.",
        "deprecated": false
      }
    },
    {
      "name": "request.header",
      "parameters": [
        {
          "name": "name",
          "type": "\"set-cookie\"",
          "optional": false
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "xaiDescription": "Alias for `request.get`. Returns request header.",
        "deprecated": false
      }
    },
    {
      "name": "request.accepts",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsCharsets",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsEncodings",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.acceptsLanguages",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
        "deprecated": false
      }
    },
    {
      "name": "request.range",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        },
        {
          "name": "options",
          "type": "Options",
          "optional": true
        }
      ],
      "returnType": "Ranges | Result",
      "jsdoc": {
        "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
        "deprecated": false
      }
    },
    {
      "name": "request.toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of an array.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.",
        "deprecated": false
      }
    },
    {
      "name": "request.pop",
      "parameters": [],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "request.push",
      "parameters": [
        {
          "name": "items",
          "type": "MediaType[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Appends new elements to the end of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "New elements to add to the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.concat",
      "parameters": [
        {
          "name": "items",
          "type": "ConcatArray<MediaType>[]",
          "optional": false
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Combines two or more arrays.\nThis method returns a new array without modifying any existing arrays.",
        "params": [
          {
            "name": "items",
            "description": "Additional arrays and/or items to add to the end of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.join",
      "parameters": [
        {
          "name": "separator",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
        "params": [
          {
            "name": "separator",
            "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reverse",
      "parameters": [],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "deprecated": false
      }
    },
    {
      "name": "request.shift",
      "parameters": [],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
        "deprecated": false
      }
    },
    {
      "name": "request.slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Returns a copy of a section of an array.\nFor both start and end, a negative index can be used to indicate an offset from the end of the array.\nFor example, -2 refers to the second to last element of the array.",
        "params": [
          {
            "name": "start",
            "description": "The beginning index of the specified portion of the array.\nIf start is undefined, then the slice begins at index 0."
          },
          {
            "name": "end",
            "description": "The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\nIf end is undefined, then the slice extends to the end of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.sort",
      "parameters": [
        {
          "name": "compareFn",
          "type": "(a: MediaType, b: MediaType) => number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
        "params": [
          {
            "name": "compareFn",
            "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\nts\n[11,2,22,1].sort((a, b) => a - b)\n"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.splice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "deleteCount",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based location in the array from which to start removing elements."
          },
          {
            "name": "deleteCount",
            "description": "The number of elements to remove."
          }
        ],
        "returns": "An array containing the elements that were deleted.",
        "deprecated": false
      }
    },
    {
      "name": "request.unshift",
      "parameters": [
        {
          "name": "items",
          "type": "MediaType[]",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
        "params": [
          {
            "name": "items",
            "description": "Elements to insert at the start of the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.indexOf",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first occurrence of a value in an array, or -1 if it is not present.",
        "params": [
          {
            "name": "searchElement",
            "description": "The value to locate in the array."
          },
          {
            "name": "fromIndex",
            "description": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.lastIndexOf",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.",
        "params": [
          {
            "name": "searchElement",
            "description": "The value to locate in the array."
          },
          {
            "name": "fromIndex",
            "description": "The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.every",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether all the members of an array satisfy the specified test.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.some",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether the specified callback function returns true for any element of an array.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.forEach",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: MediaType, index: number, array: MediaType[]) => void",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Performs the specified action for each element in an array.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.map",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(value: MediaType, index: number, array: MediaType[]) => U",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.filter",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S[]",
      "jsdoc": {
        "description": "Returns the elements of an array that meet the condition specified in a callback function.",
        "params": [
          {
            "name": "predicate",
            "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reduce",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.reduceRight",
      "parameters": [
        {
          "name": "callbackfn",
          "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": {
        "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
        "params": [
          {
            "name": "callbackfn",
            "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
          },
          {
            "name": "initialValue",
            "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.find",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, obj: MediaType[]) => value is S",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "S",
      "jsdoc": {
        "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.findIndex",
      "parameters": [
        {
          "name": "predicate",
          "type": "(value: MediaType, index: number, obj: MediaType[]) => unknown",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
        "params": [
          {
            "name": "predicate",
            "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
          },
          {
            "name": "thisArg",
            "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.fill",
      "parameters": [
        {
          "name": "value",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
        "params": [
          {
            "name": "value",
            "description": "value to fill array section with"
          },
          {
            "name": "start",
            "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
          },
          {
            "name": "end",
            "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.copyWithin",
      "parameters": [
        {
          "name": "target",
          "type": "number",
          "optional": false
        },
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "MediaType[]",
      "jsdoc": {
        "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
        "params": [
          {
            "name": "target",
            "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
          },
          {
            "name": "start",
            "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
          },
          {
            "name": "end",
            "description": "If not specified, length of the this object is used as its default value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.entries",
      "parameters": [],
      "returnType": "ArrayIterator<[number, MediaType]>",
      "jsdoc": {
        "description": "Returns an iterable of key, value pairs for every entry in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.keys",
      "parameters": [],
      "returnType": "ArrayIterator<number>",
      "jsdoc": {
        "description": "Returns an iterable of keys in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.values",
      "parameters": [],
      "returnType": "ArrayIterator<MediaType>",
      "jsdoc": {
        "description": "Returns an iterable of values in the array",
        "deprecated": false
      }
    },
    {
      "name": "request.includes",
      "parameters": [
        {
          "name": "searchElement",
          "type": "MediaType",
          "optional": false
        },
        {
          "name": "fromIndex",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Determines whether an array includes a certain element, returning true or false as appropriate.",
        "params": [
          {
            "name": "searchElement",
            "description": "The element to search for."
          },
          {
            "name": "fromIndex",
            "description": "The position in this array at which to begin searching for searchElement."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.flatMap",
      "parameters": [
        {
          "name": "callback",
          "type": "(this: This, value: MediaType, index: number, array: MediaType[]) => U | readonly U[]",
          "optional": false
        },
        {
          "name": "thisArg",
          "type": "This",
          "optional": true
        }
      ],
      "returnType": "U[]",
      "jsdoc": {
        "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
        "params": [
          {
            "name": "callback",
            "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
          },
          {
            "name": "thisArg",
            "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.flat",
      "parameters": [
        {
          "name": "depth",
          "type": "D",
          "optional": true
        }
      ],
      "returnType": "FlatArray<A, D>[]",
      "jsdoc": {
        "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
        "params": [
          {
            "name": "depth",
            "description": "The maximum recursion depth"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.__@iterator@69548",
      "parameters": [],
      "returnType": "ArrayIterator<MediaType>",
      "jsdoc": {
        "description": "Iterator",
        "deprecated": false
      }
    },
    {
      "name": "request.at",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "MediaType",
      "jsdoc": null,
      "xaiDescription": "Returns the element at the specified index in the array."
    },
    {
      "name": "request.is",
      "parameters": [
        {
          "name": "type",
          "type": "string | string[]",
          "optional": false
        }
      ],
      "returnType": "string | false",
      "jsdoc": {
        "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
        "deprecated": false
      }
    },
    {
      "name": "request.charAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the character at the specified index.",
        "params": [
          {
            "name": "pos",
            "description": "The zero-based index of the desired character."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.charCodeAt",
      "parameters": [
        {
          "name": "index",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the Unicode value of the character at the specified location.",
        "params": [
          {
            "name": "index",
            "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.localeCompare",
      "parameters": [
        {
          "name": "that",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Determines whether two strings are equivalent in the current locale.",
        "params": [
          {
            "name": "that",
            "description": "String to compare to target string"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.match",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpMatchArray",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.replace",
      "parameters": [
        {
          "name": "searchValue",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "replaceValue",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Replaces text in a string, using a regular expression or search string.",
        "params": [
          {
            "name": "searchValue",
            "description": "A string or regular expression to search for."
          },
          {
            "name": "replaceValue",
            "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.search",
      "parameters": [
        {
          "name": "regexp",
          "type": "string | RegExp",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Finds the first substring match in a regular expression search.",
        "params": [
          {
            "name": "regexp",
            "description": "The regular expression pattern and applicable flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.split",
      "parameters": [
        {
          "name": "separator",
          "type": "string | RegExp",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Split a string into substrings using the specified separator and return them as an array.",
        "params": [
          {
            "name": "separator",
            "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
          },
          {
            "name": "limit",
            "description": "A value used to limit the number of elements returned in the array."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.substring",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": false
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the substring at the specified location within a String object.",
        "params": [
          {
            "name": "start",
            "description": "The zero-based index number indicating the beginning of the substring."
          },
          {
            "name": "end",
            "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.toLowerCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to lowercase.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleLowerCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "request.toUpperCase",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Converts all the alphabetic characters in a string to uppercase.",
        "deprecated": false
      }
    },
    {
      "name": "request.toLocaleUpperCase",
      "parameters": [
        {
          "name": "locales",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
        "deprecated": false
      }
    },
    {
      "name": "request.trim",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading and trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.substr",
      "parameters": [
        {
          "name": "from",
          "type": "number",
          "optional": false
        },
        {
          "name": "length",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets a substring beginning at the specified location and having the specified length.",
        "params": [
          {
            "name": "from",
            "description": "The starting position of the desired substring. The index of the first character in the string is zero."
          },
          {
            "name": "length",
            "description": "The number of characters to include in the returned substring."
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "request.valueOf",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the primitive value of the specified object.",
        "deprecated": false
      }
    },
    {
      "name": "request.codePointAt",
      "parameters": [
        {
          "name": "pos",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
        "deprecated": false
      }
    },
    {
      "name": "request.endsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "endPosition",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition – length(this). Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "request.normalize",
      "parameters": [
        {
          "name": "form",
          "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
        "params": [
          {
            "name": "form",
            "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.repeat",
      "parameters": [
        {
          "name": "count",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
        "params": [
          {
            "name": "count",
            "description": "number of copies to append"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.startsWith",
      "parameters": [
        {
          "name": "searchString",
          "type": "string",
          "optional": false
        },
        {
          "name": "position",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
        "deprecated": false
      }
    },
    {
      "name": "request.anchor",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
        "params": [
          {
            "name": "name"
          }
        ],
        "deprecated": true
      }
    },
    {
      "name": "request.big",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<big>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.blink",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<blink>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.bold",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<b>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fixed",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<tt>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fontcolor",
      "parameters": [
        {
          "name": "color",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the color attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.fontsize",
      "parameters": [
        {
          "name": "size",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<font>` HTML element and sets the size attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.italics",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<i>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.link",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns an `<a>` HTML element and sets the href attribute value",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.small",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<small>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.strike",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<strike>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.sub",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sub>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.sup",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a `<sup>` HTML element",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.padStart",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.padEnd",
      "parameters": [
        {
          "name": "maxLength",
          "type": "number",
          "optional": false
        },
        {
          "name": "fillString",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
        "params": [
          {
            "name": "maxLength",
            "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
          },
          {
            "name": "fillString",
            "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.trimEnd",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.trimStart",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "deprecated": false
      }
    },
    {
      "name": "request.trimLeft",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the leading white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.trimRight",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Removes the trailing white space and line terminator characters from a string.",
        "params": [],
        "deprecated": true
      }
    },
    {
      "name": "request.matchAll",
      "parameters": [
        {
          "name": "regexp",
          "type": "RegExp",
          "optional": false
        }
      ],
      "returnType": "RegExpStringIterator<RegExpExecArray>",
      "jsdoc": {
        "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
        "params": [
          {
            "name": "regexp",
            "description": "A variable name or string literal containing the regular expression pattern and flags."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.app",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
          "optional": false
        }
      ],
      "returnType": "any",
      "jsdoc": null,
      "xaiDescription": "Handles incoming request and response objects."
    },
    {
      "name": "request.init",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
        "deprecated": false
      }
    },
    {
      "name": "request.defaultConfiguration",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Initialize application configuration.",
        "deprecated": false
      }
    },
    {
      "name": "request.engine",
      "parameters": [
        {
          "name": "ext",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
        "deprecated": false
      }
    },
    {
      "name": "request.set",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
        "deprecated": false
      }
    },
    {
      "name": "request.param",
      "parameters": [
        {
          "name": "name",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "handler",
          "type": "RequestParamHandler",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null,
      "xaiDescription": "Registers a parameter handler for the specified name(s)."
    },
    {
      "name": "request.path",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
        "deprecated": false
      }
    },
    {
      "name": "request.enabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
        "deprecated": false
      }
    },
    {
      "name": "request.disabled",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
        "deprecated": false
      }
    },
    {
      "name": "request.enable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Enable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "request.disable",
      "parameters": [
        {
          "name": "setting",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Disable `setting`.",
        "deprecated": false
      }
    },
    {
      "name": "request.render",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "object",
          "optional": true
        },
        {
          "name": "callback",
          "type": "(err: Error, html: string) => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
        "deprecated": false
      }
    },
    {
      "name": "request.listen",
      "parameters": [
        {
          "name": "port",
          "type": "number",
          "optional": false
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false
        },
        {
          "name": "backlog",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": true
        }
      ],
      "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
      "jsdoc": {
        "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
        "deprecated": false
      }
    },
    {
      "name": "request.router",
      "parameters": [
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "res",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": false
        }
      ],
      "returnType": "void | Promise<void>",
      "jsdoc": null,
      "xaiDescription": "Handles routing for the incoming request."
    },
    {
      "name": "request.use",
      "parameters": [
        {
          "name": "handlers",
          "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": null,
      "xaiDescription": "Adds middleware handlers to the application."
    },
    {
      "name": "request.on",
      "parameters": [
        {
          "name": "event",
          "type": "string",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(parent: Application<Record<string, any>>) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
        "deprecated": false
      }
    },
    {
      "name": "request.__@captureRejectionSymbol@69398",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "event",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": null,
      "xaiDescription": "Handles error rejection for the specified event."
    },
    {
      "name": "request.addListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.on(eventName, listener)`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.once",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.removeListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.off",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Alias for `emitter.removeListener()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.removeAllListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": true
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setMaxListeners",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.getMaxListeners",
      "parameters": [],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.listeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.rawListeners",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        }
      ],
      "returnType": "Function[]",
      "jsdoc": {
        "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.emit",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "args",
          "type": "AnyRest",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.listenerCount",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "Function",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event being listened for"
          },
          {
            "name": "listener",
            "description": "The event handler function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.prependListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.prependOnceListener",
      "parameters": [
        {
          "name": "eventName",
          "type": "string | symbol",
          "optional": false
        },
        {
          "name": "listener",
          "type": "(...args: any[]) => void",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Adds a one-time listener function for the event to the beginning of the listeners array. Removes and invokes the listener on the next event trigger.",
        "params": [
          {
            "name": "eventName",
            "description": "The name of the event."
          },
          {
            "name": "listener",
            "description": "The callback function"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.eventNames",
      "parameters": [],
      "returnType": "(string | symbol)[]",
      "jsdoc": {
        "description": "Returns an array of events for which the emitter has registered listeners.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.all",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "description": "Applies the given route path, middleware, and callback to every HTTP method.",
        "deprecated": false
      }
    },
    {
      "name": "request.post",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles POST requests for the specified route path."
      }
    },
    {
      "name": "request.put",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PUT requests for the specified route path."
      }
    },
    {
      "name": "request.delete",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles DELETE requests for the specified route path."
      }
    },
    {
      "name": "request.patch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PATCH requests for the specified route path."
      }
    },
    {
      "name": "request.options",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles OPTIONS requests for the specified route path."
      }
    },
    {
      "name": "request.head",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles HEAD requests for the specified route path."
      }
    },
    {
      "name": "request.checkout",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles CHECKOUT requests for the specified route path."
      }
    },
    {
      "name": "request.connect",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles CONNECT requests for the specified route path."
      }
    },
    {
      "name": "request.copy",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles COPY requests for the specified route path."
      }
    },
    {
      "name": "request.lock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles LOCK requests for the specified route path."
      }
    },
    {
      "name": "request.merge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MERGE requests for the specified route path."
      }
    },
    {
      "name": "request.mkactivity",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MKACTIVITY requests for the specified route path."
      }
    },
    {
      "name": "request.mkcol",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MKCOL requests for the specified route path."
      }
    },
    {
      "name": "request.move",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles MOVE requests for the specified route path."
      }
    },
    {
      "name": "request.m-search",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles M-SEARCH requests for the specified route path."
      }
    },
    {
      "name": "request.notify",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles NOTIFY requests for the specified route path."
      }
    },
    {
      "name": "request.propfind",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PROPFIND requests for the specified route path."
      }
    },
    {
      "name": "request.proppatch",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PROPPATCH requests for the specified route path."
      }
    },
    {
      "name": "request.purge",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles PURGE requests for the specified route path."
      }
    },
    {
      "name": "request.report",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles REPORT requests for the specified route path."
      }
    },
    {
      "name": "request.subscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles SUBSCRIBE requests for the specified route path."
      }
    },
    {
      "name": "request.trace",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles TRACE requests for the specified route path."
      }
    },
    {
      "name": "request.unlock",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNLOCK requests for the specified route path."
      }
    },
    {
      "name": "request.unsubscribe",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNSUBSCRIBE requests for the specified route path."
      }
    },
    {
      "name": "request.unlink",
      "parameters": [
        {
          "name": "path",
          "type": "Route",
          "optional": false
        },
        {
          "name": "handlers",
          "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
          "optional": false
        }
      ],
      "returnType": "Application<Record<string, any>>",
      "jsdoc": {
        "xaiDescription": "Handles UNLINK requests for the specified route path."
      }
    },
    {
      "name": "request.route",
      "parameters": [
        {
          "name": "prefix",
          "type": "T",
          "optional": false
        }
      ],
      "returnType": "IRoute<T>",
      "jsdoc": {
        "xaiDescription": "Creates a new route with the specified prefix."
      }
    },
    {
      "name": "request.status",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set status code.",
        "deprecated": false
      }
    },
    {
      "name": "request.sendStatus",
      "parameters": [
        {
          "name": "code",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set HTTP status code and send its string representation as the response body.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.links",
      "parameters": [
        {
          "name": "links",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set Link header field with the given links.",
        "deprecated": false
      }
    },
    {
      "name": "request.send",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send a response.",
        "deprecated": false
      }
    },
    {
      "name": "request.json",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send JSON response.",
        "deprecated": false
      }
    },
    {
      "name": "request.jsonp",
      "parameters": [
        {
          "name": "body",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Send JSON response with JSONP callback support.",
        "deprecated": false
      }
    },
    {
      "name": "request.sendFile",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given path.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.download",
      "parameters": [
        {
          "name": "path",
          "type": "string",
          "optional": false
        },
        {
          "name": "fn",
          "type": "Errback",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Transfer the file at the given path as an attachment.",
        "deprecated": false
      }
    },
    {
      "name": "request.contentType",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set Content-Type response header with type through mime.lookup().",
        "deprecated": false
      }
    },
    {
      "name": "request.type",
      "parameters": [
        {
          "name": "type",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set Content-Type response header with type through mime.lookup().",
        "deprecated": false
      }
    },
    {
      "name": "request.format",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Respond to the Acceptable formats using an object of mime-type callbacks.",
        "deprecated": false
      }
    },
    {
      "name": "request.attachment",
      "parameters": [
        {
          "name": "filename",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set Content-Disposition header to attachment with optional filename.",
        "deprecated": false
      }
    },
    {
      "name": "request.clearCookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Clear cookie name.",
        "deprecated": false
      }
    },
    {
      "name": "request.cookie",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "val",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "CookieOptions",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set cookie name to val, with the given options.",
        "deprecated": false
      }
    },
    {
      "name": "request.location",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Set the location header to url.",
        "deprecated": false
      }
    },
    {
      "name": "request.redirect",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Redirect to the given url with optional response status defaulting to 302.",
        "deprecated": false
      }
    },
    {
      "name": "request.vary",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Adds the field to the Vary response header, if it is not there already.",
        "deprecated": false
      }
    },
    {
      "name": "request.append",
      "parameters": [
        {
          "name": "field",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | string[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Appends the specified value to the HTTP response header field.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.assignSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Assigns the specified socket to the request."
      }
    },
    {
      "name": "request.detachSocket",
      "parameters": [
        {
          "name": "socket",
          "type": "Socket",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Detaches the specified socket from the request."
      }
    },
    {
      "name": "request.writeContinue",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 100 Continue message to the client.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.writeEarlyHints",
      "parameters": [
        {
          "name": "hints",
          "type": "Record<string, string | string[]>",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
        "params": [
          {
            "name": "hints",
            "description": "An object containing the values of headers"
          },
          {
            "name": "callback",
            "description": "Will be called when the response message has been written"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.writeHead",
      "parameters": [
        {
          "name": "statusCode",
          "type": "number",
          "optional": false
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true
        },
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.writeProcessing",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.setTimeout",
      "parameters": [
        {
          "name": "msecs",
          "type": "number",
          "optional": false
        },
        {
          "name": "callback",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.",
        "params": [
          {
            "name": "callback",
            "description": "Optional function to be called when a timeout occurs. Same as binding to the `timeout` event."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | number | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setHeaders",
      "parameters": [
        {
          "name": "headers",
          "type": "Headers | Map<string, string | number | readonly string[]>",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.appendHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | readonly string[]",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          },
          {
            "name": "value",
            "description": "Header value"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string | number | string[]",
      "jsdoc": {
        "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
        "params": [
          {
            "name": "name",
            "description": "Name of header"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeaders",
      "parameters": [],
      "returnType": "OutgoingHttpHeaders",
      "jsdoc": {
        "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.getHeaderNames",
      "parameters": [],
      "returnType": "string[]",
      "jsdoc": {
        "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.hasHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.removeHeader",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
        "params": [
          {
            "name": "name",
            "description": "Header name"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.addTrailers",
      "parameters": [
        {
          "name": "headers",
          "type": "OutgoingHttpHeaders | readonly [string, string][]",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.flushHeaders",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request._write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Writes data to the stream, calls callback when done."
      }
    },
    {
      "name": "request._writev",
      "parameters": [
        {
          "name": "chunks",
          "type": "{ chunk: any; encoding: BufferEncoding; }[]",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Writes multiple chunks to the stream, calls callback when done."
      }
    },
    {
      "name": "request._construct",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Initializes the stream, calls callback when done."
      }
    },
    {
      "name": "request._destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Destroys the stream, calls callback when done."
      }
    },
    {
      "name": "request._final",
      "parameters": [
        {
          "name": "callback",
          "type": "(error?: Error) => void",
          "optional": false
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Finalizes the stream, calls callback when done."
      }
    },
    {
      "name": "request.write",
      "parameters": [
        {
          "name": "chunk",
          "type": "any",
          "optional": false
        },
        {
          "name": "callback",
          "type": "(error: Error) => void",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\njs\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding, if `chunk` is a string."
          },
          {
            "name": "callback",
            "description": "Callback for when this chunk of data is flushed."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.setDefaultEncoding",
      "parameters": [
        {
          "name": "encoding",
          "type": "BufferEncoding",
          "optional": false
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
        "params": [
          {
            "name": "encoding",
            "description": "The new default encoding"
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.end",
      "parameters": [
        {
          "name": "cb",
          "type": "() => void",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\njs\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n",
        "params": [
          {
            "name": "chunk",
            "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
          },
          {
            "name": "encoding",
            "description": "The encoding if `chunk` is a string"
          },
          {
            "name": "callback",
            "description": "Callback for when the stream is finished."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.cork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.uncork",
      "parameters": [],
      "returnType": "void",
      "jsdoc": {
        "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
        "params": [],
        "deprecated": false
      }
    },
    {
      "name": "request.destroy",
      "parameters": [
        {
          "name": "error",
          "type": "Error",
          "optional": true
        }
      ],
      "returnType": "Response<any, Record<string, any>, number>",
      "jsdoc": {
        "description": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the writable\nstream has ended and subsequent calls to `write()` or `end()` will result in\nan `ERR_STREAM_DESTROYED` error.\nThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\nUse `end()` instead of destroy if data should flush before close, or wait for\nthe `'drain'` event before destroying the stream.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method,\nbut instead implement `writable._destroy()`.",
        "params": [
          {
            "name": "error",
            "description": "Optional, an error to emit with `'error'` event."
          }
        ],
        "deprecated": false
      }
    },
    {
      "name": "request.pipe",
      "parameters": [
        {
          "name": "destination",
          "type": "T",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ end?: boolean; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Pipes the readable stream to the destination, optionally ending the destination."
      }
    },
    {
      "name": "request.compose",
      "parameters": [
        {
          "name": "stream",
          "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
          "optional": false
        },
        {
          "name": "options",
          "type": "{ signal: AbortSignal; }",
          "optional": true
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "xaiDescription": "Composes the stream with another stream or iterable, optionally with an abort signal."
      }
    },
    {
      "name": "request.next",
      "parameters": [
        {
          "name": "err",
          "type": "any",
          "optional": true
        }
      ],
      "returnType": "void",
      "jsdoc": {
        "xaiDescription": "Advances to the next item in the stream, optionally with an error."
      }
    },
    {
      "name": "request.toFixed",
      "parameters": [
        {
          "name": "fractionDigits",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Returns a string representing a number in fixed-point notation.",
        "params": [
          {
            "name": "fractionDigits",
            "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
          }
        ],
        "deprecated": false
      }
    }
  ],
  "enums": [],
  "types": [
    {
      "name": "RouterOptions",
      "type": "RouterOptions",
      "properties": [
        {
          "name": "caseSensitive",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "mergeParams",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "strict",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Options for configuring router behavior."
      },
      "isExported": false
    },
    {
      "name": "Application",
      "type": "Application",
      "properties": [
        {
          "name": "init",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "defaultConfiguration",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "engine",
          "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Application",
          "optional": false
        },
        {
          "name": "set",
          "type": "(setting: string, val: any) => Application",
          "optional": false
        },
        {
          "name": "get",
          "type": "((name: string) => any) & IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "param",
          "type": "(name: string | string[], handler: RequestParamHandler) => Application",
          "optional": false
        },
        {
          "name": "path",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "enabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "disabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "enable",
          "type": "(setting: string) => Application",
          "optional": false
        },
        {
          "name": "disable",
          "type": "(setting: string) => Application",
          "optional": false
        },
        {
          "name": "render",
          "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
          "optional": false
        },
        {
          "name": "listen",
          "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
          "optional": false
        },
        {
          "name": "router",
          "type": "Router",
          "optional": false
        },
        {
          "name": "settings",
          "type": "any",
          "optional": false
        },
        {
          "name": "resource",
          "type": "any",
          "optional": false
        },
        {
          "name": "map",
          "type": "any",
          "optional": false
        },
        {
          "name": "locals",
          "type": "Record<string, any> & Locals",
          "optional": false
        },
        {
          "name": "routes",
          "type": "any",
          "optional": false
        },
        {
          "name": "_router",
          "type": "any",
          "optional": false
        },
        {
          "name": "use",
          "type": "ApplicationRequestHandler<Application>",
          "optional": false
        },
        {
          "name": "on",
          "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Application",
          "optional": false
        },
        {
          "name": "mountpath",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@69398",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "addListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "once",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Application",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Application",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "emit",
          "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Application, \"all\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Application, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Application, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Application, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Application, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Application, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Application, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Application, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Application"
      ],
      "jsdoc": {
        "xaiDescription": "Represents an Express application. Extends core.Application."
      },
      "isExported": false
    },
    {
      "name": "CookieOptions",
      "type": "CookieOptions",
      "properties": [
        {
          "name": "maxAge",
          "type": "number",
          "optional": true
        },
        {
          "name": "signed",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "expires",
          "type": "Date",
          "optional": true
        },
        {
          "name": "httpOnly",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "path",
          "type": "string",
          "optional": true
        },
        {
          "name": "domain",
          "type": "string",
          "optional": true
        },
        {
          "name": "secure",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "encode",
          "type": "(val: string) => string",
          "optional": true
        },
        {
          "name": "sameSite",
          "type": "boolean | \"lax\" | \"strict\" | \"none\"",
          "optional": true
        },
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\"",
          "optional": true
        },
        {
          "name": "partitioned",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [
        "core.CookieOptions"
      ],
      "jsdoc": {
        "xaiDescription": "Options for setting cookies. Extends core.CookieOptions."
      },
      "isExported": false
    },
    {
      "name": "Errback",
      "type": "Errback",
      "properties": [],
      "extends": [
        "core.Errback"
      ],
      "jsdoc": {
        "xaiDescription": "Callback function for handling errors. Extends core.Errback."
      },
      "isExported": false
    },
    {
      "name": "ErrorRequestHandler",
      "type": "ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [],
      "extends": [
        "core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": {
        "xaiDescription": "Middleware for handling errors. Extends core.ErrorRequestHandler."
      },
      "isExported": false
    },
    {
      "name": "Express",
      "type": "Express",
      "properties": [
        {
          "name": "request",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false
        },
        {
          "name": "response",
          "type": "Response<any, Record<string, any>, number>",
          "optional": false
        },
        {
          "name": "init",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "defaultConfiguration",
          "type": "() => void",
          "optional": false
        },
        {
          "name": "engine",
          "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Express",
          "optional": false
        },
        {
          "name": "set",
          "type": "(setting: string, val: any) => Express",
          "optional": false
        },
        {
          "name": "get",
          "type": "((name: string) => any) & IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "param",
          "type": "(name: string | string[], handler: RequestParamHandler) => Express",
          "optional": false
        },
        {
          "name": "path",
          "type": "() => string",
          "optional": false
        },
        {
          "name": "enabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "disabled",
          "type": "(setting: string) => boolean",
          "optional": false
        },
        {
          "name": "enable",
          "type": "(setting: string) => Express",
          "optional": false
        },
        {
          "name": "disable",
          "type": "(setting: string) => Express",
          "optional": false
        },
        {
          "name": "render",
          "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
          "optional": false
        },
        {
          "name": "listen",
          "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
          "optional": false
        },
        {
          "name": "router",
          "type": "Router",
          "optional": false
        },
        {
          "name": "settings",
          "type": "any",
          "optional": false
        },
        {
          "name": "resource",
          "type": "any",
          "optional": false
        },
        {
          "name": "map",
          "type": "any",
          "optional": false
        },
        {
          "name": "locals",
          "type": "Record<string, any> & Locals",
          "optional": false
        },
        {
          "name": "routes",
          "type": "any",
          "optional": false
        },
        {
          "name": "_router",
          "type": "any",
          "optional": false
        },
        {
          "name": "use",
          "type": "ApplicationRequestHandler<Express>",
          "optional": false
        },
        {
          "name": "on",
          "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Express",
          "optional": false
        },
        {
          "name": "mountpath",
          "type": "string | string[]",
          "optional": false
        },
        {
          "name": "__@captureRejectionSymbol@69398",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true
        },
        {
          "name": "addListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "once",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "removeListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Express",
          "optional": false
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Express",
          "optional": false
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false
        },
        {
          "name": "emit",
          "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
          "optional": false
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false
        },
        {
          "name": "prependListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "prependOnceListener",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
          "optional": false
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Express, \"all\">",
          "optional": false
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Express, \"post\">",
          "optional": false
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Express, \"put\">",
          "optional": false
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Express, \"delete\">",
          "optional": false
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Express, \"patch\">",
          "optional": false
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Express, \"options\">",
          "optional": false
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Express, \"head\">",
          "optional": false
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Express, any>",
          "optional": false
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false
        }
      ],
      "extends": [
        "core.Express"
      ],
      "jsdoc": {
        "xaiDescription": "Represents an Express application. Extends core.Express."
      },
      "isExported": false
    },
    {
      "name": "Handler",
      "type": "Handler",
      "properties": [],
      "extends": [
        "core.Handler"
      ],
      "jsdoc": {
        "xaiDescription": "Function to handle requests. Extends core.Handler."
      },
      "isExported": false
    },
    {
      "name": "IRoute",
      "type": "IRoute",
      "properties": [
        {
          "name": "path",
          "type": "string",
          "optional": false,
          "xaiDescription": "Defines the route path. Uses string."
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false,
          "xaiDescription": "Array of middleware layers. Uses ILayer[]."
        },
        {
          "name": "all",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles all HTTP methods. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "get",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles GET requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "post",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles POST requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "put",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles PUT requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "delete",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles DELETE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "patch",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles PATCH requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "options",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles OPTIONS requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "head",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles HEAD requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "checkout",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles CHECKOUT requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "copy",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles COPY requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "lock",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles LOCK requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "merge",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles MERGE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "mkactivity",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles MKACTIVITY requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "mkcol",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles MKCOL requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "move",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles MOVE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "m-search",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles M-SEARCH requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "notify",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles NOTIFY requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "purge",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles PURGE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "report",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles REPORT requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "search",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles SEARCH requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "subscribe",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles SUBSCRIBE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "trace",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles TRACE requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "unlock",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles UNLOCK requests. Uses IRouterHandler<IRoute, string>."
        },
        {
          "name": "unsubscribe",
          "type": "IRouterHandler<IRoute, string>",
          "optional": false,
          "xaiDescription": "Handles UNSUBSCRIBE requests. Uses IRouterHandler<IRoute, string>."
        }
      ],
      "extends": [
        "core.IRoute"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Interface for route handling. Extends core.IRoute."
    },
    {
      "name": "IRouter",
      "type": "IRouter",
      "properties": [
        {
          "name": "param",
          "type": "(name: string, handler: RequestParamHandler) => IRouter",
          "optional": false,
          "xaiDescription": "Adds a parameter handler. Uses RequestParamHandler, returns IRouter."
        },
        {
          "name": "all",
          "type": "IRouterMatcher<IRouter, \"all\">",
          "optional": false,
          "xaiDescription": "Matches all HTTP methods. Uses IRouterMatcher<IRouter, 'all'>."
        },
        {
          "name": "get",
          "type": "IRouterMatcher<IRouter, \"get\">",
          "optional": false,
          "xaiDescription": "Matches GET requests. Uses IRouterMatcher<IRouter, 'get'>."
        },
        {
          "name": "post",
          "type": "IRouterMatcher<IRouter, \"post\">",
          "optional": false,
          "xaiDescription": "Matches POST requests. Uses IRouterMatcher<IRouter, 'post'>."
        },
        {
          "name": "put",
          "type": "IRouterMatcher<IRouter, \"put\">",
          "optional": false,
          "xaiDescription": "Matches PUT requests. Uses IRouterMatcher<IRouter, 'put'>."
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<IRouter, \"delete\">",
          "optional": false,
          "xaiDescription": "Matches DELETE requests. Uses IRouterMatcher<IRouter, 'delete'>."
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<IRouter, \"patch\">",
          "optional": false,
          "xaiDescription": "Matches PATCH requests. Uses IRouterMatcher<IRouter, 'patch'>."
        },
        {
          "name": "options",
          "type": "IRouterMatcher<IRouter, \"options\">",
          "optional": false,
          "xaiDescription": "Matches OPTIONS requests. Uses IRouterMatcher<IRouter, 'options'>."
        },
        {
          "name": "head",
          "type": "IRouterMatcher<IRouter, \"head\">",
          "optional": false,
          "xaiDescription": "Matches HEAD requests. Uses IRouterMatcher<IRouter, 'head'>."
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches CHECKOUT requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches CONNECT requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches COPY requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches LOCK requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches MERGE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches MKACTIVITY requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches MKCOL requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "move",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches MOVE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches M-SEARCH requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches NOTIFY requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches PROPFIND requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches PROPPATCH requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches PURGE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "report",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches REPORT requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "search",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches SEARCH requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches SUBSCRIBE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches TRACE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches UNLOCK requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches UNSUBSCRIBE requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "link",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches LINK requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Matches UNLINK requests. Uses IRouterMatcher<IRouter, any>."
        },
        {
          "name": "use",
          "type": "IRouterHandler<IRouter, string> & IRouterMatcher<IRouter, any>",
          "optional": false,
          "xaiDescription": "Adds middleware or matches routes. Uses IRouterHandler<IRouter, string> & IRouterMatcher<IRouter, any>."
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false,
          "xaiDescription": "Creates a new route. Returns IRoute<T> or IRoute<string>."
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false,
          "xaiDescription": "Array of middleware layers. Uses ILayer[]."
        }
      ],
      "extends": [
        "core.IRouter"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Interface for router handling. Extends core.IRouter."
    },
    {
      "name": "IRouterHandler",
      "type": "IRouterHandler<T>",
      "properties": [],
      "extends": [
        "core.IRouterHandler<T>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Interface for router handlers. Extends core.IRouterHandler<T>."
    },
    {
      "name": "IRouterMatcher",
      "type": "IRouterMatcher<T>",
      "properties": [],
      "extends": [
        "core.IRouterMatcher<T>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Interface for router matchers. Extends core.IRouterMatcher<T>."
    },
    {
      "name": "MediaType",
      "type": "MediaType",
      "properties": [
        {
          "name": "value",
          "type": "string",
          "optional": false,
          "xaiDescription": "The media type value. Uses string."
        },
        {
          "name": "quality",
          "type": "number",
          "optional": false,
          "xaiDescription": "The quality factor. Uses number."
        },
        {
          "name": "type",
          "type": "string",
          "optional": false,
          "xaiDescription": "The media type. Uses string."
        },
        {
          "name": "subtype",
          "type": "string",
          "optional": false,
          "xaiDescription": "The media subtype. Uses string."
        }
      ],
      "extends": [
        "core.MediaType"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents a media type. Extends core.MediaType."
    },
    {
      "name": "NextFunction",
      "type": "NextFunction",
      "properties": [],
      "extends": [
        "core.NextFunction"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Function to pass control to the next middleware. Extends core.NextFunction."
    },
    {
      "name": "Locals",
      "type": "Locals",
      "properties": [],
      "extends": [
        "core.Locals"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Object to store local variables. Extends core.Locals."
    },
    {
      "name": "Request",
      "type": "Request<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [
        {
          "name": "get",
          "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
          "optional": false,
          "xaiDescription": "Gets a header value. Returns string[] for 'set-cookie', string otherwise."
        },
        {
          "name": "header",
          "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
          "optional": false,
          "xaiDescription": "Gets a header value. Returns string[] for 'set-cookie', string otherwise."
        },
        {
          "name": "accepts",
          "type": "{ (): string[]; (type: string): string | false; (type: string[]): string | false; (...type: string[]): string | false; }",
          "optional": false,
          "xaiDescription": "Checks if the client accepts a content type. Returns string[] or string | false."
        },
        {
          "name": "acceptsCharsets",
          "type": "{ (): string[]; (charset: string): string | false; (charset: string[]): string | false; (...charset: string[]): string | false; }",
          "optional": false,
          "xaiDescription": "Checks if the client accepts a charset. Returns string[] or string | false."
        },
        {
          "name": "acceptsEncodings",
          "type": "{ (): string[]; (encoding: string): string | false; (encoding: string[]): string | false; (...encoding: string[]): string | false; }",
          "optional": false,
          "xaiDescription": "Checks if the client accepts an encoding. Returns string[] or string | false."
        },
        {
          "name": "acceptsLanguages",
          "type": "{ (): string[]; (lang: string): string | false; (lang: string[]): string | false; (...lang: string[]): string | false; }",
          "optional": false,
          "xaiDescription": "Checks if the client accepts a language. Returns string[] or string | false."
        },
        {
          "name": "range",
          "type": "(size: number, options?: Options) => Ranges | Result",
          "optional": false,
          "xaiDescription": "Parses the Range header. Returns Ranges or Result."
        },
        {
          "name": "accepted",
          "type": "MediaType[]",
          "optional": false,
          "xaiDescription": "List of accepted media types. Uses MediaType[]."
        },
        {
          "name": "is",
          "type": "(type: string | string[]) => string | false",
          "optional": false,
          "xaiDescription": "Checks if the request matches a content type. Returns string or false."
        },
        {
          "name": "protocol",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request protocol. Uses string."
        },
        {
          "name": "secure",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request is secure. Uses boolean."
        },
        {
          "name": "ip",
          "type": "string",
          "optional": false,
          "xaiDescription": "The client's IP address. Uses string."
        },
        {
          "name": "ips",
          "type": "string[]",
          "optional": false,
          "xaiDescription": "List of client IP addresses. Uses string[]."
        },
        {
          "name": "subdomains",
          "type": "string[]",
          "optional": false,
          "xaiDescription": "List of subdomains. Uses string[]."
        },
        {
          "name": "path",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request path. Uses string."
        },
        {
          "name": "hostname",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request hostname. Uses string."
        },
        {
          "name": "host",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request host. Uses string."
        },
        {
          "name": "fresh",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request is fresh. Uses boolean."
        },
        {
          "name": "stale",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request is stale. Uses boolean."
        },
        {
          "name": "xhr",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request is an XHR. Uses boolean."
        },
        {
          "name": "body",
          "type": "ReqBody",
          "optional": false,
          "xaiDescription": "The request body. Uses ReqBody."
        },
        {
          "name": "cookies",
          "type": "any",
          "optional": false,
          "xaiDescription": "The request cookies. Uses any."
        },
        {
          "name": "method",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request method. Uses string."
        },
        {
          "name": "params",
          "type": "P",
          "optional": false,
          "xaiDescription": "The route parameters. Uses P."
        },
        {
          "name": "query",
          "type": "ReqQuery",
          "optional": false,
          "xaiDescription": "The query string. Uses ReqQuery."
        },
        {
          "name": "route",
          "type": "any",
          "optional": false,
          "xaiDescription": "The matched route. Uses any."
        },
        {
          "name": "signedCookies",
          "type": "any",
          "optional": false,
          "xaiDescription": "The signed cookies. Uses any."
        },
        {
          "name": "originalUrl",
          "type": "string",
          "optional": false,
          "xaiDescription": "The original request URL. Uses string."
        },
        {
          "name": "url",
          "type": "string",
          "optional": false,
          "xaiDescription": "The request URL. Uses string."
        },
        {
          "name": "baseUrl",
          "type": "string",
          "optional": false,
          "xaiDescription": "The base URL. Uses string."
        },
        {
          "name": "app",
          "type": "Application<Record<string, any>>",
          "optional": false,
          "xaiDescription": "The application instance. Uses Application<Record<string, any>>."
        },
        {
          "name": "res",
          "type": "Response<ResBody, Locals, number>",
          "optional": true,
          "xaiDescription": "The response object. Uses Response<ResBody, Locals, number>."
        },
        {
          "name": "next",
          "type": "NextFunction",
          "optional": true,
          "xaiDescription": "The next middleware function. Uses NextFunction."
        },
        {
          "name": "aborted",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request was aborted. Uses boolean."
        },
        {
          "name": "httpVersion",
          "type": "string",
          "optional": false,
          "xaiDescription": "The HTTP version. Uses string."
        },
        {
          "name": "httpVersionMajor",
          "type": "number",
          "optional": false,
          "xaiDescription": "The major HTTP version. Uses number."
        },
        {
          "name": "httpVersionMinor",
          "type": "number",
          "optional": false,
          "xaiDescription": "The minor HTTP version. Uses number."
        },
        {
          "name": "complete",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the request is complete. Uses boolean."
        },
        {
          "name": "connection",
          "type": "Socket",
          "optional": false,
          "xaiDescription": "The underlying socket. Uses Socket."
        },
        {
          "name": "socket",
          "type": "Socket",
          "optional": false,
          "xaiDescription": "The underlying socket. Uses Socket."
        },
        {
          "name": "headers",
          "type": "IncomingHttpHeaders",
          "optional": false,
          "xaiDescription": "The request headers. Uses IncomingHttpHeaders."
        },
        {
          "name": "headersDistinct",
          "type": "Dict<string[]>",
          "optional": false,
          "xaiDescription": "The distinct request headers. Uses Dict<string[]>"
        },
        {
          "name": "rawHeaders",
          "type": "string[]",
          "optional": false,
          "xaiDescription": "The raw request headers. Uses string[]."
        },
        {
          "name": "trailers",
          "type": "Dict<string>",
          "optional": false,
          "xaiDescription": "The request trailers. Uses Dict<string>."
        },
        {
          "name": "trailersDistinct",
          "type": "Dict<string[]>",
          "optional": false,
          "xaiDescription": "The distinct request trailers. Uses Dict<string[]>"
        },
        {
          "name": "rawTrailers",
          "type": "string[]",
          "optional": false,
          "xaiDescription": "The raw request trailers. Uses string[]."
        },
        {
          "name": "setTimeout",
          "type": "(msecs: number, callback?: () => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Sets a timeout for the request. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "statusCode",
          "type": "number",
          "optional": true,
          "xaiDescription": "The response status code. Uses number."
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": true,
          "xaiDescription": "The response status message. Uses string."
        },
        {
          "name": "destroy",
          "type": "(error?: Error) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Destroys the request. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "readableAborted",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the readable stream was aborted. Uses boolean."
        },
        {
          "name": "readable",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the stream is readable. Uses boolean."
        },
        {
          "name": "readableDidRead",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the stream was read. Uses boolean."
        },
        {
          "name": "readableEncoding",
          "type": "BufferEncoding",
          "optional": false,
          "xaiDescription": "The readable stream encoding. Uses BufferEncoding."
        },
        {
          "name": "readableEnded",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the readable stream ended. Uses boolean."
        },
        {
          "name": "readableFlowing",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the readable stream is flowing. Uses boolean."
        },
        {
          "name": "readableHighWaterMark",
          "type": "number",
          "optional": false,
          "xaiDescription": "The high water mark for the readable stream. Uses number."
        },
        {
          "name": "readableLength",
          "type": "number",
          "optional": false,
          "xaiDescription": "The length of the readable stream. Uses number."
        },
        {
          "name": "readableObjectMode",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the readable stream is in object mode. Uses boolean."
        },
        {
          "name": "destroyed",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the stream was destroyed. Uses boolean."
        },
        {
          "name": "closed",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if the stream was closed. Uses boolean."
        },
        {
          "name": "errored",
          "type": "Error",
          "optional": false,
          "xaiDescription": "The error that occurred in the stream. Uses Error."
        },
        {
          "name": "_construct",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": true,
          "xaiDescription": "Constructs the stream. Uses callback function."
        },
        {
          "name": "_read",
          "type": "(size: number) => void",
          "optional": false,
          "xaiDescription": "Reads data from the stream. Uses size parameter."
        },
        {
          "name": "read",
          "type": "(size?: number) => any",
          "optional": false,
          "xaiDescription": "Reads data from the stream. Returns any."
        },
        {
          "name": "setEncoding",
          "type": "(encoding: BufferEncoding) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Sets the encoding for the stream. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "pause",
          "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Pauses the stream. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "resume",
          "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Resumes the stream. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "isPaused",
          "type": "() => boolean",
          "optional": false,
          "xaiDescription": "Checks if the stream is paused. Returns boolean."
        },
        {
          "name": "unpipe",
          "type": "(destination?: WritableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Unpipes the stream. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "unshift",
          "type": "(chunk: any, encoding?: BufferEncoding) => void",
          "optional": false,
          "xaiDescription": "Unshifts data into the stream. Uses chunk and encoding parameters."
        },
        {
          "name": "wrap",
          "type": "(stream: ReadableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Wraps a readable stream. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "push",
          "type": "(chunk: any, encoding?: BufferEncoding) => boolean",
          "optional": false,
          "xaiDescription": "Pushes data into the stream. Returns boolean."
        },
        {
          "name": "iterator",
          "type": "(options?: { destroyOnReturn?: boolean; }) => AsyncIterator<any, any, any>",
          "optional": false,
          "xaiDescription": "Creates an async iterator for the stream. Returns AsyncIterator<any, any, any>."
        },
        {
          "name": "map",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
          "optional": false,
          "xaiDescription": "Maps data in the stream. Returns Readable."
        },
        {
          "name": "filter",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Readable",
          "optional": false,
          "xaiDescription": "Filters data in the stream. Returns Readable."
        },
        {
          "name": "forEach",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>, options?: ArrayOptions) => Promise<void>",
          "optional": false,
          "xaiDescription": "Iterates over data in the stream. Returns Promise<void>."
        },
        {
          "name": "toArray",
          "type": "(options?: Pick<ArrayOptions, \"signal\">) => Promise<any[]>",
          "optional": false,
          "xaiDescription": "Converts the stream to an array. Returns Promise<any[]>"
        },
        {
          "name": "some",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
          "optional": false,
          "xaiDescription": "Checks if some data in the stream satisfies a condition. Returns Promise<boolean>."
        },
        {
          "name": "find",
          "type": "{ <T>(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T, options?: ArrayOptions): Promise<T>; (fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<...>, options?: ArrayOptions): Promise<...>; }",
          "optional": false,
          "xaiDescription": "Finds data in the stream. Returns Promise<T> or Promise<any>."
        },
        {
          "name": "every",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
          "optional": false,
          "xaiDescription": "Checks if all data in the stream satisfies a condition. Returns Promise<boolean>."
        },
        {
          "name": "flatMap",
          "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
          "optional": false,
          "xaiDescription": "Flattens and maps data in the stream. Returns Readable."
        },
        {
          "name": "drop",
          "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false,
          "xaiDescription": "Drops a specified number of elements from the stream. Returns Readable."
        },
        {
          "name": "take",
          "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false,
          "xaiDescription": "Takes a specified number of elements from the stream. Returns Readable."
        },
        {
          "name": "asIndexedPairs",
          "type": "(options?: Pick<ArrayOptions, \"signal\">) => Readable",
          "optional": false,
          "xaiDescription": "Converts the stream to indexed pairs. Returns Readable."
        },
        {
          "name": "reduce",
          "type": "{ <T = any>(fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T, initial?: undefined, options?: Pick<ArrayOptions, \"signal\">): Promise<...>; <T = any>(fn: (previous: T, data: any, options?: Pick<...>) => T, initial: T, options?: Pick<...>): Promise<...>; }",
          "optional": false,
          "xaiDescription": "Reduces the stream to a single value. Returns Promise<T>."
        },
        {
          "name": "_destroy",
          "type": "(error: Error, callback: (error?: Error) => void) => void",
          "optional": false,
          "xaiDescription": "Destroys the stream. Uses error and callback parameters."
        },
        {
          "name": "addListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Adds an event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "emit",
          "type": "{ (event: \"close\"): boolean; (event: \"data\", chunk: any): boolean; (event: \"end\"): boolean; (event: \"error\", err: Error): boolean; (event: \"pause\"): boolean; (event: \"readable\"): boolean; (event: \"resume\"): boolean; (event: string | symbol, ...args: any[]): boolean; }",
          "optional": false,
          "xaiDescription": "Emits an event. Returns boolean."
        },
        {
          "name": "on",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Adds an event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "once",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Adds a one-time event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "prependListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Prepends an event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "prependOnceListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Prepends a one-time event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "removeListener",
          "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
          "optional": false,
          "xaiDescription": "Removes an event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "__@asyncIterator@70027",
          "type": "() => AsyncIterator<any, any, any>",
          "optional": false,
          "xaiDescription": "Creates an async iterator for the stream. Returns AsyncIterator<any, any, any>."
        },
        {
          "name": "__@asyncDispose@70029",
          "type": "() => Promise<void>",
          "optional": false,
          "xaiDescription": "Disposes the stream asynchronously. Returns Promise<void>."
        },
        {
          "name": "pipe",
          "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
          "optional": false,
          "xaiDescription": "Pipes the stream to a writable stream. Returns T."
        },
        {
          "name": "compose",
          "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
          "optional": false,
          "xaiDescription": "Composes the stream with other streams. Returns T."
        },
        {
          "name": "__@captureRejectionSymbol@69398",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true,
          "xaiDescription": "Captures rejection events. Uses error, event, and args parameters."
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Removes an event listener. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Removes all event listeners. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
          "optional": false,
          "xaiDescription": "Sets the maximum number of listeners. Returns Request<P, ResBody, ReqBody, ReqQuery, Locals>."
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false,
          "xaiDescription": "Gets the maximum number of listeners. Returns number."
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false,
          "xaiDescription": "Gets the listeners for an event. Returns Function[]."
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false,
          "xaiDescription": "Gets the raw listeners for an event. Returns Function[]."
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false,
          "xaiDescription": "Gets the number of listeners for an event. Returns number."
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false,
          "xaiDescription": "Gets the event names. Returns (string | symbol)[]."
        }
      ],
      "extends": [
        "core.Request<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents an HTTP request. Extends core.Request<P, ResBody, ReqBody, ReqQuery, Locals>."
    },
    {
      "name": "RequestHandler",
      "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
      "properties": [],
      "extends": [
        "core.RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Function to handle HTTP requests. Extends core.RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>."
    },
    {
      "name": "RequestParamHandler",
      "type": "RequestParamHandler",
      "properties": [],
      "extends": [
        "core.RequestParamHandler"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Function to handle route parameters. Extends core.RequestParamHandler."
    },
    {
      "name": "Response",
      "type": "Response<ResBody, Locals>",
      "properties": [
        {
          "name": "status",
          "type": "(code: number) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets the HTTP status code. Returns Response object."
        },
        {
          "name": "sendStatus",
          "type": "(code: number) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sends HTTP response with status code. Returns Response object."
        },
        {
          "name": "links",
          "type": "(links: any) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets Link header field. Returns Response object."
        },
        {
          "name": "send",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false,
          "xaiDescription": "Sends HTTP response. Uses Send<ResBody, Response<ResBody, Locals>>."
        },
        {
          "name": "json",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false,
          "xaiDescription": "Sends JSON response. Uses Send<ResBody, Response<ResBody, Locals>>."
        },
        {
          "name": "jsonp",
          "type": "Send<ResBody, Response<ResBody, Locals>>",
          "optional": false,
          "xaiDescription": "Sends JSONP response. Uses Send<ResBody, Response<ResBody, Locals>>."
        },
        {
          "name": "sendFile",
          "type": "{ (path: string, fn?: Errback): void; (path: string, options: SendFileOptions, fn?: Errback): void; }",
          "optional": false,
          "xaiDescription": "Sends file as response. Uses SendFileOptions."
        },
        {
          "name": "download",
          "type": "{ (path: string, fn?: Errback): void; (path: string, filename: string, fn?: Errback): void; (path: string, filename: string, options: DownloadOptions, fn?: Errback): void; }",
          "optional": false,
          "xaiDescription": "Prompts download of file. Uses DownloadOptions."
        },
        {
          "name": "contentType",
          "type": "(type: string) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets Content-Type header. Returns Response object."
        },
        {
          "name": "type",
          "type": "(type: string) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets Content-Type header. Returns Response object."
        },
        {
          "name": "format",
          "type": "(obj: any) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sends response based on Accept header. Returns Response object."
        },
        {
          "name": "attachment",
          "type": "(filename?: string) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets Content-Disposition header. Returns Response object."
        },
        {
          "name": "set",
          "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
          "optional": false,
          "xaiDescription": "Sets response header. Returns Response object."
        },
        {
          "name": "header",
          "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
          "optional": false,
          "xaiDescription": "Sets response header. Returns Response object."
        },
        {
          "name": "headersSent",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if headers have been sent."
        },
        {
          "name": "get",
          "type": "(field: string) => string",
          "optional": false,
          "xaiDescription": "Gets response header value."
        },
        {
          "name": "clearCookie",
          "type": "(name: string, options?: CookieOptions) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Clears cookie. Uses CookieOptions. Returns Response object."
        },
        {
          "name": "cookie",
          "type": "{ (name: string, val: string, options: CookieOptions): Response<ResBody, Locals>; (name: string, val: any, options: CookieOptions): Response<...>; (name: string, val: any): Response<...>; }",
          "optional": false,
          "xaiDescription": "Sets cookie. Uses CookieOptions. Returns Response object."
        },
        {
          "name": "location",
          "type": "(url: string) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets Location header. Returns Response object."
        },
        {
          "name": "redirect",
          "type": "{ (url: string): void; (status: number, url: string): void; }",
          "optional": false,
          "xaiDescription": "Redirects to specified URL."
        },
        {
          "name": "render",
          "type": "{ (view: string, options?: object, callback?: (err: Error, html: string) => void): void; (view: string, callback?: (err: Error, html: string) => void): void; }",
          "optional": false,
          "xaiDescription": "Renders view template."
        },
        {
          "name": "locals",
          "type": "Locals & Locals",
          "optional": false,
          "xaiDescription": "Local variables for response."
        },
        {
          "name": "charset",
          "type": "string",
          "optional": false,
          "xaiDescription": "Sets character set for response."
        },
        {
          "name": "vary",
          "type": "(field: string) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Adds Vary header. Returns Response object."
        },
        {
          "name": "app",
          "type": "Application<Record<string, any>>",
          "optional": false,
          "xaiDescription": "Reference to the application."
        },
        {
          "name": "append",
          "type": "(field: string, value?: string | string[]) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Appends to response header. Returns Response object."
        },
        {
          "name": "req",
          "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
          "optional": false,
          "xaiDescription": "Reference to the request object."
        },
        {
          "name": "statusCode",
          "type": "number",
          "optional": false,
          "xaiDescription": "HTTP status code of response."
        },
        {
          "name": "statusMessage",
          "type": "string",
          "optional": false,
          "xaiDescription": "HTTP status message of response."
        },
        {
          "name": "strictContentLength",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Enables strict Content-Length header."
        },
        {
          "name": "assignSocket",
          "type": "(socket: Socket) => void",
          "optional": false,
          "xaiDescription": "Assigns socket to response."
        },
        {
          "name": "detachSocket",
          "type": "(socket: Socket) => void",
          "optional": false,
          "xaiDescription": "Detaches socket from response."
        },
        {
          "name": "writeContinue",
          "type": "(callback?: () => void) => void",
          "optional": false,
          "xaiDescription": "Sends 100 Continue response."
        },
        {
          "name": "writeEarlyHints",
          "type": "(hints: Record<string, string | string[]>, callback?: () => void) => void",
          "optional": false,
          "xaiDescription": "Sends early hints response."
        },
        {
          "name": "writeHead",
          "type": "{ (statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<ResBody, Locals>; (statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<...>; }",
          "optional": false,
          "xaiDescription": "Writes HTTP response headers. Returns Response object."
        },
        {
          "name": "writeProcessing",
          "type": "() => void",
          "optional": false,
          "xaiDescription": "Sends 102 Processing response."
        },
        {
          "name": "chunkedEncoding",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Enables chunked transfer encoding."
        },
        {
          "name": "shouldKeepAlive",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if connection should be kept alive."
        },
        {
          "name": "useChunkedEncodingByDefault",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Enables chunked encoding by default."
        },
        {
          "name": "sendDate",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Enables sending Date header."
        },
        {
          "name": "finished",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is finished."
        },
        {
          "name": "connection",
          "type": "Socket",
          "optional": false,
          "xaiDescription": "Socket connection for response."
        },
        {
          "name": "socket",
          "type": "Socket",
          "optional": false,
          "xaiDescription": "Socket for response."
        },
        {
          "name": "setTimeout",
          "type": "(msecs: number, callback?: () => void) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets timeout for response. Returns Response object."
        },
        {
          "name": "setHeader",
          "type": "(name: string, value: string | number | readonly string[]) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets response header. Returns Response object."
        },
        {
          "name": "setHeaders",
          "type": "(headers: Headers | Map<string, string | number | readonly string[]>) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets multiple response headers. Returns Response object."
        },
        {
          "name": "appendHeader",
          "type": "(name: string, value: string | readonly string[]) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Appends to response header. Returns Response object."
        },
        {
          "name": "getHeader",
          "type": "(name: string) => string | number | string[]",
          "optional": false,
          "xaiDescription": "Gets response header value."
        },
        {
          "name": "getHeaders",
          "type": "() => OutgoingHttpHeaders",
          "optional": false,
          "xaiDescription": "Gets all response headers."
        },
        {
          "name": "getHeaderNames",
          "type": "() => string[]",
          "optional": false,
          "xaiDescription": "Gets names of response headers."
        },
        {
          "name": "hasHeader",
          "type": "(name: string) => boolean",
          "optional": false,
          "xaiDescription": "Checks if response has header."
        },
        {
          "name": "removeHeader",
          "type": "(name: string) => void",
          "optional": false,
          "xaiDescription": "Removes response header."
        },
        {
          "name": "addTrailers",
          "type": "(headers: OutgoingHttpHeaders | readonly [string, string][]) => void",
          "optional": false,
          "xaiDescription": "Adds trailers to response."
        },
        {
          "name": "flushHeaders",
          "type": "() => void",
          "optional": false,
          "xaiDescription": "Flushes response headers."
        },
        {
          "name": "writable",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is writable."
        },
        {
          "name": "writableEnded",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response has ended."
        },
        {
          "name": "writableFinished",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is finished."
        },
        {
          "name": "writableHighWaterMark",
          "type": "number",
          "optional": false,
          "xaiDescription": "High water mark for response."
        },
        {
          "name": "writableLength",
          "type": "number",
          "optional": false,
          "xaiDescription": "Length of response buffer."
        },
        {
          "name": "writableObjectMode",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is in object mode."
        },
        {
          "name": "writableCorked",
          "type": "number",
          "optional": false,
          "xaiDescription": "Number of corked writes."
        },
        {
          "name": "destroyed",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is destroyed."
        },
        {
          "name": "closed",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response is closed."
        },
        {
          "name": "errored",
          "type": "Error",
          "optional": false,
          "xaiDescription": "Error associated with response."
        },
        {
          "name": "writableNeedDrain",
          "type": "boolean",
          "optional": false,
          "xaiDescription": "Indicates if response needs drain."
        },
        {
          "name": "_write",
          "type": "(chunk: any, encoding: BufferEncoding, callback: (error?: Error) => void) => void",
          "optional": false,
          "xaiDescription": "Writes chunk to response."
        },
        {
          "name": "_writev",
          "type": "(chunks: { chunk: any; encoding: BufferEncoding; }[], callback: (error?: Error) => void) => void",
          "optional": true,
          "xaiDescription": "Writes multiple chunks to response."
        },
        {
          "name": "_construct",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": true,
          "xaiDescription": "Constructs response."
        },
        {
          "name": "_destroy",
          "type": "(error: Error, callback: (error?: Error) => void) => void",
          "optional": false,
          "xaiDescription": "Destroys response."
        },
        {
          "name": "_final",
          "type": "(callback: (error?: Error) => void) => void",
          "optional": false,
          "xaiDescription": "Finalizes response."
        },
        {
          "name": "write",
          "type": "{ (chunk: any, callback?: (error: Error) => void): boolean; (chunk: any, encoding: BufferEncoding, callback?: (error: Error) => void): boolean; }",
          "optional": false,
          "xaiDescription": "Writes data to response."
        },
        {
          "name": "setDefaultEncoding",
          "type": "(encoding: BufferEncoding) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets default encoding for response. Returns Response object."
        },
        {
          "name": "end",
          "type": "{ (cb?: () => void): Response<ResBody, Locals>; (chunk: any, cb?: () => void): Response<ResBody, Locals>; (chunk: any, encoding: BufferEncoding, cb?: () => void): Response<...>; }",
          "optional": false,
          "xaiDescription": "Ends response. Returns Response object."
        },
        {
          "name": "cork",
          "type": "() => void",
          "optional": false,
          "xaiDescription": "Corks response."
        },
        {
          "name": "uncork",
          "type": "() => void",
          "optional": false,
          "xaiDescription": "Uncorks response."
        },
        {
          "name": "destroy",
          "type": "(error?: Error) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Destroys response. Returns Response object."
        },
        {
          "name": "addListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Adds event listener to response. Returns Response object."
        },
        {
          "name": "emit",
          "type": "{ (event: \"close\"): boolean; (event: \"drain\"): boolean; (event: \"error\", err: Error): boolean; (event: \"finish\"): boolean; (event: \"pipe\", src: Readable): boolean; (event: \"unpipe\", src: Readable): boolean; (event: string | symbol, ...args: any[]): boolean; }",
          "optional": false,
          "xaiDescription": "Emits event on response."
        },
        {
          "name": "on",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Adds event listener to response. Returns Response object."
        },
        {
          "name": "once",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Adds one-time event listener to response. Returns Response object."
        },
        {
          "name": "prependListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Prepends event listener to response. Returns Response object."
        },
        {
          "name": "prependOnceListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Prepends one-time event listener to response. Returns Response object."
        },
        {
          "name": "removeListener",
          "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
          "optional": false,
          "xaiDescription": "Removes event listener from response. Returns Response object."
        },
        {
          "name": "pipe",
          "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
          "optional": false,
          "xaiDescription": "Pipes response to writable stream."
        },
        {
          "name": "compose",
          "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
          "optional": false,
          "xaiDescription": "Composes response with readable stream."
        },
        {
          "name": "__@captureRejectionSymbol@69398",
          "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
          "optional": true,
          "xaiDescription": "Captures rejection symbol for response."
        },
        {
          "name": "off",
          "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Removes event listener from response. Returns Response object."
        },
        {
          "name": "removeAllListeners",
          "type": "(eventName?: string | symbol) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Removes all event listeners from response. Returns Response object."
        },
        {
          "name": "setMaxListeners",
          "type": "(n: number) => Response<ResBody, Locals>",
          "optional": false,
          "xaiDescription": "Sets maximum number of listeners for response. Returns Response object."
        },
        {
          "name": "getMaxListeners",
          "type": "() => number",
          "optional": false,
          "xaiDescription": "Gets maximum number of listeners for response."
        },
        {
          "name": "listeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false,
          "xaiDescription": "Gets listeners for event on response."
        },
        {
          "name": "rawListeners",
          "type": "<K>(eventName: string | symbol) => Function[]",
          "optional": false,
          "xaiDescription": "Gets raw listeners for event on response."
        },
        {
          "name": "listenerCount",
          "type": "<K>(eventName: string | symbol, listener?: Function) => number",
          "optional": false,
          "xaiDescription": "Gets count of listeners for event on response."
        },
        {
          "name": "eventNames",
          "type": "() => (string | symbol)[]",
          "optional": false,
          "xaiDescription": "Gets names of events on response."
        }
      ],
      "extends": [
        "core.Response<ResBody, Locals>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents an HTTP response. Extends core.Response<ResBody, Locals>."
    },
    {
      "name": "Router",
      "type": "Router",
      "properties": [
        {
          "name": "param",
          "type": "(name: string, handler: RequestParamHandler) => Router",
          "optional": false,
          "xaiDescription": "Adds parameter middleware to router. Returns Router object."
        },
        {
          "name": "all",
          "type": "IRouterMatcher<Router, \"all\">",
          "optional": false,
          "xaiDescription": "Matches all HTTP methods. Uses IRouterMatcher<Router, \"all\">."
        },
        {
          "name": "get",
          "type": "IRouterMatcher<Router, \"get\">",
          "optional": false,
          "xaiDescription": "Matches GET requests. Uses IRouterMatcher<Router, \"get\">."
        },
        {
          "name": "post",
          "type": "IRouterMatcher<Router, \"post\">",
          "optional": false,
          "xaiDescription": "Matches POST requests. Uses IRouterMatcher<Router, \"post\">."
        },
        {
          "name": "put",
          "type": "IRouterMatcher<Router, \"put\">",
          "optional": false,
          "xaiDescription": "Matches PUT requests. Uses IRouterMatcher<Router, \"put\">."
        },
        {
          "name": "delete",
          "type": "IRouterMatcher<Router, \"delete\">",
          "optional": false,
          "xaiDescription": "Matches DELETE requests. Uses IRouterMatcher<Router, \"delete\">."
        },
        {
          "name": "patch",
          "type": "IRouterMatcher<Router, \"patch\">",
          "optional": false,
          "xaiDescription": "Matches PATCH requests. Uses IRouterMatcher<Router, \"patch\">."
        },
        {
          "name": "options",
          "type": "IRouterMatcher<Router, \"options\">",
          "optional": false,
          "xaiDescription": "Matches OPTIONS requests. Uses IRouterMatcher<Router, \"options\">."
        },
        {
          "name": "head",
          "type": "IRouterMatcher<Router, \"head\">",
          "optional": false,
          "xaiDescription": "Matches HEAD requests. Uses IRouterMatcher<Router, \"head\">."
        },
        {
          "name": "checkout",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches CHECKOUT requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "connect",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches CONNECT requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "copy",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches COPY requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "lock",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches LOCK requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "merge",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches MERGE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "mkactivity",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches MKACTIVITY requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "mkcol",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches MKCOL requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "move",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches MOVE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "m-search",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches M-SEARCH requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "notify",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches NOTIFY requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "propfind",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches PROPFIND requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "proppatch",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches PROPPATCH requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "purge",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches PURGE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "report",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches REPORT requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "search",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches SEARCH requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "subscribe",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches SUBSCRIBE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "trace",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches TRACE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "unlock",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches UNLOCK requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "unsubscribe",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches UNSUBSCRIBE requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "link",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches LINK requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "unlink",
          "type": "IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Matches UNLINK requests. Uses IRouterMatcher<Router, any>."
        },
        {
          "name": "use",
          "type": "IRouterHandler<Router, string> & IRouterMatcher<Router, any>",
          "optional": false,
          "xaiDescription": "Adds middleware or sub-router to router. Uses IRouterHandler<Router, string> & IRouterMatcher<Router, any>."
        },
        {
          "name": "route",
          "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
          "optional": false,
          "xaiDescription": "Creates route for specified path. Uses IRoute<T>."
        },
        {
          "name": "stack",
          "type": "ILayer[]",
          "optional": false,
          "xaiDescription": "Array of middleware layers. Uses ILayer[]."
        }
      ],
      "extends": [
        "core.Router"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Handles routing for HTTP requests. Extends core.Router."
    },
    {
      "name": "Send",
      "type": "Send",
      "properties": [],
      "extends": [
        "core.Send"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Utility for sending HTTP responses. Extends core.Send."
    }
  ],
  "classes": [],
  "constants": [],
  "namespaces": [
    {
      "name": "express",
      "contents": {
        "functions": [
          {
            "name": "Router",
            "parameters": [
              {
                "name": "options",
                "type": "RouterOptions",
                "optional": true
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Creates a new router object. Uses RouterOptions."
          },
          {
            "name": "json",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsJson",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null,
            "xaiDescription": "Middleware for parsing JSON. Uses OptionsJson."
          },
          {
            "name": "raw",
            "parameters": [
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null,
            "xaiDescription": "Middleware for parsing raw bodies. Uses Options."
          },
          {
            "name": "text",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsText",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null,
            "xaiDescription": "Middleware for parsing text bodies. Uses OptionsText."
          },
          {
            "name": "application",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null,
            "xaiDescription": "Handles application requests. Uses Request and Response types."
          },
          {
            "name": "init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "get",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null,
            "xaiDescription": "Retrieves the value of a setting."
          },
          {
            "name": "param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Adds custom logic for route parameters. Uses RequestParamHandler."
          },
          {
            "name": "path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null,
            "xaiDescription": "Handles routing for requests. Uses Request, Response, and NextFunction."
          },
          {
            "name": "use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Mounts middleware functions. Uses RequestHandler."
          },
          {
            "name": "on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "__@captureRejectionSymbol@69398",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Handles promise rejections. Uses Error type."
          },
          {
            "name": "addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\njs\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\njs\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles POST requests. Uses Route and RequestHandler."
          },
          {
            "name": "put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles PUT requests. Uses Route and RequestHandler."
          },
          {
            "name": "delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles DELETE requests. Uses Route and RequestHandler."
          },
          {
            "name": "patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles PATCH requests. Uses Route and RequestHandler."
          },
          {
            "name": "options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles OPTIONS requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles HEAD requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles CHECKOUT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles CONNECT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles COPY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles LOCK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles MERGE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles MKACTIVITY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles MKCOL requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles MOVE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles M-SEARCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles NOTIFY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles PROPFIND requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles PROPPATCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles PURGE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles REPORT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles SEARCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles SUBSCRIBE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles TRACE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles UNLOCK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles UNSUBSCRIBE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "link",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles LINK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Handles UNLINK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null,
            "xaiDescription": "Creates a new route with the specified prefix. Returns IRoute<T>."
          },
          {
            "name": "application.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "application.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "application.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "application.set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "application.get",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null,
            "xaiDescription": "Retrieves the value of the specified setting."
          },
          {
            "name": "application.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": null,
            "xaiDescription": "Defines a parameter handler for the specified parameter name. Uses RequestParamHandler."
          },
          {
            "name": "application.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "application.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "application.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "application.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "application.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "application.render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "application.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "application.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null,
            "xaiDescription": "Handles routing for the application. Uses Request, Response, and NextFunction."
          },
          {
            "name": "application.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false
            }
          },
          {
            "name": "application.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles POST requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles PUT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles DELETE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles PATCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles OPTIONS requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles HEAD requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles CHECKOUT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles CONNECT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles COPY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles LOCK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles MERGE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles MKACTIVITY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles MKCOL requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles MOVE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles M-SEARCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles NOTIFY requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles PROPFIND requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles PROPPATCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles PURGE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles REPORT requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles SEARCH requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles SUBSCRIBE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles TRACE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles UNLOCK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles UNSUBSCRIBE requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.link",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles LINK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Handles UNLINK requests for the specified route. Uses RequestHandler."
          },
          {
            "name": "application.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Router",
            "jsdoc": null,
            "xaiDescription": "Adds middleware to the application. Uses RequestHandler."
          },
          {
            "name": "application.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": null,
            "xaiDescription": "Creates a new route with the specified prefix. Returns IRoute<T>."
          },
          {
            "name": "application.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "application.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": null,
            "xaiDescription": "Returns a string representation of the application."
          },
          {
            "name": "application.concat",
            "parameters": [
              {
                "name": "strings",
                "type": "string[]",
                "optional": false
              }
            ],
            "returnType": "string | string[]",
            "jsdoc": null,
            "xaiDescription": "Concatenates the given strings to the application."
          },
          {
            "name": "application.indexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": null,
            "xaiDescription": "Returns the index of the first occurrence of the specified search string."
          },
          {
            "name": "application.lastIndexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": null,
            "xaiDescription": "Returns the index of the last occurrence of the specified search string."
          },
          {
            "name": "application.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string | string[]",
            "jsdoc": null,
            "xaiDescription": "Extracts a section of the application string."
          },
          {
            "name": "application.valueOf",
            "parameters": [],
            "returnType": "string | Object",
            "jsdoc": null,
            "xaiDescription": "Returns the primitive value of the application."
          },
          {
            "name": "application.includes",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": null,
            "xaiDescription": "Determines whether the application string includes the specified search string."
          },
          {
            "name": "application.__@iterator@69548",
            "parameters": [],
            "returnType": "StringIterator<string>",
            "jsdoc": null,
            "xaiDescription": "Returns an iterator for the application string."
          },
          {
            "name": "application.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": null,
            "xaiDescription": "Returns the character at the specified index in the application string."
          },
          {
            "name": "application.toLocaleString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": null,
            "xaiDescription": "Returns a string representation of the application using the locale's conventions."
          },
          {
            "name": "application.__@captureRejectionSymbol@69398",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Handles error rejection for events. Uses Error, AnyRest."
          },
          {
            "name": "application.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\njs\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\njs\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "application.pop",
            "parameters": [],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "application.push",
            "parameters": [
              {
                "name": "items",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Appends new elements to the end of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "New elements to add to the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.join",
            "parameters": [
              {
                "name": "separator",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reverse",
            "parameters": [],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "deprecated": false
            }
          },
          {
            "name": "application.shift",
            "parameters": [],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "application.sort",
            "parameters": [
              {
                "name": "compareFn",
                "type": "(a: ILayer, b: ILayer) => number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "params": [
                {
                  "name": "compareFn",
                  "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\nts\n[11,2,22,1].sort((a, b) => a - b)\n"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.splice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "deleteCount",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based location in the array from which to start removing elements."
                },
                {
                  "name": "deleteCount",
                  "description": "The number of elements to remove."
                }
              ],
              "returns": "An array containing the elements that were deleted.",
              "deprecated": false
            }
          },
          {
            "name": "application.unshift",
            "parameters": [
              {
                "name": "items",
                "type": "ILayer[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "Elements to insert at the start of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.every",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether all the members of an array satisfy the specified test.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The every method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value false, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.some",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether the specified callback function returns true for any element of an array.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The some method calls\nthe predicate function for each element in the array until the predicate returns a value\nwhich is coercible to the Boolean value true, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function.\nIf thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.forEach",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: ILayer, index: number, array: ILayer[]) => void",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Performs the specified action for each element in an array.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.map",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: ILayer, index: number, array: ILayer[]) => U",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.filter",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, array: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S[]",
            "jsdoc": {
              "description": "Returns the elements of an array that meet the condition specified in a callback function.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reduce",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
                "optional": false
              }
            ],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.reduceRight",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: ILayer, currentValue: ILayer, currentIndex: number, array: ILayer[]) => ILayer",
                "optional": false
              }
            ],
            "returnType": "ILayer",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.find",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, obj: ILayer[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S",
            "jsdoc": {
              "description": "Returns the value of the first element in the array where predicate is true, and undefined\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found, find\nimmediately returns that element value. Otherwise, find returns undefined."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.findIndex",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: ILayer, index: number, obj: ILayer[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first element in the array where predicate is true, and -1\notherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending\norder, until it finds one where predicate returns true. If such an element is found,\nfindIndex immediately returns that element index. Otherwise, findIndex returns -1."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of\npredicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.fill",
            "parameters": [
              {
                "name": "value",
                "type": "ILayer",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
              "params": [
                {
                  "name": "value",
                  "description": "value to fill array section with"
                },
                {
                  "name": "start",
                  "description": "index to start filling the array at. If start is negative, it is treated as\nlength+start where length is the length of the array."
                },
                {
                  "name": "end",
                  "description": "index to stop filling the array at. If end is negative, it is treated as\nlength+end."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.copyWithin",
            "parameters": [
              {
                "name": "target",
                "type": "number",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "ILayer[]",
            "jsdoc": {
              "description": "Returns the this object after copying a section of the array identified by start and end\nto the same array starting at position target",
              "params": [
                {
                  "name": "target",
                  "description": "If target is negative, it is treated as length+target where length is the\nlength of the array."
                },
                {
                  "name": "start",
                  "description": "If start is negative, it is treated as length+start. If end is negative, it\nis treated as length+end."
                },
                {
                  "name": "end",
                  "description": "If not specified, length of the this object is used as its default value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.entries",
            "parameters": [],
            "returnType": "ArrayIterator<[number, ILayer]>",
            "jsdoc": {
              "description": "Returns an iterable of key, value pairs for every entry in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.keys",
            "parameters": [],
            "returnType": "ArrayIterator<number>",
            "jsdoc": {
              "description": "Returns an iterable of keys in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.values",
            "parameters": [],
            "returnType": "ArrayIterator<ILayer>",
            "jsdoc": {
              "description": "Returns an iterable of values in the array",
              "deprecated": false
            }
          },
          {
            "name": "application.flatMap",
            "parameters": [
              {
                "name": "callback",
                "type": "(this: This, value: ILayer, index: number, array: ILayer[]) => U | readonly U[]",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "This",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array. Then, flattens the result into\na new array.\nThis is identical to a map followed by flat with depth 1.",
              "params": [
                {
                  "name": "callback",
                  "description": "A function that accepts up to three arguments. The flatMap method calls the\ncallback function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callback function. If\nthisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "application.flat",
            "parameters": [
              {
                "name": "depth",
                "type": "D",
                "optional": true
              }
            ],
            "returnType": "FlatArray<A, D>[]",
            "jsdoc": {
              "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the\nspecified depth.",
              "params": [
                {
                  "name": "depth",
                  "description": "The maximum recursion depth"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "header",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "xaiDescription": "Retrieves the 'set-cookie' header values."
            }
          },
          {
            "name": "accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
              "deprecated": false
            }
          },
          {
            "name": "acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\"\nheader field, and it contains the give mime `type`.\n\nExamples:\n\n     // With Content-Type: text/html; charset=utf-8\n     req.is('html');\n     req.is('text/html');\n     req.is('text/*');\n     // => true\n\n     // When Content-Type is application/json\n     req.is('json');\n     req.is('application/json');\n     req.is('application/*');\n     // => true\n\n     req.is('html');\n     // => false",
              "deprecated": false
            }
          },
          {
            "name": "app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "xaiDescription": "Handles request and response objects."
            }
          },
          {
            "name": "next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Passes control to the next matching route."
            }
          },
          {
            "name": "setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed\nas an argument to any listeners on the event.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "_construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Initializes the stream, calls callback on completion."
            }
          },
          {
            "name": "_read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Reads data from the stream, size specifies amount."
            }
          },
          {
            "name": "read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\njs\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\njs\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n",
              "params": [
                {
                  "name": "encoding",
                  "description": "The encoding to use."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "pause",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "resume",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\njs\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "unshift",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\njs\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
                },
                {
                  "name": "encoding",
                  "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "push",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "xaiDescription": "Adds a chunk to the stream. Returns if successful."
            }
          },
          {
            "name": "iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "map",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. Async or not."
                }
              ],
              "returns": "a stream mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "filter",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to filter chunks from the stream. Async or not."
                }
              ],
              "returns": "a stream filtered with the predicate *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "forEach",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise for when the stream has finished.",
              "deprecated": false
            }
          },
          {
            "name": "toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false
            }
          },
          {
            "name": "some",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "find",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
              "deprecated": false
            }
          },
          {
            "name": "every",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
              "deprecated": false
            }
          },
          {
            "name": "flatMap",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
                }
              ],
              "returns": "a stream flat-mapped with the function *fn*.",
              "deprecated": false
            }
          },
          {
            "name": "drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false
            }
          },
          {
            "name": "take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false
            }
          },
          {
            "name": "asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false
            }
          },
          {
            "name": "reduce",
            "parameters": [
              {
                "name": "fn",
                "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
                "optional": false
              },
              {
                "name": "initial",
                "type": "undefined",
                "optional": true
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
              "params": [
                {
                  "name": "fn",
                  "description": "a reducer function to call over every chunk in the stream. Async or not."
                },
                {
                  "name": "initial",
                  "description": "the initial value to use in the reduction."
                }
              ],
              "returns": "a promise for the final value of the reduction.",
              "deprecated": false
            }
          },
          {
            "name": "_destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Destroys the stream, calls callback with error."
            }
          },
          {
            "name": "__@asyncIterator@70027",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "xaiDescription": "Returns an async iterator for the stream."
            }
          },
          {
            "name": "__@asyncDispose@70029",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "xaiDescription": "Pipes the stream to a destination. Returns destination."
            }
          },
          {
            "name": "compose",
            "parameters": [
              {
                "name": "stream",
                "type": "T | ComposeFnParam | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "xaiDescription": "Composes streams or iterables. Returns composed stream."
            }
          },
          {
            "name": "request.get",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Return request header.\n\nThe `Referrer` header field is special-cased,\nboth `Referrer` and `Referer` are interchangeable.\n\nExamples:\n\n    req.get('Content-Type');\n    // => \"text/plain\"\n\n    req.get('content-type');\n    // => \"text/plain\"\n\n    req.get('Something');\n    // => undefined\n\nAliased as `req.header()`.",
              "deprecated": false
            }
          },
          {
            "name": "request.header",
            "parameters": [
              {
                "name": "name",
                "type": "\"set-cookie\"",
                "optional": false
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "xaiDescription": "Alias for request.get. Returns header value."
            }
          },
          {
            "name": "request.accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning\nthe best match when true, otherwise `undefined`, in which\ncase you should respond with 406 \"Not Acceptable\".\n\nThe `type` value may be a single mime type string\nsuch as \"application/json\", the extension name\nsuch as \"json\", a comma-delimted list such as \"json, html, text/plain\",\nor an array `[\"json\", \"html\", \"text/plain\"]`. When a list\nor array is given the _best_ match, if any is returned.\n\nExamples:\n\n    // Accept: text/html\n    req.accepts('html');\n    // => \"html\"\n\n    // Accept: text/*, application/json\n    req.accepts('html');\n    // => \"html\"\n    req.accepts('text/html');\n    // => \"text/html\"\n    req.accepts('json, text');\n    // => \"json\"\n    req.accepts('application/json');\n    // => \"application/json\"\n\n    // Accept: text/*, application/json\n    req.accepts('image/png');\n    req.accepts('png');\n    // => false\n\n    // Accept: text/*;q=.5, application/json\n    req.accepts(['html', 'json']);\n    req.accepts('html, json');\n    // => \"json\"",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets,\nbased on the request's Accept-Charset HTTP header field.\nIf none of the specified charsets is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings,\nbased on the request's Accept-Encoding HTTP header field.\nIf none of the specified encodings is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages,\nbased on the request's Accept-Language HTTP header field.\nIf none of the specified languages is accepted, returns false.\n\nFor more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "request.range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`.\n\nUnspecified ranges such as \"0-\" require knowledge of your resource length. In\nthe case of a byte range this is of course the total number of bytes.\nIf the Range header field is not given `undefined` is returned.\nIf the Range header field is given, return value is a result of range-parser.\nSee more ./types/range-parser/index.d.ts\n\nNOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\nshould respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "request.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of an array.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.",
              "deprecated": false
            }
          },
          {
            "name": "request.pop",
            "parameters": [],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Removes the last element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "request.push",
            "parameters": [
              {
                "name": "items",
                "type": "MediaType[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Appends new elements to the end of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "New elements to add to the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.concat",
            "parameters": [
              {
                "name": "items",
                "type": "ConcatArray<MediaType>[]",
                "optional": false
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Combines two or more arrays.\nThis method returns a new array without modifying any existing arrays.",
              "params": [
                {
                  "name": "items",
                  "description": "Additional arrays and/or items to add to the end of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.join",
            "parameters": [
              {
                "name": "separator",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Adds all the elements of an array into a string, separated by the specified separator string.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reverse",
            "parameters": [],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Reverses the elements in an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "deprecated": false
            }
          },
          {
            "name": "request.shift",
            "parameters": [],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Removes the first element from an array and returns it.\nIf the array is empty, undefined is returned and the array is not modified.",
              "deprecated": false
            }
          },
          {
            "name": "request.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Returns a copy of a section of an array.\nFor both start and end, a negative index can be used to indicate an offset from the end of the array.\nFor example, -2 refers to the second to last element of the array.",
              "params": [
                {
                  "name": "start",
                  "description": "The beginning index of the specified portion of the array.\nIf start is undefined, then the slice begins at index 0."
                },
                {
                  "name": "end",
                  "description": "The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.\nIf end is undefined, then the slice extends to the end of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.sort",
            "parameters": [
              {
                "name": "compareFn",
                "type": "(a: MediaType, b: MediaType) => number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Sorts an array in place.\nThis method mutates the array and returns a reference to the same array.",
              "params": [
                {
                  "name": "compareFn",
                  "description": "Function used to determine the order of the elements. It is expected to return\na negative value if the first argument is less than the second argument, zero if they're equal, and a positive\nvalue otherwise. If omitted, the elements are sorted in ascending, UTF-16 code unit order.\nts\n[11,2,22,1].sort((a, b) => a - b)\n"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.splice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "deleteCount",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based location in the array from which to start removing elements."
                },
                {
                  "name": "deleteCount",
                  "description": "The number of elements to remove."
                }
              ],
              "returns": "An array containing the elements that were deleted.",
              "deprecated": false
            }
          },
          {
            "name": "request.unshift",
            "parameters": [
              {
                "name": "items",
                "type": "MediaType[]",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Inserts new elements at the start of an array, and returns the new length of the array.",
              "params": [
                {
                  "name": "items",
                  "description": "Elements to insert at the start of the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.indexOf",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first occurrence of a value in an array, or -1 if it is not present.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The value to locate in the array."
                },
                {
                  "name": "fromIndex",
                  "description": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.lastIndexOf",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The value to locate in the array."
                },
                {
                  "name": "fromIndex",
                  "description": "The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.every",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether all the members of an array satisfy the specified test.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The every method calls the predicate function for each element in the array until the predicate returns a value which is coercible to the Boolean value false, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.some",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether the specified callback function returns true for any element of an array.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The some method calls the predicate function for each element in the array until the predicate returns a value which is coercible to the Boolean value true, or until the end of the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.forEach",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: MediaType, index: number, array: MediaType[]) => void",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Performs the specified action for each element in an array.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.map",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(value: MediaType, index: number, array: MediaType[]) => U",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array, and returns an array that contains the results.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.filter",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, array: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S[]",
            "jsdoc": {
              "description": "Returns the elements of an array that meet the condition specified in a callback function.",
              "params": [
                {
                  "name": "predicate",
                  "description": "A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reduce",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.reduceRight",
            "parameters": [
              {
                "name": "callbackfn",
                "type": "(previousValue: MediaType, currentValue: MediaType, currentIndex: number, array: MediaType[]) => MediaType",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": {
              "description": "Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.",
              "params": [
                {
                  "name": "callbackfn",
                  "description": "A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array."
                },
                {
                  "name": "initialValue",
                  "description": "If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.find",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, obj: MediaType[]) => value is S",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "S",
            "jsdoc": {
              "description": "Returns the value of the first element in the array where predicate is true, and undefined otherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending order, until it finds one where predicate returns true. If such an element is found, find immediately returns that element value. Otherwise, find returns undefined."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of predicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.findIndex",
            "parameters": [
              {
                "name": "predicate",
                "type": "(value: MediaType, index: number, obj: MediaType[]) => unknown",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the index of the first element in the array where predicate is true, and -1 otherwise.",
              "params": [
                {
                  "name": "predicate",
                  "description": "find calls predicate once for each element of the array, in ascending order, until it finds one where predicate returns true. If such an element is found, findIndex immediately returns that element index. Otherwise, findIndex returns -1."
                },
                {
                  "name": "thisArg",
                  "description": "If provided, it will be used as the this value for each invocation of predicate. If it is not provided, undefined is used instead."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.fill",
            "parameters": [
              {
                "name": "value",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Changes all array elements from `start` to `end` index to a static `value` and returns the modified array",
              "params": [
                {
                  "name": "value",
                  "description": "value to fill array section with"
                },
                {
                  "name": "start",
                  "description": "index to start filling the array at. If start is negative, it is treated as length+start where length is the length of the array."
                },
                {
                  "name": "end",
                  "description": "index to stop filling the array at. If end is negative, it is treated as length+end."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.copyWithin",
            "parameters": [
              {
                "name": "target",
                "type": "number",
                "optional": false
              },
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "MediaType[]",
            "jsdoc": {
              "description": "Returns the this object after copying a section of the array identified by start and end to the same array starting at position target",
              "params": [
                {
                  "name": "target",
                  "description": "If target is negative, it is treated as length+target where length is the length of the array."
                },
                {
                  "name": "start",
                  "description": "If start is negative, it is treated as length+start. If end is negative, it is treated as length+end."
                },
                {
                  "name": "end",
                  "description": "If not specified, length of the this object is used as its default value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.entries",
            "parameters": [],
            "returnType": "ArrayIterator<[number, MediaType]>",
            "jsdoc": {
              "description": "Returns an iterable of key, value pairs for every entry in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.keys",
            "parameters": [],
            "returnType": "ArrayIterator<number>",
            "jsdoc": {
              "description": "Returns an iterable of keys in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.values",
            "parameters": [],
            "returnType": "ArrayIterator<MediaType>",
            "jsdoc": {
              "description": "Returns an iterable of values in the array",
              "deprecated": false
            }
          },
          {
            "name": "request.includes",
            "parameters": [
              {
                "name": "searchElement",
                "type": "MediaType",
                "optional": false
              },
              {
                "name": "fromIndex",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Determines whether an array includes a certain element, returning true or false as appropriate.",
              "params": [
                {
                  "name": "searchElement",
                  "description": "The element to search for."
                },
                {
                  "name": "fromIndex",
                  "description": "The position in this array at which to begin searching for searchElement."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.flatMap",
            "parameters": [
              {
                "name": "callback",
                "type": "(this: This, value: MediaType, index: number, array: MediaType[]) => U | readonly U[]",
                "optional": false
              },
              {
                "name": "thisArg",
                "type": "This",
                "optional": true
              }
            ],
            "returnType": "U[]",
            "jsdoc": {
              "description": "Calls a defined callback function on each element of an array. Then, flattens the result into a new array. This is identical to a map followed by flat with depth 1.",
              "params": [
                {
                  "name": "callback",
                  "description": "A function that accepts up to three arguments. The flatMap method calls the callback function one time for each element in the array."
                },
                {
                  "name": "thisArg",
                  "description": "An object to which the this keyword can refer in the callback function. If thisArg is omitted, undefined is used as the this value."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.flat",
            "parameters": [
              {
                "name": "depth",
                "type": "D",
                "optional": true
              }
            ],
            "returnType": "FlatArray<A, D>[]",
            "jsdoc": {
              "description": "Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.",
              "params": [
                {
                  "name": "depth",
                  "description": "The maximum recursion depth"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.__@iterator@69548",
            "parameters": [],
            "returnType": "ArrayIterator<MediaType>",
            "jsdoc": {
              "description": "Iterator",
              "deprecated": false
            }
          },
          {
            "name": "request.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "MediaType",
            "jsdoc": {
              "xaiDescription": "Returns the element at the specified index in the array.",
              "deprecated": false
            }
          },
          {
            "name": "request.is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\" header field, and it contains the give mime `type`.",
              "deprecated": false
            }
          },
          {
            "name": "request.charAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the character at the specified index.",
              "params": [
                {
                  "name": "pos",
                  "description": "The zero-based index of the desired character."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.charCodeAt",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the Unicode value of the character at the specified location.",
              "params": [
                {
                  "name": "index",
                  "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.localeCompare",
            "parameters": [
              {
                "name": "that",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Determines whether two strings are equivalent in the current locale.",
              "params": [
                {
                  "name": "that",
                  "description": "String to compare to target string"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.match",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpMatchArray",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.replace",
            "parameters": [
              {
                "name": "searchValue",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "replaceValue",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Replaces text in a string, using a regular expression or search string.",
              "params": [
                {
                  "name": "searchValue",
                  "description": "A string or regular expression to search for."
                },
                {
                  "name": "replaceValue",
                  "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.search",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Finds the first substring match in a regular expression search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "The regular expression pattern and applicable flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.split",
            "parameters": [
              {
                "name": "separator",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "limit",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Split a string into substrings using the specified separator and return them as an array.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
                },
                {
                  "name": "limit",
                  "description": "A value used to limit the number of elements returned in the array."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.substring",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the substring at the specified location within a String object.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based index number indicating the beginning of the substring."
                },
                {
                  "name": "end",
                  "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end. If end is omitted, the characters from start through the end of the original string are returned."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.toLowerCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to lowercase.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleLowerCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "request.toUpperCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to uppercase.",
              "deprecated": false
            }
          },
          {
            "name": "request.toLocaleUpperCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
              "deprecated": false
            }
          },
          {
            "name": "request.trim",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading and trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.substr",
            "parameters": [
              {
                "name": "from",
                "type": "number",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Gets a substring beginning at the specified location and having the specified length.",
              "params": [
                {
                  "name": "from",
                  "description": "The starting position of the desired substring. The index of the first character in the string is zero."
                },
                {
                  "name": "length",
                  "description": "The number of characters to include in the returned substring."
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "request.valueOf",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the primitive value of the specified object.",
              "deprecated": false
            }
          },
          {
            "name": "request.codePointAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point value of the UTF-16 encoded code point starting at the string element at position pos in the String resulting from converting this object to a String. If there is no element at that position, the result is undefined. If a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
              "deprecated": false
            }
          },
          {
            "name": "request.endsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "endPosition",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at endPosition – length(this). Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "request.normalize",
            "parameters": [
              {
                "name": "form",
                "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the String value result of normalizing the string into the normalization form named by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
              "params": [
                {
                  "name": "form",
                  "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default is \"NFC\""
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.repeat",
            "parameters": [
              {
                "name": "count",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a String value that is made from count copies appended together. If count is 0, the empty string is returned.",
              "params": [
                {
                  "name": "count",
                  "description": "number of copies to append"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.startsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at position. Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "request.anchor",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
              "params": [
                {
                  "name": "name"
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "request.big",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<big>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.blink",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<blink>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.bold",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<b>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fixed",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<tt>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fontcolor",
            "parameters": [
              {
                "name": "color",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the color attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.fontsize",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the size attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.italics",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<i>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.link",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML element and sets the href attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.small",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<small>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.strike",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<strike>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.sub",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sub>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.sup",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sup>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.padStart",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.padEnd",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.trimEnd",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.trimStart",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "request.trimLeft",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.trimRight",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "request.matchAll",
            "parameters": [
              {
                "name": "regexp",
                "type": "RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpStringIterator<RegExpExecArray>",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": null,
            "xaiDescription": "Handles request and response objects. Uses Request and Response types."
          },
          {
            "name": "request.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "request.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "request.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "request.set",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Assign `setting` to `val`, or return `setting`'s value.\n\n   app.set('foo', 'bar');\n   app.get('foo');\n   // => \"bar\"\n   app.set('foo', ['bar', 'baz']);\n   app.get('foo');\n   // => [\"bar\", \"baz\"]\n\nMounted servers inherit their parent server's settings.",
              "deprecated": false
            }
          },
          {
            "name": "request.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null,
            "xaiDescription": "Handles request parameters. Uses RequestParamHandler type."
          },
          {
            "name": "request.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "request.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "request.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "request.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "request.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "request.render",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render the given view `name` name with `options`\nand a callback accepting an error and the\nrendered template string.\n\nExample:\n\n   app.render('email', { name: 'Tobi' }, function(err, html){\n     // ...\n   })",
              "deprecated": false
            }
          },
          {
            "name": "request.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "request.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": null,
            "xaiDescription": "Handles routing. Uses Request, Response, and NextFunction types."
          },
          {
            "name": "request.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": null,
            "xaiDescription": "Adds middleware to the application. Uses RequestHandler type."
          },
          {
            "name": "request.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "request.__@captureRejectionSymbol@69398",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Handles error rejection. Uses Error type."
          },
          {
            "name": "request.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`.\nIf `listener` is provided, it will return how many times the listener is found\nin the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`\nand `listener` will result in the `listener` being added, and called, multiple times.\n\njs\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\njs\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "request.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\njs\nimport { EventEmitter } from 'node:events';\n\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "request.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.",
              "deprecated": false,
              "xaiDescription": "Applies route to all HTTP methods. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles POST requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PUT requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles DELETE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PATCH requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles OPTIONS requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles HEAD requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles CHECKOUT requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles CONNECT requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles COPY requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles LOCK requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MERGE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MKACTIVITY requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MKCOL requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MOVE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles M-SEARCH requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles NOTIFY requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PROPFIND requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PROPPATCH requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PURGE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles REPORT requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles SUBSCRIBE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles TRACE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNLOCK requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNSUBSCRIBE requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNLINK requests. Uses Route and RequestHandler types."
            }
          },
          {
            "name": "request.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": {
              "xaiDescription": "Creates a new route with the given prefix. Uses IRoute<T> type."
            }
          },
          {
            "name": "request.status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false,
              "xaiDescription": "Sets the HTTP status code. Uses Response type."
            }
          },
          {
            "name": "request.sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Sets status code and sends it as response body. Uses Response type."
            }
          },
          {
            "name": "request.links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false,
              "xaiDescription": "Sets Link header with given links. Uses Response type."
            }
          },
          {
            "name": "request.send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false,
              "xaiDescription": "Sends a response with the given body. Uses Response type."
            }
          },
          {
            "name": "request.json",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
              "deprecated": false,
              "xaiDescription": "Sends a JSON response with the given body. Uses Response type."
            }
          },
          {
            "name": "request.jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false,
              "xaiDescription": "Sends a JSONP response with the given body. Uses Response type."
            }
          },
          {
            "name": "request.sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Transfers file at given path. Uses Errback type."
            }
          },
          {
            "name": "request.download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false,
              "xaiDescription": "Transfers file as attachment. Uses Errback type."
            }
          },
          {
            "name": "request.contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false,
              "xaiDescription": "Sets Content-Type header. Uses Response type."
            }
          },
          {
            "name": "request.type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false,
              "xaiDescription": "Sets Content-Type header. Uses Response type."
            }
          },
          {
            "name": "request.format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false,
              "xaiDescription": "Responds based on Accept header. Uses Response type."
            }
          },
          {
            "name": "request.attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false,
              "xaiDescription": "Sets Content-Disposition header to attachment. Uses Response type."
            }
          },
          {
            "name": "request.clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false,
              "xaiDescription": "Clears a cookie. Uses Response and CookieOptions types."
            }
          },
          {
            "name": "request.cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false,
              "xaiDescription": "Sets a cookie. Uses Response and CookieOptions types."
            }
          },
          {
            "name": "request.location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false,
              "xaiDescription": "Sets the Location header. Uses Response type."
            }
          },
          {
            "name": "request.redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false,
              "xaiDescription": "Redirects to the given URL."
            }
          },
          {
            "name": "request.vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false,
              "xaiDescription": "Adds field to Vary header. Uses Response type."
            }
          },
          {
            "name": "request.append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Appends value to response header. Uses Response type."
            }
          },
          {
            "name": "request.assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Assigns a socket to the request. Uses Socket type."
            }
          },
          {
            "name": "request.detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Detaches a socket from the request. Uses Socket type."
            }
          },
          {
            "name": "request.writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Sends 100 Continue message to client."
            }
          },
          {
            "name": "request.writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sends HTTP/1.1 103 Early Hints message with Link header for preloading resources."
            }
          },
          {
            "name": "request.writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Sends response header with status code and optional headers. Uses OutgoingHttpHeaders."
            }
          },
          {
            "name": "request.writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Sends HTTP/1.1 102 Processing message to indicate request body should be sent."
            }
          },
          {
            "name": "request.setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.",
              "params": [
                {
                  "name": "callback",
                  "description": "Optional function to be called when a timeout occurs. Same as binding to the `timeout` event."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sets timeout for socket associated with message. Uses socket.setTimeout()."
            }
          },
          {
            "name": "request.setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sets a single header value, replacing existing value if present."
            }
          },
          {
            "name": "request.setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sets multiple header values for implicit headers. Uses Headers or Map."
            }
          },
          {
            "name": "request.appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Appends a single header value to the header object."
            }
          },
          {
            "name": "request.getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Gets the value of the HTTP header with the given name."
            }
          },
          {
            "name": "request.getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Returns a shallow copy of current outgoing headers. Uses OutgoingHttpHeaders."
            }
          },
          {
            "name": "request.getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Returns an array of unique names of current outgoing headers."
            }
          },
          {
            "name": "request.hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Checks if a header is set in outgoing headers. Case-insensitive."
            }
          },
          {
            "name": "request.removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Removes a header queued for implicit sending."
            }
          },
          {
            "name": "request.addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Adds HTTP trailers to the message. Uses OutgoingHttpHeaders."
            }
          },
          {
            "name": "request.flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Flushes the message headers, bypassing optimization."
            }
          },
          {
            "name": "request._write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Writes data to the stream and calls the callback."
            }
          },
          {
            "name": "request._writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Writes multiple chunks to the stream and calls the callback."
            }
          },
          {
            "name": "request._construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Constructs the stream and calls the callback."
            }
          },
          {
            "name": "request._destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Destroys the stream and calls the callback with an error."
            }
          },
          {
            "name": "request._final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Finalizes the stream and calls the callback."
            }
          },
          {
            "name": "request.write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\njs\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding, if `chunk` is a string."
                },
                {
                  "name": "callback",
                  "description": "Callback for when this chunk of data is flushed."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Writes data to the stream and calls the callback. Returns true if buffer is below highWaterMark."
            }
          },
          {
            "name": "request.setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sets the default encoding for a Writable stream."
            }
          },
          {
            "name": "request.end",
            "parameters": [
              {
                "name": "cb",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\njs\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding if `chunk` is a string"
                },
                {
                  "name": "callback",
                  "description": "Callback for when the stream is finished."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Signals no more data will be written to the Writable stream. Uses optional chunk and encoding."
            }
          },
          {
            "name": "request.cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Buffers all written data in memory until uncork() is called."
            }
          },
          {
            "name": "request.uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Flushes all data buffered since cork() was called."
            }
          },
          {
            "name": "request.destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>, number>",
            "jsdoc": {
              "description": "Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'` event (unless `emitClose` is set to `false`). After this call, the writable\nstream has ended and subsequent calls to `write()` or `end()` will result in\nan `ERR_STREAM_DESTROYED` error.\nThis is a destructive and immediate way to destroy a stream. Previous calls to `write()` may not have drained, and may trigger an `ERR_STREAM_DESTROYED` error.\nUse `end()` instead of destroy if data should flush before close, or wait for\nthe `'drain'` event before destroying the stream.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method,\nbut instead implement `writable._destroy()`.",
              "params": [
                {
                  "name": "error",
                  "description": "Optional, an error to emit with `'error'` event."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Destroys the stream, optionally emitting an error. Subsequent writes result in ERR_STREAM_DESTROYED."
            }
          },
          {
            "name": "request.pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "xaiDescription": "Pipes the readable stream to the destination. Uses T type."
            }
          },
          {
            "name": "request.compose",
            "parameters": [
              {
                "name": "stream",
                "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "xaiDescription": "Composes the stream with the given stream or iterable. Uses T type."
            }
          },
          {
            "name": "request.next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Advances to the next item in the stream, optionally with an error."
            }
          },
          {
            "name": "request.toFixed",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representing a number in fixed-point notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Returns a string in fixed-point notation. Uses number type."
            }
          },
          {
            "name": "request.toExponential",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented in exponential notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Converts a number to exponential notation string."
          },
          {
            "name": "request.toPrecision",
            "parameters": [
              {
                "name": "precision",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
              "params": [
                {
                  "name": "precision",
                  "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Converts a number to a string with specified precision."
          },
          {
            "name": "request.destroySoon",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Destroys the socket after data is written."
          },
          {
            "name": "request.setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sets the encoding for the socket as a Readable Stream."
          },
          {
            "name": "request.pause",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Pauses the reading of data. That is, `'data'` events will not be emitted.\nUseful to throttle back an upload.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Pauses data reading, useful for throttling uploads."
          },
          {
            "name": "request.resetAndDestroy",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Closes TCP connection and destroys the stream."
          },
          {
            "name": "request.resume",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Resumes reading after a call to `socket.pause()`.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Resumes data reading after pausing."
          },
          {
            "name": "request.setNoDelay",
            "parameters": [
              {
                "name": "noDelay",
                "type": "boolean",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
              "params": [
                {
                  "name": "noDelay"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Enables/disables Nagle's algorithm for the socket."
          },
          {
            "name": "request.setKeepAlive",
            "parameters": [
              {
                "name": "enable",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "initialDelay",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
              "params": [
                {
                  "name": "enable"
                },
                {
                  "name": "initialDelay"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Enables/disables keep-alive functionality for the socket."
          },
          {
            "name": "request.address",
            "parameters": [],
            "returnType": "{} | AddressInfo",
            "jsdoc": {
              "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Returns socket's bound address, family, and port."
          },
          {
            "name": "request.unref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Allows program exit if socket is the only active one."
          },
          {
            "name": "request.ref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Prevents program exit if socket is the only active one."
          },
          {
            "name": "request._read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Reads data from the socket."
          },
          {
            "name": "request.read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and\nreturns it. If no data is available to be read, `null` is returned. By default,\nthe data is returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If\n`size` bytes are not available to be read, `null` will be returned _unless_ the\nstream has ended, in which case all of the data remaining in the internal buffer\nwill be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\njs\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\njs\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the `size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling    after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Reads data from the internal buffer."
          },
          {
            "name": "request.isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Returns the current operating state of the Readable."
          },
          {
            "name": "request.unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Detaches a previously attached Writable stream."
          },
          {
            "name": "request.wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Creates a Readable stream using an old-style readable stream."
          },
          {
            "name": "request.iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Creates an async iterator for the stream."
          },
          {
            "name": "request.toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false
            },
            "xaiDescription": "Returns a promise with the stream's contents as an array."
          },
          {
            "name": "request.drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false
            },
            "xaiDescription": "Returns a new stream with the first limit chunks dropped."
          },
          {
            "name": "request.take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false
            },
            "xaiDescription": "Returns a new stream with the first limit chunks."
          },
          {
            "name": "request.asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false
            },
            "xaiDescription": "Returns a new stream with chunks paired with a counter."
          },
          {
            "name": "request.__@asyncIterator@70027",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": null,
            "xaiDescription": "Async iterator for the stream."
          },
          {
            "name": "request.__@asyncDispose@70029",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Destroys the stream with an AbortError."
          },
          {
            "name": "status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false
            },
            "xaiDescription": "Sets the response status code."
          },
          {
            "name": "sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sets response status code and sends it as the body."
          },
          {
            "name": "links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false
            },
            "xaiDescription": "Sets the Link header field with given links."
          },
          {
            "name": "send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false
            },
            "xaiDescription": "Sends a response with the given body."
          },
          {
            "name": "jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false
            },
            "xaiDescription": "Sends a JSON response with JSONP callback support."
          },
          {
            "name": "sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Transfers a file at the given path."
          },
          {
            "name": "download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false
            },
            "xaiDescription": "Transfers a file as an attachment."
          },
          {
            "name": "contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            },
            "xaiDescription": "Sets the Content-Type response header."
          },
          {
            "name": "type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            },
            "xaiDescription": "Sets the Content-Type response header."
          },
          {
            "name": "format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false
            },
            "xaiDescription": "Responds to acceptable formats using mime-type callbacks."
          },
          {
            "name": "attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false
            },
            "xaiDescription": "Sets Content-Disposition header to attachment."
          },
          {
            "name": "clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false
            },
            "xaiDescription": "Clears a cookie by name."
          },
          {
            "name": "cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false
            },
            "xaiDescription": "Sets a cookie with specified name, value, and options. Uses CookieOptions."
          },
          {
            "name": "location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false
            },
            "xaiDescription": "Sets the location header to the specified URL."
          },
          {
            "name": "redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false
            },
            "xaiDescription": "Redirects to the specified URL with optional status code."
          },
          {
            "name": "vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false
            },
            "xaiDescription": "Adds a field to the Vary response header."
          },
          {
            "name": "append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field.\nIf the header is not already set, it creates the header with the specified value.\nThe value parameter can be a string or an array.\n\nNote: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Appends a value to an HTTP response header field."
          },
          {
            "name": "assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Assigns a socket to the response. Uses Socket."
          },
          {
            "name": "detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Detaches a socket from the response. Uses Socket."
          },
          {
            "name": "writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sends HTTP/1.1 100 Continue message to client."
          },
          {
            "name": "writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Sends HTTP/1.1 103 Early Hints message with headers."
          },
          {
            "name": "writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sends response headers with status code and optional message. Uses OutgoingHttpHeaders."
          },
          {
            "name": "writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sends HTTP/1.1 102 Processing message to client."
          },
          {
            "name": "setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Sets a single header value, replacing existing ones."
          },
          {
            "name": "setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Sets multiple header values, replacing existing ones. Uses Headers or Map."
          },
          {
            "name": "appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Appends a single header value to the header object."
          },
          {
            "name": "getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Gets the value of an HTTP header by name."
          },
          {
            "name": "getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Returns a shallow copy of current outgoing headers. Uses OutgoingHttpHeaders."
          },
          {
            "name": "getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Returns an array of unique names of current outgoing headers."
          },
          {
            "name": "hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Checks if a header is set in outgoing headers."
          },
          {
            "name": "removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Removes a header queued for implicit sending."
          },
          {
            "name": "addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Adds HTTP trailers to the message. Uses OutgoingHttpHeaders."
          },
          {
            "name": "flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Flushes the message headers."
          },
          {
            "name": "_write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Writes data to the stream. Uses BufferEncoding."
          },
          {
            "name": "_writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Writes multiple chunks to the stream. Uses BufferEncoding."
          },
          {
            "name": "_final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Finalizes the stream."
          },
          {
            "name": "write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `writable.write()` method writes some data to the stream, and calls the\nsupplied `callback` once the data has been fully handled. If an error\noccurs, the `callback` will be called with the error as its\nfirst argument. The `callback` is called asynchronously and before `'error'` is\nemitted.\n\nThe return value is `true` if the internal buffer is less than the `highWaterMark` configured when the stream was created after admitting `chunk`.\nIf `false` is returned, further attempts to write data to the stream should\nstop until the `'drain'` event is emitted.\n\nWhile a stream is not draining, calls to `write()` will buffer `chunk`, and\nreturn false. Once all currently buffered chunks are drained (accepted for\ndelivery by the operating system), the `'drain'` event will be emitted.\nOnce `write()` returns false, do not write more chunks\nuntil the `'drain'` event is emitted. While calling `write()` on a stream that\nis not draining is allowed, Node.js will buffer all written chunks until\nmaximum memory usage occurs, at which point it will abort unconditionally.\nEven before it aborts, high memory usage will cause poor garbage collector\nperformance and high RSS (which is not typically released back to the system,\neven after the memory is no longer required). Since TCP sockets may never\ndrain if the remote peer does not read the data, writing a socket that is\nnot draining may lead to a remotely exploitable vulnerability.\n\nWriting data while the stream is not draining is particularly\nproblematic for a `Transform`, because the `Transform` streams are paused\nby default until they are piped or a `'data'` or `'readable'` event handler\nis added.\n\nIf the data to be written can be generated or fetched on demand, it is\nrecommended to encapsulate the logic into a `Readable` and use   . However, if calling `write()` is preferred, it is\npossible to respect backpressure and avoid memory issues using the `'drain'` event:\n\njs\nfunction write(data, cb) {\n  if (!stream.write(data)) {\n    stream.once('drain', cb);\n  } else {\n    process.nextTick(cb);\n  }\n}\n\n// Wait for cb to be called before doing any other write.\nwrite('hello', () => {\n  console.log('Write completed, do more writes now.');\n});\n\n\nA `Writable` stream in object mode will always ignore the `encoding` argument.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding, if `chunk` is a string."
                },
                {
                  "name": "callback",
                  "description": "Callback for when this chunk of data is flushed."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Writes data to the stream, returns true if buffer is below highWaterMark."
          },
          {
            "name": "setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Sets the default encoding for a Writable stream. Uses BufferEncoding."
          },
          {
            "name": "end",
            "parameters": [
              {
                "name": "cb",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Calling the `writable.end()` method signals that no more data will be written\nto the `Writable`. The optional `chunk` and `encoding` arguments allow one\nfinal additional chunk of data to be written immediately before closing the\nstream.\n\nCalling the    method after calling    will raise an error.\n\njs\n// Write 'hello, ' and then end with 'world!'.\nimport fs from 'node:fs';\nconst file = fs.createWriteStream('example.txt');\nfile.write('hello, ');\nfile.end('world!');\n// Writing more now is not allowed!\n",
              "params": [
                {
                  "name": "chunk",
                  "description": "Optional data to write. For streams not operating in object mode, `chunk` must be a {string}, {Buffer},\n{TypedArray} or {DataView}. For object mode streams, `chunk` may be any JavaScript value other than `null`."
                },
                {
                  "name": "encoding",
                  "description": "The encoding if `chunk` is a string"
                },
                {
                  "name": "callback",
                  "description": "Callback for when the stream is finished."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Signals no more data will be written to the Writable stream."
          },
          {
            "name": "cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Buffers all written data in memory until uncorked."
          },
          {
            "name": "uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.status",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set status `code`.",
              "deprecated": false
            },
            "xaiDescription": "Sets the HTTP status code of the response."
          },
          {
            "name": "response.sendStatus",
            "parameters": [
              {
                "name": "code",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the response HTTP status code to `statusCode` and send its string representation as the response body.",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Sets status code and sends it as the response body."
          },
          {
            "name": "response.links",
            "parameters": [
              {
                "name": "links",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set Link header field with the given `links`.\n\nExamples:\n\n   res.links({\n     next: 'http://api.example.com/users?page=2',\n     last: 'http://api.example.com/users?page=5'\n   });",
              "deprecated": false
            },
            "xaiDescription": "Sets Link header with provided links."
          },
          {
            "name": "response.send",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');",
              "deprecated": false
            },
            "xaiDescription": "Sends a response with the provided body."
          },
          {
            "name": "response.json",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');",
              "deprecated": false
            },
            "xaiDescription": "Sends a JSON response with the provided body."
          },
          {
            "name": "response.jsonp",
            "parameters": [
              {
                "name": "body",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');",
              "deprecated": false
            },
            "xaiDescription": "Sends JSON response with JSONP callback support."
          },
          {
            "name": "response.sendFile",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path`.\n\nAutomatically sets the _Content-Type_ response header field.\nThe callback `fn(err)` is invoked when the transfer is complete\nor when an error occurs. Be sure to check `res.headersSent`\nif you wish to attempt responding, as the header and some data\nmay have already been transferred.\n\nOptions:\n\n  - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n  - `root`     root directory for relative filenames\n  - `headers`  object of headers to serve with file\n  - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n\nOther options are passed along to `send`.\n\nExamples:\n\n The following example illustrates how `res.sendFile()` may\n be used as an alternative for the `static()` middleware for\n dynamic situations. The code backing `res.sendFile()` is actually\n the same code, so HTTP cache support etc is identical.\n\n    app.get('/user/:uid/photos/:file', function(req, res){\n      var uid = req.params.uid\n        , file = req.params.file;\n\n      req.user.mayViewFilesFrom(uid, function(yes){\n        if (yes) {\n          res.sendFile('/uploads/' + uid + '/' + file);\n        } else {\n          res.send(403, 'Sorry! you cant see that.');\n        }\n      });\n    });",
              "params": [],
              "deprecated": false
            },
            "xaiDescription": "Transfers file at given path, sets Content-Type."
          },
          {
            "name": "response.download",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "Errback",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Transfer the file at the given `path` as an attachment.\n\nOptionally providing an alternate attachment `filename`,\nand optional callback `fn(err)`. The callback is invoked\nwhen the data transfer is complete, or when an error has\nocurred. Be sure to check `res.headersSent` if you plan to respond.\n\nThe optional options argument passes through to the underlying\nres.sendFile() call, and takes the exact same parameters.\n\nThis method uses `res.sendFile()`.",
              "deprecated": false
            },
            "xaiDescription": "Transfers file as attachment, uses res.sendFile()."
          },
          {
            "name": "response.contentType",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            },
            "xaiDescription": "Sets Content-Type header using mime.lookup() or directly."
          },
          {
            "name": "response.type",
            "parameters": [
              {
                "name": "type",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Type_ response header with `type` through `mime.lookup()`\nwhen it does not contain \"/\", or set the Content-Type to `type` otherwise.\n\nExamples:\n\n    res.type('.html');\n    res.type('html');\n    res.type('json');\n    res.type('application/json');\n    res.type('png');",
              "deprecated": false
            },
            "xaiDescription": "Sets Content-Type header using mime.lookup() or directly."
          },
          {
            "name": "response.format",
            "parameters": [
              {
                "name": "obj",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Respond to the Acceptable formats using an `obj`\nof mime-type callbacks.\n\nThis method uses `req.accepted`, an array of\nacceptable types ordered by their quality values.\nWhen \"Accept\" is not present the _first_ callback\nis invoked, otherwise the first match is used. When\nno match is performed the server responds with\n406 \"Not Acceptable\".\n\nContent-Type is set for you, however if you choose\nyou may alter this within the callback using `res.type()`\nor `res.set('Content-Type', ...)`.\n\n   res.format({\n     'text/plain': function(){\n       res.send('hey');\n     },\n\n     'text/html': function(){\n       res.send('<p>hey</p>');\n     },\n\n     'appliation/json': function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nIn addition to canonicalized MIME types you may\nalso use extnames mapped to these types:\n\n   res.format({\n     text: function(){\n       res.send('hey');\n     },\n\n     html: function(){\n       res.send('<p>hey</p>');\n     },\n\n     json: function(){\n       res.send({ message: 'hey' });\n     }\n   });\n\nBy default Express passes an `Error`\nwith a `.status` of 406 to `next(err)`\nif a match is not made. If you provide\na `.default` callback it will be invoked\ninstead.",
              "deprecated": false
            },
            "xaiDescription": "Responds based on Accept header, sets Content-Type."
          },
          {
            "name": "response.attachment",
            "parameters": [
              {
                "name": "filename",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set _Content-Disposition_ header to _attachment_ with optional `filename`.",
              "deprecated": false
            },
            "xaiDescription": "Sets Content-Disposition header to attachment."
          },
          {
            "name": "response.set",
            "parameters": [
              {
                "name": "field",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set header `field` to `val`, or pass\nan object of header fields.\n\nExamples:\n\n   res.set('Foo', ['bar', 'baz']);\n   res.set('Accept', 'application/json');\n   res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n\nAliased as `res.header()`.",
              "deprecated": false
            },
            "xaiDescription": "Sets response header field or multiple fields."
          },
          {
            "name": "response.header",
            "parameters": [
              {
                "name": "field",
                "type": "any",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": null,
            "xaiDescription": "Alias for res.set(), sets response header."
          },
          {
            "name": "response.valueOf",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns the primitive value of the specified object.",
              "deprecated": false
            },
            "xaiDescription": "Returns primitive value of the object."
          },
          {
            "name": "response.get",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Get value for header `field`.",
              "deprecated": false
            },
            "xaiDescription": "Retrieves value of specified header field."
          },
          {
            "name": "response.clearCookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Clear cookie `name`.",
              "deprecated": false
            },
            "xaiDescription": "Clears specified cookie."
          },
          {
            "name": "response.cookie",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "val",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "CookieOptions",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set cookie `name` to `val`, with the given `options`.\n\nOptions:\n\n   - `maxAge`   max-age in milliseconds, converted to `expires`\n   - `signed`   sign the cookie\n   - `path`     defaults to \"/\"\n\nExamples:\n\n   // \"Remember Me\" for 15 minutes\n   res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n\n   // save as above\n   res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
              "deprecated": false
            },
            "xaiDescription": "Sets a cookie with specified name, value, and options."
          },
          {
            "name": "response.location",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Set the location header to `url`.\n\nExamples:\n\n   res.location('/foo/bar').;\n   res.location('http://example.com');\n   res.location('../login'); // /blog/post/1 -> /blog/login\n\nMounting:\n\n  When an application is mounted and `res.location()`\n  is given a path that does _not_ lead with \"/\" it becomes\n  relative to the mount-point. For example if the application\n  is mounted at \"/blog\", the following would become \"/blog/login\".\n\n     res.location('login');\n\n  While the leading slash would result in a location of \"/login\":\n\n     res.location('/login');",
              "deprecated": false
            },
            "xaiDescription": "Sets the Location header to the specified URL."
          },
          {
            "name": "response.redirect",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Redirect to the given `url` with optional response `status`\ndefaulting to 302.\n\nThe resulting `url` is determined by `res.location()`, so\nit will play nicely with mounted apps, relative paths, etc.\n\nExamples:\n\n   res.redirect('/foo/bar');\n   res.redirect('http://example.com');\n   res.redirect(301, 'http://example.com');\n   res.redirect('../login'); // /blog/post/1 -> /blog/login",
              "deprecated": false
            },
            "xaiDescription": "Redirects to specified URL, uses res.location()."
          },
          {
            "name": "response.render",
            "parameters": [
              {
                "name": "view",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "object",
                "optional": true
              },
              {
                "name": "callback",
                "type": "(err: Error, html: string) => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Render `view` with the given `options` and optional callback `fn`.\nWhen a callback function is given a response will _not_ be made\nautomatically, otherwise a response of _200_ and _text/html_ is given.\n\nOptions:\n\n - `cache`     boolean hinting to the engine it should cache\n - `filename`  filename of the view being rendered",
              "deprecated": false
            },
            "xaiDescription": "Renders specified view with options, uses callback."
          },
          {
            "name": "response.toString",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representation of a string.",
              "deprecated": false
            },
            "xaiDescription": "Returns string representation of the object."
          },
          {
            "name": "response.charAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the character at the specified index.",
              "params": [
                {
                  "name": "pos",
                  "description": "The zero-based index of the desired character."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Returns character at specified index."
          },
          {
            "name": "response.charCodeAt",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the Unicode value of the character at the specified location.",
              "params": [
                {
                  "name": "index",
                  "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Returns Unicode value of character at index."
          },
          {
            "name": "response.concat",
            "parameters": [
              {
                "name": "strings",
                "type": "string[]",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string that contains the concatenation of two or more strings.",
              "params": [
                {
                  "name": "strings",
                  "description": "The strings to append to the end of the string."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Concatenates multiple strings."
          },
          {
            "name": "response.indexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the position of the first occurrence of a substring.",
              "params": [
                {
                  "name": "searchString",
                  "description": "The substring to search for in the string"
                },
                {
                  "name": "position",
                  "description": "The index at which to begin searching the String object. If omitted, search starts at the beginning of the string."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Finds first occurrence of substring."
          },
          {
            "name": "response.lastIndexOf",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the last occurrence of a substring in the string.",
              "params": [
                {
                  "name": "searchString",
                  "description": "The substring to search for."
                },
                {
                  "name": "position",
                  "description": "The index at which to begin searching. If omitted, the search begins at the end of the string."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Finds last occurrence of substring."
          },
          {
            "name": "response.localeCompare",
            "parameters": [
              {
                "name": "that",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Determines whether two strings are equivalent in the current locale.",
              "params": [
                {
                  "name": "that",
                  "description": "String to compare to target string"
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Compares strings based on current locale."
          },
          {
            "name": "response.match",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpMatchArray",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an array containing the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Matches string with regex, returns result array."
          },
          {
            "name": "response.replace",
            "parameters": [
              {
                "name": "searchValue",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "replaceValue",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Replaces text in a string, using a regular expression or search string.",
              "params": [
                {
                  "name": "searchValue",
                  "description": "A string or regular expression to search for."
                },
                {
                  "name": "replaceValue",
                  "description": "A string containing the text to replace. When the    is a `RegExp`, all matches are replaced if the `g` flag is set (or only those matches at the beginning, if the `y` flag is also present). Otherwise, only the first match of    is replaced."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Replaces text in string using regex or string."
          },
          {
            "name": "response.search",
            "parameters": [
              {
                "name": "regexp",
                "type": "string | RegExp",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Finds the first substring match in a regular expression search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "The regular expression pattern and applicable flags."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Finds first substring match using regex."
          },
          {
            "name": "response.slice",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": true
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a section of a string.",
              "params": [
                {
                  "name": "start",
                  "description": "The index to the beginning of the specified portion of stringObj."
                },
                {
                  "name": "end",
                  "description": "The index to the end of the specified portion of stringObj. The substring includes the characters up to, but not including, the character indicated by end.\nIf this value is not specified, the substring continues to the end of stringObj."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Returns section of string from start to end."
          },
          {
            "name": "response.split",
            "parameters": [
              {
                "name": "separator",
                "type": "string | RegExp",
                "optional": false
              },
              {
                "name": "limit",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Split a string into substrings using the specified separator and return them as an array.",
              "params": [
                {
                  "name": "separator",
                  "description": "A string that identifies character or characters to use in separating the string. If omitted, a single-element array containing the entire string is returned."
                },
                {
                  "name": "limit",
                  "description": "A value used to limit the number of elements returned in the array."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Splits string into array using separator."
          },
          {
            "name": "response.substring",
            "parameters": [
              {
                "name": "start",
                "type": "number",
                "optional": false
              },
              {
                "name": "end",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the substring at the specified location within a String object.",
              "params": [
                {
                  "name": "start",
                  "description": "The zero-based index number indicating the beginning of the substring."
                },
                {
                  "name": "end",
                  "description": "Zero-based index number indicating the end of the substring. The substring includes the characters up to, but not including, the character indicated by end.\nIf end is omitted, the characters from start through the end of the original string are returned."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Returns substring from start to end."
          },
          {
            "name": "response.toLowerCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to lowercase.",
              "deprecated": false
            },
            "xaiDescription": "Converts string to lowercase."
          },
          {
            "name": "response.toLocaleLowerCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all alphabetic characters to lowercase, taking into account the host environment's current locale.",
              "deprecated": false
            },
            "xaiDescription": "Converts string to lowercase based on locale."
          },
          {
            "name": "response.toUpperCase",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts all the alphabetic characters in a string to uppercase.",
              "deprecated": false
            },
            "xaiDescription": "Converts string to uppercase."
          },
          {
            "name": "response.toLocaleUpperCase",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string where all alphabetic characters have been converted to uppercase, taking into account the host environment's current locale.",
              "deprecated": false
            },
            "xaiDescription": "Converts string to uppercase based on locale."
          },
          {
            "name": "response.trim",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading and trailing white space and line terminator characters from a string.",
              "deprecated": false
            },
            "xaiDescription": "Removes leading and trailing whitespace."
          },
          {
            "name": "response.substr",
            "parameters": [
              {
                "name": "from",
                "type": "number",
                "optional": false
              },
              {
                "name": "length",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Gets a substring beginning at the specified location and having the specified length.",
              "params": [
                {
                  "name": "from",
                  "description": "The starting position of the desired substring. The index of the first character in the string is zero."
                },
                {
                  "name": "length",
                  "description": "The number of characters to include in the returned substring."
                }
              ],
              "deprecated": true
            },
            "xaiDescription": "Gets substring from specified position and length."
          },
          {
            "name": "response.codePointAt",
            "parameters": [
              {
                "name": "pos",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns a nonnegative integer Number less than 1114112 (0x110000) that is the code point\nvalue of the UTF-16 encoded code point starting at the string element at position pos in\nthe String resulting from converting this object to a String.\nIf there is no element at that position, the result is undefined.\nIf a valid UTF-16 surrogate pair does not begin at pos, the result is the code unit at pos.",
              "deprecated": false
            },
            "xaiDescription": "Returns Unicode code point at specified position."
          },
          {
            "name": "response.includes",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if searchString appears as a substring of the result of converting this\nobject to a String, at one or more positions that are\ngreater than or equal to position; otherwise, returns false.",
              "params": [
                {
                  "name": "searchString",
                  "description": "search string"
                },
                {
                  "name": "position",
                  "description": "If position is undefined, 0 is assumed, so as to search all of the String."
                }
              ],
              "deprecated": false
            },
            "xaiDescription": "Checks if string includes specified substring."
          },
          {
            "name": "response.endsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "endPosition",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nendPosition – length(this). Otherwise returns false.",
              "deprecated": false
            },
            "xaiDescription": "Checks if string ends with specified substring."
          },
          {
            "name": "response.normalize",
            "parameters": [
              {
                "name": "form",
                "type": "\"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns the String value result of normalizing the string into the normalization form\nnamed by form as specified in Unicode Standard Annex #15, Unicode Normalization Forms.",
              "params": [
                {
                  "name": "form",
                  "description": "Applicable values: \"NFC\", \"NFD\", \"NFKC\", or \"NFKD\", If not specified default\nis \"NFC\""
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.repeat",
            "parameters": [
              {
                "name": "count",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned.",
              "params": [
                {
                  "name": "count",
                  "description": "number of copies to append"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.startsWith",
            "parameters": [
              {
                "name": "searchString",
                "type": "string",
                "optional": false
              },
              {
                "name": "position",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns true if the sequence of elements of searchString converted to a String is the\nsame as the corresponding elements of this object (converted to a String) starting at\nposition. Otherwise returns false.",
              "deprecated": false
            }
          },
          {
            "name": "response.anchor",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML anchor element and sets the name attribute to the text value",
              "params": [
                {
                  "name": "name"
                }
              ],
              "deprecated": true
            }
          },
          {
            "name": "response.big",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<big>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.blink",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<blink>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.bold",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<b>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fixed",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<tt>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fontcolor",
            "parameters": [
              {
                "name": "color",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the color attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.fontsize",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<font>` HTML element and sets the size attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.italics",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<i>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.link",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns an `<a>` HTML element and sets the href attribute value",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.small",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<small>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.strike",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<strike>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.sub",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sub>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.sup",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a `<sup>` HTML element",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.padStart",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the start (left) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.padEnd",
            "parameters": [
              {
                "name": "maxLength",
                "type": "number",
                "optional": false
              },
              {
                "name": "fillString",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Pads the current string with a given string (possibly repeated) so that the resulting string reaches a given length.\nThe padding is applied from the end (right) of the current string.",
              "params": [
                {
                  "name": "maxLength",
                  "description": "The length of the resulting string once the current string has been padded.\nIf this parameter is smaller than the current string's length, the current string will be returned as it is."
                },
                {
                  "name": "fillString",
                  "description": "The string to pad the current string with.\nIf this string is too long, it will be truncated and the left-most part will be applied.\nThe default value for this parameter is \" \" (U+0020)."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.trimEnd",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.trimStart",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "deprecated": false
            }
          },
          {
            "name": "response.trimLeft",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the leading white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.trimRight",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Removes the trailing white space and line terminator characters from a string.",
              "params": [],
              "deprecated": true
            }
          },
          {
            "name": "response.matchAll",
            "parameters": [
              {
                "name": "regexp",
                "type": "RegExp",
                "optional": false
              }
            ],
            "returnType": "RegExpStringIterator<RegExpExecArray>",
            "jsdoc": {
              "description": "Matches a string with a regular expression, and returns an iterable of matches\ncontaining the results of that search.",
              "params": [
                {
                  "name": "regexp",
                  "description": "A variable name or string literal containing the regular expression pattern and flags."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.__@iterator@69548",
            "parameters": [],
            "returnType": "StringIterator<string>",
            "jsdoc": {
              "description": "Iterator",
              "deprecated": false
            }
          },
          {
            "name": "response.at",
            "parameters": [
              {
                "name": "index",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "xaiDescription": "Returns the character at the specified index in the string."
            }
          },
          {
            "name": "response.vary",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Adds the field to the Vary response header, if it is not there already.\nExamples:\n\n    res.vary('User-Agent').render('docs');",
              "deprecated": false
            }
          },
          {
            "name": "response.app",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>> | IncomingMessage",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number> | ServerResponse<IncomingMessage>",
                "optional": false
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "xaiDescription": "Handles the request and response objects."
            }
          },
          {
            "name": "response.init",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize the server.\n\n  - setup default configuration\n  - setup default middleware\n  - setup route reflection methods",
              "deprecated": false
            }
          },
          {
            "name": "response.defaultConfiguration",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Initialize application configuration.",
              "deprecated": false
            }
          },
          {
            "name": "response.engine",
            "parameters": [
              {
                "name": "ext",
                "type": "string",
                "optional": false
              },
              {
                "name": "fn",
                "type": "(path: string, options: object, callback: (e: any, rendered?: string) => void) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Register the given template engine callback `fn`\nas `ext`.\n\nBy default will `require()` the engine based on the\nfile extension. For example if you try to render\na \"foo.jade\" file Express will invoke the following internally:\n\n    app.engine('jade', require('jade').__express);\n\nFor engines that do not provide `.__express` out of the box,\nor if you wish to \"map\" a different extension to the template engine\nyou may use this method. For example mapping the EJS template engine to\n\".html\" files:\n\n    app.engine('html', require('ejs').renderFile);\n\nIn this case EJS provides a `.renderFile()` method with\nthe same signature that Express expects: `(path, options, callback)`,\nthough note that it aliases this method as `ejs.__express` internally\nso if you're using \".ejs\" extensions you dont need to do anything.\n\nSome template engines do not follow this convention, the\n[Consolidate.js](https://github.com/visionmedia/consolidate.js)\nlibrary was created to map all of node's popular template\nengines to follow this convention, thus allowing them to\nwork seamlessly within Express.",
              "deprecated": false
            }
          },
          {
            "name": "response.param",
            "parameters": [
              {
                "name": "name",
                "type": "string | string[]",
                "optional": false
              },
              {
                "name": "handler",
                "type": "RequestParamHandler",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Registers a parameter handler for the specified name(s)."
            }
          },
          {
            "name": "response.path",
            "parameters": [],
            "returnType": "string",
            "jsdoc": {
              "description": "Return the app's absolute pathname\nbased on the parent(s) that have\nmounted it.\n\nFor example if the application was\nmounted as \"/admin\", which itself\nwas mounted as \"/blog\" then the\nreturn value would be \"/blog/admin\".",
              "deprecated": false
            }
          },
          {
            "name": "response.enabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is enabled (truthy).\n\n   app.enabled('foo')\n   // => false\n\n   app.enable('foo')\n   app.enabled('foo')\n   // => true",
              "deprecated": false
            }
          },
          {
            "name": "response.disabled",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Check if `setting` is disabled.\n\n   app.disabled('foo')\n   // => true\n\n   app.enable('foo')\n   app.disabled('foo')\n   // => false",
              "deprecated": false
            }
          },
          {
            "name": "response.enable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Enable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "response.disable",
            "parameters": [
              {
                "name": "setting",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Disable `setting`.",
              "deprecated": false
            }
          },
          {
            "name": "response.listen",
            "parameters": [
              {
                "name": "port",
                "type": "number",
                "optional": false
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false
              },
              {
                "name": "backlog",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "Server<typeof IncomingMessage, typeof ServerResponse>",
            "jsdoc": {
              "description": "Listen for connections.\n\nA node `http.Server` is returned, with this\napplication (which is a `Function`) as its\ncallback. If you wish to create both an HTTP\nand HTTPS server you may do so with the \"http\"\nand \"https\" modules as shown here:\n\n   var http = require('http')\n     , https = require('https')\n     , express = require('express')\n     , app = express();\n\n   http.createServer(app).listen(80);\n   https.createServer({ ... }, app).listen(443);",
              "deprecated": false
            }
          },
          {
            "name": "response.router",
            "parameters": [
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false
              },
              {
                "name": "res",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": false
              }
            ],
            "returnType": "void | Promise<void>",
            "jsdoc": {
              "xaiDescription": "Handles routing for the given request and response."
            }
          },
          {
            "name": "response.use",
            "parameters": [
              {
                "name": "handlers",
                "type": "RequestHandler<ParamsDictionary, any, any, ParsedQs, Record<string, any>>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Adds middleware handlers to the application."
            }
          },
          {
            "name": "response.on",
            "parameters": [
              {
                "name": "event",
                "type": "string",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(parent: Application<Record<string, any>>) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.",
              "deprecated": false
            }
          },
          {
            "name": "response.__@captureRejectionSymbol@69398",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "event",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Handles error capture and rejection."
            }
          },
          {
            "name": "response.addListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.on(eventName, listener)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.once",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a **one-time** `listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\njs\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\njs\nimport { EventEmitter } from 'node:events';\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.removeListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes the specified `listener` from the listener array for the event named `eventName`.\n\njs\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution\nwill not remove them from`emit()` in progress. Subsequent events behave as expected.\n\njs\nimport { EventEmitter } from 'node:events';\nclass MyEmitter extends EventEmitter {}\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')` listener is removed:\n\njs\nimport { EventEmitter } from 'node:events';\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.off",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Alias for `emitter.removeListener()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.removeAllListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": true
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setMaxListeners",
            "parameters": [
              {
                "name": "n",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.getMaxListeners",
            "parameters": [],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to   .",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.listeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`.\n\njs\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.rawListeners",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              }
            ],
            "returnType": "Function[]",
            "jsdoc": {
              "description": "Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\njs\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.emit",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "args",
                "type": "AnyRest",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments to each. Returns `true` if the event had listeners, `false` otherwise.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.listenerCount",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "Function",
                "optional": true
              }
            ],
            "returnType": "number",
            "jsdoc": {
              "description": "Returns the number of listeners listening for the event named `eventName`. If `listener` is provided, it will return how many times the listener is found in the list of the listeners of the event.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event being listened for"
                },
                {
                  "name": "listener",
                  "description": "The event handler function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.prependListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds the `listener` function to the beginning of the listeners array for the event named `eventName`. No checks are made to see if the `listener` has already been added. Multiple calls passing the same combination of `eventName` and `listener` will result in the `listener` being added, and called, multiple times. Returns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.prependOnceListener",
            "parameters": [
              {
                "name": "eventName",
                "type": "string | symbol",
                "optional": false
              },
              {
                "name": "listener",
                "type": "(...args: any[]) => void",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Adds a one-time `listener` function for the event named `eventName` to the beginning of the listeners array. The next time `eventName` is triggered, this listener is removed, and then invoked. Returns a reference to the `EventEmitter`, so that calls can be chained.",
              "params": [
                {
                  "name": "eventName",
                  "description": "The name of the event."
                },
                {
                  "name": "listener",
                  "description": "The callback function"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.eventNames",
            "parameters": [],
            "returnType": "(string | symbol)[]",
            "jsdoc": {
              "description": "Returns an array listing the events for which the emitter has registered listeners. The values in the array are strings or `Symbol`s.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.all",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "description": "Special-cased \"all\" method, applying the given route `path`, middleware, and callback to every HTTP method.",
              "deprecated": false,
              "xaiDescription": "Applies route to all HTTP methods. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.post",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles POST requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.put",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PUT requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.delete",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles DELETE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.patch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PATCH requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.options",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles OPTIONS requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.head",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles HEAD requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.checkout",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles CHECKOUT requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.connect",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles CONNECT requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.copy",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles COPY requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.lock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles LOCK requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.merge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MERGE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.mkactivity",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MKACTIVITY requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.mkcol",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MKCOL requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.move",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles MOVE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.m-search",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles M-SEARCH requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.notify",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles NOTIFY requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.propfind",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PROPFIND requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.proppatch",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PROPPATCH requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.purge",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles PURGE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.report",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles REPORT requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.subscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles SUBSCRIBE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.trace",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles TRACE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.unlock",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNLOCK requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.unsubscribe",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNSUBSCRIBE requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.unlink",
            "parameters": [
              {
                "name": "path",
                "type": "Route",
                "optional": false
              },
              {
                "name": "handlers",
                "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, LocalsObj>[]",
                "optional": false
              }
            ],
            "returnType": "Application<Record<string, any>>",
            "jsdoc": {
              "xaiDescription": "Handles UNLINK requests. Uses Route, RequestHandler."
            }
          },
          {
            "name": "response.route",
            "parameters": [
              {
                "name": "prefix",
                "type": "T",
                "optional": false
              }
            ],
            "returnType": "IRoute<T>",
            "jsdoc": {
              "xaiDescription": "Creates a new route with the given prefix. Uses IRoute<T>."
            }
          },
          {
            "name": "response.append",
            "parameters": [
              {
                "name": "field",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | string[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Appends the specified value to the HTTP response header field. If the header is not already set, it creates the header with the specified value. The value parameter can be a string or an array. Note: calling res.set() after res.append() will reset the previously-set header value.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.accepts",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Check if the given `type(s)` is acceptable, returning the best match when true, otherwise `undefined`, in which case you should respond with 406 \"Not Acceptable\". The `type` value may be a single mime type string such as \"application/json\", the extension name such as \"json\", a comma-delimted list such as \"json, html, text/plain\", or an array `[\"json\", \"html\", \"text/plain\"]`. When a list or array is given the _best_ match, if any is returned.",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsCharsets",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted charset of the specified character sets, based on the request's Accept-Charset HTTP header field. If none of the specified charsets is accepted, returns false. For more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsEncodings",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted encoding of the specified encodings, based on the request's Accept-Encoding HTTP header field. If none of the specified encodings is accepted, returns false. For more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.acceptsLanguages",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns the first accepted language of the specified languages, based on the request's Accept-Language HTTP header field. If none of the specified languages is accepted, returns false. For more information, or if you have issues or concerns, see accepts.",
              "deprecated": false
            }
          },
          {
            "name": "response.range",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Options",
                "optional": true
              }
            ],
            "returnType": "Ranges | Result",
            "jsdoc": {
              "description": "Parse Range header field, capping to the given `size`. Unspecified ranges such as \"0-\" require knowledge of your resource length. In the case of a byte range this is of course the total number of bytes. If the Range header field is not given `undefined` is returned. If the Range header field is given, return value is a result of range-parser. See more ./types/range-parser/index.d.ts NOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\" should respond with 4 users when available, not 3.",
              "deprecated": false
            }
          },
          {
            "name": "response.is",
            "parameters": [
              {
                "name": "type",
                "type": "string | string[]",
                "optional": false
              }
            ],
            "returnType": "string | false",
            "jsdoc": {
              "description": "Check if the incoming request contains the \"Content-Type\" header field, and it contains the give mime `type`. Examples: With Content-Type: text/html; charset=utf-8 req.is('html'); req.is('text/html'); req.is('text/*'); // => true When Content-Type is application/json req.is('json'); req.is('application/json'); req.is('application/*'); // => true req.is('html'); // => false",
              "deprecated": false
            }
          },
          {
            "name": "response.next",
            "parameters": [
              {
                "name": "err",
                "type": "any",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Passes control to the next matching route. Optional error parameter."
            }
          },
          {
            "name": "response.setTimeout",
            "parameters": [
              {
                "name": "msecs",
                "type": "number",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `message.socket.setTimeout(msecs, callback)`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed as an argument to any listeners on the event.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response._construct",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Initializes the response object. Uses callback for error handling."
            }
          },
          {
            "name": "response._read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "xaiDescription": "Reads data from the response stream. Uses size parameter."
            }
          },
          {
            "name": "response.read",
            "parameters": [
              {
                "name": "size",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "any",
            "jsdoc": {
              "description": "The `readable.read()` method reads data out of the internal buffer and returns it. If no data is available to be read, `null` is returned. By default, the data is returned as a `Buffer` object unless an encoding has been specified using the `readable.setEncoding()` method or the stream is operating in object mode. The optional `size` argument specifies a specific number of bytes to read. If `size` bytes are not available to be read, `null` will be returned _unless_ the stream has ended, in which case all of the data remaining in the internal buffer will be returned. If the `size` argument is not specified, all of the data contained in the internal buffer will be returned. The `size` argument must be less than or equal to 1 GiB. The `readable.read()` method should only be called on `Readable` streams operating in paused mode. In flowing mode, `readable.read()` is called automatically until the internal buffer is fully drained. Each call to `readable.read()` returns a chunk of data, or `null`. The chunks are not concatenated. A `while` loop is necessary to consume all data currently in the buffer. When reading a large file `.read()` may return `null`, having consumed all buffered content so far, but there is still more data to come not yet buffered. In this case a new `'readable'` event will be emitted when there is more data in the buffer. Finally the `'end'` event will be emitted when there is no more data to come. Therefore to read a file's whole contents from a `readable`, it is necessary to collect chunks across multiple `'readable'` events. A `Readable` stream in object mode will always return a single item from a call to `readable.read(size)`, regardless of the value of the `size` argument. If the `readable.read()` method returns a chunk of data, a `'data'` event will also be emitted. Calling after the `'end'` event has been emitted will return `null`. No runtime error will be raised.",
              "params": [
                {
                  "name": "size",
                  "description": "Optional argument to specify how much data to read."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as `Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer` objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling `readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n",
              "params": [
                {
                  "name": "encoding",
                  "description": "The encoding to use."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Sets encoding for readable stream data. Uses BufferEncoding."
            }
          },
          {
            "name": "response.pause",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\njs\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n\n\nThe `readable.pause()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Pauses a readable stream, stopping data events."
            }
          },
          {
            "name": "response.resume",
            "parameters": [],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\njs\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n\n\nThe `readable.resume()` method has no effect if there is a `'readable'` event listener.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Resumes a paused readable stream, starting data events."
            }
          },
          {
            "name": "response.isPaused",
            "parameters": [],
            "returnType": "boolean",
            "jsdoc": {
              "description": "The `readable.isPaused()` method returns the current operating state of the `Readable`.\nThis is used primarily by the mechanism that underlies the `readable.pipe()` method.\nIn most typical cases, there will be no reason to use this method directly.\n\njs\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Checks if a readable stream is paused."
            }
          },
          {
            "name": "response.unpipe",
            "parameters": [
              {
                "name": "destination",
                "type": "WritableStream",
                "optional": true
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the    method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\njs\nimport fs from 'node:fs';\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n",
              "params": [
                {
                  "name": "destination",
                  "description": "Optional specific stream to unpipe"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Detaches a writable stream from a readable stream."
            }
          },
          {
            "name": "response.unshift",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\njs\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nimport { StringDecoder } from 'node:string_decoder';\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.includes('\\n\\n')) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n        return;\n      }\n      // Still reading the header.\n      header += str;\n    }\n  }\n}\n\n\nUnlike   , `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a    implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate    will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must\nbe a {string}, {Buffer}, {TypedArray}, {DataView} or `null`. For object mode streams, `chunk` may be any JavaScript value."
                },
                {
                  "name": "encoding",
                  "description": "Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Pushes data back into the readable stream's internal buffer."
            }
          },
          {
            "name": "response.wrap",
            "parameters": [
              {
                "name": "stream",
                "type": "ReadableStream",
                "optional": false
              }
            ],
            "returnType": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
            "jsdoc": {
              "description": "Prior to Node.js 0.10, streams did not implement the entire `node:stream` module API as it is currently defined. (See `Compatibility` for more\ninformation.)\n\nWhen using an older Node.js library that emits `'data'` events and has a    method that is advisory only, the `readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\njs\nimport { OldReader } from './old-api-module.js';\nimport { Readable } from 'node:stream';\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n",
              "params": [
                {
                  "name": "stream",
                  "description": "An \"old style\" readable stream"
                }
              ],
              "deprecated": false,
              "xaiDescription": "Creates a new Readable stream wrapping an old style stream."
            }
          },
          {
            "name": "response.push",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Pushes data onto the readable stream's internal buffer.",
              "params": [
                {
                  "name": "chunk",
                  "description": "Data to push onto the stream's buffer."
                },
                {
                  "name": "encoding",
                  "description": "Optional encoding for string chunks."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Adds data to the readable stream's internal buffer."
            }
          },
          {
            "name": "response.iterator",
            "parameters": [
              {
                "name": "options",
                "type": "{ destroyOnReturn?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "The iterator created by this method gives users the option to cancel the destruction\nof the stream if the `for await...of` loop is exited by `return`, `break`, or `throw`,\nor if the iterator should destroy the stream if the stream emitted an error during iteration.",
              "params": [
                {
                  "description": "When set to `false`, calling `return` on the async iterator,\nor exiting a `for await...of` iteration using a `break`, `return`, or `throw` will not destroy the stream.\n**Default: `true`**."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Creates an async iterator for the readable stream."
            }
          },
          {
            "name": "response.map",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows mapping over the stream. The *fn* function will be called for every chunk in the stream.\nIf the *fn* function returns a promise - that promise will be `await`ed before being passed to the result stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. Async or not."
                }
              ],
              "returns": "a stream mapped with the function *fn*.",
              "deprecated": false,
              "xaiDescription": "Maps over the stream, applying a function to each chunk."
            }
          },
          {
            "name": "response.filter",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method allows filtering the stream. For each chunk in the stream the *fn* function will be called\nand if it returns a truthy value, the chunk will be passed to the result stream.\nIf the *fn* function returns a promise - that promise will be `await`ed.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to filter chunks from the stream. Async or not."
                }
              ],
              "returns": "a stream filtered with the predicate *fn*.",
              "deprecated": false,
              "xaiDescription": "Filters the stream based on a predicate function."
            }
          },
          {
            "name": "response.forEach",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "This method allows iterating a stream. For each chunk in the stream the *fn* function will be called.\nIf the *fn* function returns a promise - that promise will be `await`ed.\n\nThis method is different from `for await...of` loops in that it can optionally process chunks concurrently.\nIn addition, a `forEach` iteration can only be stopped by having passed a `signal` option\nand aborting the related AbortController while `for await...of` can be stopped with `break` or `return`.\nIn either case the stream will be destroyed.\n\nThis method is different from listening to the `'data'` event in that it uses the `readable` event\nin the underlying machinary and can limit the number of concurrent *fn* calls.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise for when the stream has finished.",
              "deprecated": false,
              "xaiDescription": "Iterates over the stream, calling a function for each chunk."
            }
          },
          {
            "name": "response.toArray",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<any[]>",
            "jsdoc": {
              "description": "This method allows easily obtaining the contents of a stream.\n\nAs this method reads the entire stream into memory, it negates the benefits of streams. It's intended\nfor interoperability and convenience, not as the primary way to consume streams.",
              "params": [],
              "returns": "a promise containing an array with the contents of the stream.",
              "deprecated": false,
              "xaiDescription": "Converts the stream to an array of its contents."
            }
          },
          {
            "name": "response.some",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.some` and calls *fn* on each chunk in the stream\nuntil the awaited return value is `true` (or any truthy value). Once an *fn* call on a chunk\n`await`ed return value is truthy, the stream is destroyed and the promise is fulfilled with `true`.\nIf none of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `false`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for at least one of the chunks.",
              "deprecated": false,
              "xaiDescription": "Checks if any chunk in the stream satisfies a condition."
            }
          },
          {
            "name": "response.find",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.find` and calls *fn* on each chunk in the stream\nto find a chunk with a truthy value for *fn*. Once an *fn* call's awaited return value is truthy,\nthe stream is destroyed and the promise is fulfilled with value for which *fn* returned a truthy value.\nIf all of the *fn* calls on the chunks return a falsy value, the promise is fulfilled with `undefined`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to the first chunk for which *fn* evaluated with a truthy value,\nor `undefined` if no element was found.",
              "deprecated": false,
              "xaiDescription": "Finds the first chunk in the stream satisfying a condition."
            }
          },
          {
            "name": "response.every",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<boolean>",
            "jsdoc": {
              "description": "This method is similar to `Array.prototype.every` and calls *fn* on each chunk in the stream\nto check if all awaited return values are truthy value for *fn*. Once an *fn* call on a chunk\n`await`ed return value is falsy, the stream is destroyed and the promise is fulfilled with `false`.\nIf all of the *fn* calls on the chunks return a truthy value, the promise is fulfilled with `true`.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to call on each chunk of the stream. Async or not."
                }
              ],
              "returns": "a promise evaluating to `true` if *fn* returned a truthy value for every one of the chunks.",
              "deprecated": false,
              "xaiDescription": "Checks if all chunks in the stream satisfy a condition."
            }
          },
          {
            "name": "response.flatMap",
            "parameters": [
              {
                "name": "fn",
                "type": "(data: any, options?: Pick<ArrayOptions, \"signal\">) => any",
                "optional": false
              },
              {
                "name": "options",
                "type": "ArrayOptions",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream by applying the given callback to each chunk of the stream\nand then flattening the result.\n\nIt is possible to return a stream or another iterable or async iterable from *fn* and the result streams\nwill be merged (flattened) into the returned stream.",
              "params": [
                {
                  "name": "fn",
                  "description": "a function to map over every chunk in the stream. May be async. May be a stream or generator."
                }
              ],
              "returns": "a stream flat-mapped with the function *fn*.",
              "deprecated": false,
              "xaiDescription": "Applies a function to each chunk, flattening the result."
            }
          },
          {
            "name": "response.drop",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks dropped from the start.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to drop from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks dropped from the start.",
              "deprecated": false,
              "xaiDescription": "Creates a new stream, dropping the first specified chunks."
            }
          },
          {
            "name": "response.take",
            "parameters": [
              {
                "name": "limit",
                "type": "number",
                "optional": false
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with the first *limit* chunks.",
              "params": [
                {
                  "name": "limit",
                  "description": "the number of chunks to take from the readable."
                }
              ],
              "returns": "a stream with *limit* chunks taken.",
              "deprecated": false,
              "xaiDescription": "Creates a new stream with the first specified chunks."
            }
          },
          {
            "name": "response.asIndexedPairs",
            "parameters": [
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Readable",
            "jsdoc": {
              "description": "This method returns a new stream with chunks of the underlying stream paired with a counter\nin the form `[index, chunk]`. The first index value is `0` and it increases by 1 for each chunk produced.",
              "params": [],
              "returns": "a stream of indexed pairs.",
              "deprecated": false,
              "xaiDescription": "Creates a new stream with chunks paired with an index."
            }
          },
          {
            "name": "response.reduce",
            "parameters": [
              {
                "name": "fn",
                "type": "(previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T",
                "optional": false
              },
              {
                "name": "initial",
                "type": "undefined",
                "optional": true
              },
              {
                "name": "options",
                "type": "Pick<ArrayOptions, \"signal\">",
                "optional": true
              }
            ],
            "returnType": "Promise<T>",
            "jsdoc": {
              "description": "This method calls *fn* on each chunk of the stream in order, passing it the result from the calculation\non the previous element. It returns a promise for the final value of the reduction.\n\nIf no *initial* value is supplied the first chunk of the stream is used as the initial value.\nIf the stream is empty, the promise is rejected with a `TypeError` with the `ERR_INVALID_ARGS` code property.\n\nThe reducer function iterates the stream element-by-element which means that there is no *concurrency* parameter\nor parallelism. To perform a reduce concurrently, you can extract the async function to `readable.map` method.",
              "params": [
                {
                  "name": "fn",
                  "description": "a reducer function to call over every chunk in the stream. Async or not."
                },
                {
                  "name": "initial",
                  "description": "the initial value to use in the reduction."
                }
              ],
              "returns": "a promise for the final value of the reduction.",
              "deprecated": false,
              "xaiDescription": "Reduces the stream to a single value using a function."
            }
          },
          {
            "name": "response._destroy",
            "parameters": [
              {
                "name": "error",
                "type": "Error",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Destroys the stream, calling the callback with any error.",
              "params": [
                {
                  "name": "error",
                  "description": "The error to pass to the callback."
                },
                {
                  "name": "callback",
                  "description": "The callback to call after destruction."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Destroys the stream, calling the callback with any error."
            }
          },
          {
            "name": "response.__@asyncIterator@70027",
            "parameters": [],
            "returnType": "AsyncIterator<any, any, any>",
            "jsdoc": {
              "description": "Creates an async iterator for the readable stream.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Creates an async iterator for the readable stream."
            }
          },
          {
            "name": "response.__@asyncDispose@70029",
            "parameters": [],
            "returnType": "Promise<void>",
            "jsdoc": {
              "description": "Calls `readable.destroy()` with an `AbortError` and returns a promise that fulfills when the stream is finished.",
              "params": [],
              "deprecated": false,
              "xaiDescription": "Destroys the stream with an AbortError, returns a promise."
            }
          },
          {
            "name": "response.pipe",
            "parameters": [
              {
                "name": "destination",
                "type": "T",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ end?: boolean; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "description": "Attaches a writable stream to the readable stream.",
              "params": [
                {
                  "name": "destination",
                  "description": "The writable stream to attach."
                },
                {
                  "name": "options",
                  "description": "Options for the pipe operation."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Attaches a writable stream to the readable stream."
            }
          },
          {
            "name": "response.compose",
            "parameters": [
              {
                "name": "stream",
                "type": "ComposeFnParam | T | Iterable<T> | AsyncIterable<T>",
                "optional": false
              },
              {
                "name": "options",
                "type": "{ signal: AbortSignal; }",
                "optional": true
              }
            ],
            "returnType": "T",
            "jsdoc": {
              "description": "Composes multiple streams into a single stream.",
              "params": [
                {
                  "name": "stream",
                  "description": "The stream or streams to compose."
                },
                {
                  "name": "options",
                  "description": "Options for the composition, including an abort signal."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Composes multiple streams into a single stream."
            }
          },
          {
            "name": "response.toFixed",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string representing a number in fixed-point notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Converts a number to a fixed-point notation string."
            }
          },
          {
            "name": "response.toExponential",
            "parameters": [
              {
                "name": "fractionDigits",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented in exponential notation.",
              "params": [
                {
                  "name": "fractionDigits",
                  "description": "Number of digits after the decimal point. Must be in the range 0 - 20, inclusive."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Converts a number to exponential notation string."
            }
          },
          {
            "name": "response.toPrecision",
            "parameters": [
              {
                "name": "precision",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.",
              "params": [
                {
                  "name": "precision",
                  "description": "Number of significant digits. Must be in the range 1 - 21, inclusive."
                }
              ],
              "deprecated": false,
              "xaiDescription": "Converts a number to a string with specified precision."
            }
          },
          {
            "name": "response.toLocaleString",
            "parameters": [
              {
                "name": "locales",
                "type": "string | string[]",
                "optional": true
              },
              {
                "name": "options",
                "type": "NumberFormatOptions",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Converts a number to a string by using the current or specified locale.",
              "params": [
                {
                  "name": "locales",
                  "description": "A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used."
                },
                {
                  "name": "options",
                  "description": "An object that contains one or more properties that specify comparison options."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.assignSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Assigns a socket to the response. Uses Socket."
          },
          {
            "name": "response.detachSocket",
            "parameters": [
              {
                "name": "socket",
                "type": "Socket",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Detaches a socket from the response. Uses Socket."
          },
          {
            "name": "response.writeContinue",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 100 Continue message to the client, indicating that\nthe request body should be sent. See the `'checkContinue'` event on `Server`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.writeEarlyHints",
            "parameters": [
              {
                "name": "hints",
                "type": "Record<string, string | string[]>",
                "optional": false
              },
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,\nindicating that the user agent can preload/preconnect the linked resources.\nThe `hints` is an object containing the values of headers to be sent with\nearly hints message. The optional `callback` argument will be called when\nthe response message has been written.\n\n**Example**\n\njs\nconst earlyHintsLink = '</styles.css>; rel=preload; as=style';\nresponse.writeEarlyHints({\n  'link': earlyHintsLink,\n});\n\nconst earlyHintsLinks = [\n  '</styles.css>; rel=preload; as=style',\n  '</scripts.js>; rel=preload; as=script',\n];\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n  'x-trace-id': 'id for diagnostics',\n});\n\nconst earlyHintsCallback = () => console.log('early hints message sent');\nresponse.writeEarlyHints({\n  'link': earlyHintsLinks,\n}, earlyHintsCallback);\n",
              "params": [
                {
                  "name": "hints",
                  "description": "An object containing the values of headers"
                },
                {
                  "name": "callback",
                  "description": "Will be called when the response message has been written"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.writeHead",
            "parameters": [
              {
                "name": "statusCode",
                "type": "number",
                "optional": false
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true
              },
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | OutgoingHttpHeader[]",
                "optional": true
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like `404`. The last argument, `headers`, are the response headers.\nOptionally one can give a human-readable `statusMessage` as the second\nargument.\n\n`headers` may be an `Array` where the keys and values are in the same list.\nIt is _not_ a list of tuples. So, the even-numbered offsets are key values,\nand the odd-numbered offsets are the associated values. The array is in the same\nformat as `request.rawHeaders`.\n\nReturns a reference to the `ServerResponse`, so that calls can be chained.\n\njs\nconst body = 'hello world';\nresponse\n  .writeHead(200, {\n    'Content-Length': Buffer.byteLength(body),\n    'Content-Type': 'text/plain',\n  })\n  .end(body);\n\n\nThis method must only be called once on a message and it must\nbe called before `response.end()` is called.\n\nIf `response.write()` or `response.end()` are called before calling\nthis, the implicit/mutable headers will be calculated and call this function.\n\nWhen headers have been set with `response.setHeader()`, they will be merged\nwith any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\nIf this method is called and `response.setHeader()` has not been called,\nit will directly write the supplied header values onto the network channel\nwithout caching internally, and the `response.getHeader()` on the header\nwill not yield the expected result. If progressive population of headers is\ndesired with potential future retrieval and modification, use `response.setHeader()` instead.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.setHeader('X-Foo', 'bar');\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n\n\n`Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js\nwill check whether `Content-Length` and the length of the body which has\nbeen transmitted are equal or not.\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a \\[`Error`\\]\\[\\] being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.writeProcessing",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Sends a HTTP/1.1 102 Processing message to the client, indicating that\nthe request body should be sent.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.destroySoon",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.\nIf the socket is still writable it implicitly calls `socket.end()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.write",
            "parameters": [
              {
                "name": "buffer",
                "type": "string | Uint8Array<ArrayBufferLike>",
                "optional": false
              },
              {
                "name": "cb",
                "type": "(err?: Error) => void",
                "optional": true
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Sends data on the socket. The second parameter specifies the encoding in the\ncase of a string. It defaults to UTF8 encoding.\n\nReturns `true` if the entire data was flushed successfully to the kernel\nbuffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.\n\nThe optional `callback` parameter will be executed when the data is finally\nwritten out, which may not be immediately.\n\nSee `Writable` stream `write()` method for more\ninformation.",
              "params": [
                {
                  "name": "encoding",
                  "description": "Only used when data is `string`."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.resetAndDestroy",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Close the TCP connection by sending an RST packet and destroy the stream.\nIf this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.\nOtherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.\nIf this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setNoDelay",
            "parameters": [
              {
                "name": "noDelay",
                "type": "boolean",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable the use of Nagle's algorithm.\n\nWhen a TCP connection is created, it will have Nagle's algorithm enabled.\n\nNagle's algorithm delays data before it is sent via the network. It attempts\nto optimize throughput at the expense of latency.\n\nPassing `true` for `noDelay` or not passing an argument will disable Nagle's\nalgorithm for the socket. Passing `false` for `noDelay` will enable Nagle's\nalgorithm.",
              "params": [
                {
                  "name": "noDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setKeepAlive",
            "parameters": [
              {
                "name": "enable",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "initialDelay",
                "type": "number",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle socket.\n\nSet `initialDelay` (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default\n(or previous) setting.\n\nEnabling the keep-alive functionality will set the following socket options:\n\n* `SO_KEEPALIVE=1`\n* `TCP_KEEPIDLE=initialDelay`\n* `TCP_KEEPCNT=10`\n* `TCP_KEEPINTVL=1`",
              "params": [
                {
                  "name": "enable"
                },
                {
                  "name": "initialDelay"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.address",
            "parameters": [],
            "returnType": "{} | AddressInfo",
            "jsdoc": {
              "description": "Returns the bound `address`, the address `family` name and `port` of the\nsocket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.unref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Calling `unref()` on a socket will allow the program to exit if this is the only\nactive socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.ref",
            "parameters": [],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).\nIf the socket is `ref`ed calling `ref` again will have no effect.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.end",
            "parameters": [
              {
                "name": "callback",
                "type": "() => void",
                "optional": true
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "Half-closes the socket. i.e., it sends a FIN packet. It is possible the\nserver will still send some data.\n\nSee `writable.end()` for further details.",
              "params": [
                {
                  "name": "encoding",
                  "description": "Only used when data is `string`."
                },
                {
                  "name": "callback",
                  "description": "Optional callback for when the socket is finished."
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response._write",
            "parameters": [
              {
                "name": "chunk",
                "type": "any",
                "optional": false
              },
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Internal method to write data to the response. Uses BufferEncoding."
          },
          {
            "name": "response._writev",
            "parameters": [
              {
                "name": "chunks",
                "type": "{ chunk: any; encoding: BufferEncoding; }[]",
                "optional": false
              },
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Internal method to write multiple chunks to the response. Uses BufferEncoding."
          },
          {
            "name": "response._final",
            "parameters": [
              {
                "name": "callback",
                "type": "(error?: Error) => void",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Internal method called when the response is finished. Uses callback."
          },
          {
            "name": "response.setDefaultEncoding",
            "parameters": [
              {
                "name": "encoding",
                "type": "BufferEncoding",
                "optional": false
              }
            ],
            "returnType": "Socket",
            "jsdoc": {
              "description": "The `writable.setDefaultEncoding()` method sets the default `encoding` for a `Writable` stream.",
              "params": [
                {
                  "name": "encoding",
                  "description": "The new default encoding"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.cork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.cork()` method forces all written data to be buffered in memory.\nThe buffered data will be flushed when either the    or    methods are called.\n\nThe primary intent of `writable.cork()` is to accommodate a situation in which\nseveral small chunks are written to the stream in rapid succession. Instead of\nimmediately forwarding them to the underlying destination, `writable.cork()` buffers all the chunks until `writable.uncork()` is called, which will pass them\nall to `writable._writev()`, if present. This prevents a head-of-line blocking\nsituation where data is being buffered while waiting for the first small chunk\nto be processed. However, use of `writable.cork()` without implementing `writable._writev()` may have an adverse effect on throughput.\n\nSee also: `writable.uncork()`, `writable._writev()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.uncork",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "The `writable.uncork()` method flushes all data buffered since    was called.\n\nWhen using `writable.cork()` and `writable.uncork()` to manage the buffering\nof writes to a stream, defer calls to `writable.uncork()` using `process.nextTick()`. Doing so allows batching of all `writable.write()` calls that occur within a given Node.js event\nloop phase.\n\njs\nstream.cork();\nstream.write('some ');\nstream.write('data ');\nprocess.nextTick(() => stream.uncork());\n\n\nIf the `writable.cork()` method is called multiple times on a stream, the\nsame number of calls to `writable.uncork()` must be called to flush the buffered\ndata.\n\njs\nstream.cork();\nstream.write('some ');\nstream.cork();\nstream.write('data ');\nprocess.nextTick(() => {\n  stream.uncork();\n  // The data will not be flushed until uncork() is called a second time.\n  stream.uncork();\n});\n\n\nSee also: `writable.cork()`.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.setHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | number | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets a single header value. If the header already exists in the to-be-sent\nheaders, its value will be replaced. Use an array of strings to send multiple\nheaders with the same name.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.setHeaders",
            "parameters": [
              {
                "name": "headers",
                "type": "Headers | Map<string, string | number | readonly string[]>",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Sets multiple header values for implicit headers. headers must be an instance of\n`Headers` or `Map`, if a header already exists in the to-be-sent headers, its\nvalue will be replaced.\n\njs\nconst headers = new Headers({ foo: 'bar' });\noutgoingMessage.setHeaders(headers);\n\n\nor\n\njs\nconst headers = new Map([['foo', 'bar']]);\noutgoingMessage.setHeaders(headers);\n\n\nWhen headers have been set with `outgoingMessage.setHeaders()`, they will be\nmerged with any headers passed to `response.writeHead()`, with the headers passed\nto `response.writeHead()` given precedence.\n\njs\n// Returns content-type = text/plain\nconst server = http.createServer((req, res) => {\n  const headers = new Headers({ 'Content-Type': 'text/html' });\n  res.setHeaders(headers);\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('ok');\n});\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.appendHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              },
              {
                "name": "value",
                "type": "string | readonly string[]",
                "optional": false
              }
            ],
            "returnType": "Response<any, Record<string, any>>",
            "jsdoc": {
              "description": "Append a single header value to the header object.\n\nIf the value is an array, this is equivalent to calling this method multiple\ntimes.\n\nIf there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.\n\nDepending of the value of `options.uniqueHeaders` when the client request or the\nserver were created, this will end up in the header being sent multiple times or\na single time with values joined using `; `.",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                },
                {
                  "name": "value",
                  "description": "Header value"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string | number | string[]",
            "jsdoc": {
              "description": "Gets the value of the HTTP header with the given name. If that header is not\nset, the returned value will be `undefined`.",
              "params": [
                {
                  "name": "name",
                  "description": "Name of header"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeaders",
            "parameters": [],
            "returnType": "OutgoingHttpHeaders",
            "jsdoc": {
              "description": "Returns a shallow copy of the current outgoing headers. Since a shallow\ncopy is used, array values may be mutated without additional calls to\nvarious header-related HTTP module methods. The keys of the returned\nobject are the header names and the values are the respective header\nvalues. All header names are lowercase.\n\nThe object returned by the `outgoingMessage.getHeaders()` method does\nnot prototypically inherit from the JavaScript `Object`. This means that\ntypical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,\nand others are not defined and will not work.\n\njs\noutgoingMessage.setHeader('Foo', 'bar');\noutgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);\n\nconst headers = outgoingMessage.getHeaders();\n// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.getHeaderNames",
            "parameters": [],
            "returnType": "string[]",
            "jsdoc": {
              "description": "Returns an array containing the unique names of the current outgoing headers.\nAll names are lowercase.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.hasHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": {
              "description": "Returns `true` if the header identified by `name` is currently set in the\noutgoing headers. The header name is case-insensitive.\n\njs\nconst hasContentType = outgoingMessage.hasHeader('content-type');\n",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.removeHeader",
            "parameters": [
              {
                "name": "name",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Removes a header that is queued for implicit sending.\n\njs\noutgoingMessage.removeHeader('Content-Encoding');\n",
              "params": [
                {
                  "name": "name",
                  "description": "Header name"
                }
              ],
              "deprecated": false
            }
          },
          {
            "name": "response.addTrailers",
            "parameters": [
              {
                "name": "headers",
                "type": "OutgoingHttpHeaders | readonly [string, string][]",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Adds HTTP trailers (headers but at the end of the message) to the message.\n\nTrailers will **only** be emitted if the message is chunked encoded. If not,\nthe trailers will be silently discarded.\n\nHTTP requires the `Trailer` header to be sent to emit trailers,\nwith a list of header field names in its value, e.g.\n\njs\nmessage.writeHead(200, { 'Content-Type': 'text/plain',\n                         'Trailer': 'Content-MD5' });\nmessage.write(fileData);\nmessage.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });\nmessage.end();\n\n\nAttempting to set a header field name or value that contains invalid characters\nwill result in a `TypeError` being thrown.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "response.flushHeaders",
            "parameters": [],
            "returnType": "void",
            "jsdoc": {
              "description": "Flushes the message headers.\n\nFor efficiency reason, Node.js normally buffers the message headers\nuntil `outgoingMessage.end()` is called or the first chunk of message data\nis written. It then tries to pack the headers and data into a single TCP\npacket.\n\nIt is usually desired (it saves a TCP round-trip), but not when the first\ndata is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.",
              "params": [],
              "deprecated": false
            }
          },
          {
            "name": "static",
            "parameters": [
              {
                "name": "root",
                "type": "string",
                "optional": false
              },
              {
                "name": "options",
                "type": "ServeStaticOptions<Response<any, Record<string, any>>>",
                "optional": true
              }
            ],
            "returnType": "RequestHandler<Response<any, Record<string, any>>>",
            "jsdoc": null,
            "xaiDescription": "Serves static files from the given root directory. Uses ServeStaticOptions."
          },
          {
            "name": "static.lookup",
            "parameters": [
              {
                "name": "path",
                "type": "string",
                "optional": false
              },
              {
                "name": "fallback",
                "type": "string",
                "optional": true
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Look up a mime type based on extension.\n\nIf not found, uses the fallback argument if provided, and otherwise\nuses `default_type`.",
              "deprecated": false
            }
          },
          {
            "name": "static.extension",
            "parameters": [
              {
                "name": "mime",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "string",
            "jsdoc": {
              "description": "Return a file extensions associated with a mime type.",
              "deprecated": false
            }
          },
          {
            "name": "static.load",
            "parameters": [
              {
                "name": "filepath",
                "type": "string",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": {
              "description": "Load an Apache2-style \".types\" file.",
              "deprecated": false
            }
          },
          {
            "name": "static.define",
            "parameters": [
              {
                "name": "mimes",
                "type": "TypeMap",
                "optional": false
              }
            ],
            "returnType": "void",
            "jsdoc": null,
            "xaiDescription": "Defines MIME types. Uses TypeMap."
          },
          {
            "name": "urlencoded",
            "parameters": [
              {
                "name": "options",
                "type": "OptionsUrlencoded",
                "optional": true
              }
            ],
            "returnType": "NextHandleFunction",
            "jsdoc": null,
            "xaiDescription": "Parses URL-encoded bodies. Uses OptionsUrlencoded."
          }
        ],
        "enums": [],
        "types": [],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": true
    },
    {
      "name": "e",
      "contents": {
        "functions": [
          {
            "name": "e.Router",
            "parameters": [
              {
                "name": "options",
                "type": "RouterOptions",
                "optional": true
              }
            ],
            "returnType": "Router",
            "jsdoc": {
              "xaiDescription": "Creates a new router instance. Uses RouterOptions."
            }
          }
        ],
        "enums": [],
        "types": [
          {
            "name": "RouterOptions",
            "type": "RouterOptions",
            "properties": [
              {
                "name": "caseSensitive",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "mergeParams",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "strict",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [],
            "jsdoc": {
              "xaiDescription": "Options for configuring a router. Used in e.Router."
            },
            "isExported": false
          },
          {
            "name": "Application",
            "type": "Application",
            "properties": [
              {
                "name": "init",
                "type": "() => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Initializes the application."
                }
              },
              {
                "name": "defaultConfiguration",
                "type": "() => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets default configuration for the application."
                }
              },
              {
                "name": "engine",
                "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Registers a template engine for rendering views."
                }
              },
              {
                "name": "set",
                "type": "(setting: string, val: any) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets a value for an application setting."
                }
              },
              {
                "name": "get",
                "type": "((name: string) => any) & IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets a value for an application setting or matches a route."
                }
              },
              {
                "name": "param",
                "type": "(name: string | string[], handler: RequestParamHandler) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a middleware function for named route parameters."
                }
              },
              {
                "name": "path",
                "type": "() => string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns the path of the application."
                }
              },
              {
                "name": "enabled",
                "type": "(setting: string) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if a setting is enabled."
                }
              },
              {
                "name": "disabled",
                "type": "(setting: string) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if a setting is disabled."
                }
              },
              {
                "name": "enable",
                "type": "(setting: string) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Enables a setting."
                }
              },
              {
                "name": "disable",
                "type": "(setting: string) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Disables a setting."
                }
              },
              {
                "name": "render",
                "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Renders a view with optional data and callback."
                }
              },
              {
                "name": "listen",
                "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Starts the server listening for connections."
                }
              },
              {
                "name": "router",
                "type": "Router",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The router instance for the application."
                }
              },
              {
                "name": "settings",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Application settings."
                }
              },
              {
                "name": "resource",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Resource-related functionality."
                }
              },
              {
                "name": "map",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Mapping functionality."
                }
              },
              {
                "name": "locals",
                "type": "Record<string, any> & Locals",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Locals object for view rendering."
                }
              },
              {
                "name": "routes",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Routes of the application."
                }
              },
              {
                "name": "_router",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Internal router instance."
                }
              },
              {
                "name": "use",
                "type": "ApplicationRequestHandler<Application>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Mounts middleware functions."
                }
              },
              {
                "name": "on",
                "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds an event listener to the application."
                }
              },
              {
                "name": "mountpath",
                "type": "string | string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The mount path of the application."
                }
              },
              {
                "name": "__@captureRejectionSymbol@69398",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "Internal method for capturing rejections."
                }
              },
              {
                "name": "addListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener for an event."
                }
              },
              {
                "name": "once",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a one-time listener for an event."
                }
              },
              {
                "name": "removeListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes a listener for an event."
                }
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Alias for removeListener."
                }
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes all listeners for an event."
                }
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets the maximum number of listeners."
                }
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the maximum number of listeners."
                }
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of listeners for an event."
                }
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of raw listeners for an event."
                }
              },
              {
                "name": "emit",
                "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Emits an event with optional arguments."
                }
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns the number of listeners for an event."
                }
              },
              {
                "name": "prependListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener to the beginning of the listeners array."
                }
              },
              {
                "name": "prependOnceListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Application",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a one-time listener to the beginning of the listeners array."
                }
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of event names."
                }
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Application, \"all\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches all HTTP methods for a route."
                }
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Application, \"post\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches POST requests for a route."
                }
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Application, \"put\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PUT requests for a route."
                }
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Application, \"delete\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches DELETE requests for a route."
                }
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Application, \"patch\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PATCH requests for a route."
                }
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Application, \"options\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches OPTIONS requests for a route."
                }
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Application, \"head\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches HEAD requests for a route."
                }
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CHECKOUT requests for a route."
                }
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CONNECT requests for a route."
                }
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches COPY requests for a route."
                }
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LOCK requests for a route."
                }
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MERGE requests for a route."
                }
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKACTIVITY requests for a route."
                }
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKCOL requests for a route."
                }
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MOVE requests for a route."
                }
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches M-SEARCH requests for a route."
                }
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches NOTIFY requests for a route."
                }
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPFIND requests for a route."
                }
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPPATCH requests for a route."
                }
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PURGE requests for a route."
                }
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches REPORT requests for a route."
                }
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SEARCH requests for a route."
                }
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SUBSCRIBE requests for a route."
                }
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches TRACE requests for a route."
                }
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLOCK requests for a route."
                }
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNSUBSCRIBE requests for a route."
                }
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LINK requests for a route."
                }
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Application, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLINK requests for a route."
                }
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Creates a new route with a specified prefix."
                }
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Array of middleware layers."
                }
              }
            ],
            "extends": [
              "core.Application"
            ],
            "jsdoc": {
              "xaiDescription": "Represents an Express application. Extends core.Application."
            },
            "isExported": false
          },
          {
            "name": "CookieOptions",
            "type": "CookieOptions",
            "properties": [
              {
                "name": "maxAge",
                "type": "number",
                "optional": true
              },
              {
                "name": "signed",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "expires",
                "type": "Date",
                "optional": true
              },
              {
                "name": "httpOnly",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "path",
                "type": "string",
                "optional": true
              },
              {
                "name": "domain",
                "type": "string",
                "optional": true
              },
              {
                "name": "secure",
                "type": "boolean",
                "optional": true
              },
              {
                "name": "encode",
                "type": "(val: string) => string",
                "optional": true
              },
              {
                "name": "sameSite",
                "type": "boolean | \"lax\" | \"strict\" | \"none\"",
                "optional": true
              },
              {
                "name": "priority",
                "type": "\"low\" | \"medium\" | \"high\"",
                "optional": true
              },
              {
                "name": "partitioned",
                "type": "boolean",
                "optional": true
              }
            ],
            "extends": [
              "core.CookieOptions"
            ],
            "jsdoc": {
              "xaiDescription": "Options for setting cookies. Extends core.CookieOptions."
            },
            "isExported": false
          },
          {
            "name": "Errback",
            "type": "Errback",
            "properties": [],
            "extends": [
              "core.Errback"
            ],
            "jsdoc": {
              "xaiDescription": "Callback function for handling errors. Extends core.Errback."
            },
            "isExported": false
          },
          {
            "name": "ErrorRequestHandler",
            "type": "ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [],
            "extends": [
              "core.ErrorRequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": {
              "xaiDescription": "Middleware function for handling errors. Extends core.ErrorRequestHandler."
            },
            "isExported": false
          },
          {
            "name": "Express",
            "type": "Express",
            "properties": [
              {
                "name": "request",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request object for the Express application."
                }
              },
              {
                "name": "response",
                "type": "Response<any, Record<string, any>, number>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The response object for the Express application."
                }
              },
              {
                "name": "init",
                "type": "() => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Initializes the Express application."
                }
              },
              {
                "name": "defaultConfiguration",
                "type": "() => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets default configuration for the Express application."
                }
              },
              {
                "name": "engine",
                "type": "(ext: string, fn: (path: string, options: object, callback: (e: any, rendered?: string) => void) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Registers a template engine for rendering views in Express."
                }
              },
              {
                "name": "set",
                "type": "(setting: string, val: any) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets a value for an Express application setting."
                }
              },
              {
                "name": "get",
                "type": "((name: string) => any) & IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets a value for an Express application setting or matches a route."
                }
              },
              {
                "name": "param",
                "type": "(name: string | string[], handler: RequestParamHandler) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a middleware function for named route parameters in Express."
                }
              },
              {
                "name": "path",
                "type": "() => string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns the path of the Express application."
                }
              },
              {
                "name": "enabled",
                "type": "(setting: string) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if a setting is enabled in Express."
                }
              },
              {
                "name": "disabled",
                "type": "(setting: string) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if a setting is disabled in Express."
                }
              },
              {
                "name": "enable",
                "type": "(setting: string) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Enables a setting in Express."
                }
              },
              {
                "name": "disable",
                "type": "(setting: string) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Disables a setting in Express."
                }
              },
              {
                "name": "render",
                "type": "{ (name: string, options?: object, callback?: (err: Error, html: string) => void): void; (name: string, callback: (err: Error, html: string) => void): void; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Renders a view with optional data and callback in Express."
                }
              },
              {
                "name": "listen",
                "type": "{ (port: number, hostname: string, backlog: number, callback?: (error?: Error) => void): Server<typeof IncomingMessage, typeof ServerResponse>; (port: number, hostname: string, callback?: (error?: Error) => void): Server<...>; (port: number, callback?: (error?: Error) => void): Server<...>; (callback?: (error?: Erro...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Starts the Express server listening for connections."
                }
              },
              {
                "name": "router",
                "type": "Router",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The router instance for the Express application."
                }
              },
              {
                "name": "settings",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Express application settings."
                }
              },
              {
                "name": "resource",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Resource-related functionality in Express."
                }
              },
              {
                "name": "map",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Mapping functionality in Express."
                }
              },
              {
                "name": "locals",
                "type": "Record<string, any> & Locals",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Locals object for view rendering in Express."
                }
              },
              {
                "name": "routes",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Routes of the Express application."
                }
              },
              {
                "name": "_router",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Internal router instance in Express."
                }
              },
              {
                "name": "use",
                "type": "ApplicationRequestHandler<Express>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Mounts middleware functions in Express."
                }
              },
              {
                "name": "on",
                "type": "(event: string, callback: (parent: Application<Record<string, any>>) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds an event listener to the Express application."
                }
              },
              {
                "name": "mountpath",
                "type": "string | string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The mount path of the Express application."
                }
              },
              {
                "name": "__@captureRejectionSymbol@69398",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "Internal method for capturing rejections in Express."
                }
              },
              {
                "name": "addListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener for an event in Express."
                }
              },
              {
                "name": "once",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a one-time listener for an event in Express."
                }
              },
              {
                "name": "removeListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes a listener for an event in Express."
                }
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Alias for removeListener in Express."
                }
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes all listeners for an event in Express."
                }
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets the maximum number of listeners in Express."
                }
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the maximum number of listeners in Express."
                }
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of listeners for an event in Express."
                }
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of raw listeners for an event in Express."
                }
              },
              {
                "name": "emit",
                "type": "<K>(eventName: string | symbol, ...args: AnyRest) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Emits an event with optional arguments in Express."
                }
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns the number of listeners for an event in Express."
                }
              },
              {
                "name": "prependListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener to the beginning of the listeners array in Express."
                }
              },
              {
                "name": "prependOnceListener",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Express",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a one-time listener to the beginning of the listeners array in Express."
                }
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Returns an array of event names in Express."
                }
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Express, \"all\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches all HTTP methods for a route in Express."
                }
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Express, \"post\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches POST requests for a route in Express."
                }
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Express, \"put\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PUT requests for a route in Express."
                }
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Express, \"delete\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches DELETE requests for a route in Express."
                }
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Express, \"patch\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PATCH requests for a route in Express."
                }
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Express, \"options\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches OPTIONS requests for a route in Express."
                }
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Express, \"head\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches HEAD requests for a route in Express."
                }
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CHECKOUT requests for a route in Express."
                }
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CONNECT requests for a route in Express."
                }
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches COPY requests for a route in Express."
                }
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LOCK requests for a route in Express."
                }
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MERGE requests for a route in Express."
                }
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKACTIVITY requests for a route in Express."
                }
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKCOL requests for a route in Express."
                }
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MOVE requests for a route in Express."
                }
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches M-SEARCH requests for a route in Express."
                }
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches NOTIFY requests for a route in Express."
                }
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPFIND requests for a route in Express."
                }
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPPATCH requests for a route in Express."
                }
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PURGE requests for a route in Express."
                }
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches REPORT requests for a route in Express."
                }
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SEARCH requests for a route in Express."
                }
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SUBSCRIBE requests for a route in Express."
                }
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches TRACE requests for a route in Express."
                }
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLOCK requests for a route in Express."
                }
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNSUBSCRIBE requests for a route in Express."
                }
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LINK requests for a route in Express."
                }
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Express, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLINK requests for a route in Express."
                }
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Creates a new route with a specified prefix in Express."
                }
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Array of middleware layers in Express."
                }
              }
            ],
            "extends": [
              "core.Express"
            ],
            "jsdoc": {
              "xaiDescription": "Represents an Express application. Extends core.Express."
            },
            "isExported": false
          },
          {
            "name": "Handler",
            "type": "Handler",
            "properties": [],
            "extends": [
              "core.Handler"
            ],
            "jsdoc": {
              "xaiDescription": "Middleware function for handling requests. Extends core.Handler."
            },
            "isExported": false
          },
          {
            "name": "IRoute",
            "type": "IRoute",
            "properties": [
              {
                "name": "path",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The path of the route."
                }
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Array of middleware layers for the route."
                }
              },
              {
                "name": "all",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches all HTTP methods for the route."
                }
              },
              {
                "name": "get",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches GET requests for the route."
                }
              },
              {
                "name": "post",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches POST requests for the route."
                }
              },
              {
                "name": "put",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PUT requests for the route."
                }
              },
              {
                "name": "delete",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches DELETE requests for the route."
                }
              },
              {
                "name": "patch",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PATCH requests for the route."
                }
              },
              {
                "name": "options",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches OPTIONS requests for the route."
                }
              },
              {
                "name": "head",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches HEAD requests for the route."
                }
              },
              {
                "name": "checkout",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CHECKOUT requests for the route."
                }
              },
              {
                "name": "copy",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches COPY requests for the route."
                }
              },
              {
                "name": "lock",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LOCK requests for the route."
                }
              },
              {
                "name": "merge",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MERGE requests for the route."
                }
              },
              {
                "name": "mkactivity",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKACTIVITY requests for the route."
                }
              },
              {
                "name": "mkcol",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKCOL requests for the route."
                }
              },
              {
                "name": "move",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MOVE requests for the route."
                }
              },
              {
                "name": "m-search",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches M-SEARCH requests for the route."
                }
              },
              {
                "name": "notify",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches NOTIFY requests for the route."
                }
              },
              {
                "name": "purge",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PURGE requests for the route."
                }
              },
              {
                "name": "report",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches REPORT requests for the route."
                }
              },
              {
                "name": "search",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SEARCH requests for the route."
                }
              },
              {
                "name": "subscribe",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SUBSCRIBE requests for the route."
                }
              },
              {
                "name": "trace",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches TRACE requests for the route."
                }
              },
              {
                "name": "unlock",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLOCK requests for the route."
                }
              },
              {
                "name": "unsubscribe",
                "type": "IRouterHandler<IRoute, string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNSUBSCRIBE requests for the route."
                }
              }
            ],
            "extends": [
              "core.IRoute"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a route. Extends core.IRoute."
            },
            "isExported": false
          },
          {
            "name": "IRouter",
            "type": "IRouter",
            "properties": [
              {
                "name": "param",
                "type": "(name: string, handler: RequestParamHandler) => IRouter",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a middleware function for named route parameters."
                }
              },
              {
                "name": "all",
                "type": "IRouterMatcher<IRouter, \"all\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches all HTTP methods for a route."
                }
              },
              {
                "name": "get",
                "type": "IRouterMatcher<IRouter, \"get\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches GET requests for a route."
                }
              },
              {
                "name": "post",
                "type": "IRouterMatcher<IRouter, \"post\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches POST requests for a route."
                }
              },
              {
                "name": "put",
                "type": "IRouterMatcher<IRouter, \"put\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PUT requests for a route."
                }
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<IRouter, \"delete\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches DELETE requests for a route."
                }
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<IRouter, \"patch\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PATCH requests for a route."
                }
              },
              {
                "name": "options",
                "type": "IRouterMatcher<IRouter, \"options\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches OPTIONS requests for a route."
                }
              },
              {
                "name": "head",
                "type": "IRouterMatcher<IRouter, \"head\">",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches HEAD requests for a route."
                }
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CHECKOUT requests for a route."
                }
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches CONNECT requests for a route."
                }
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches COPY requests for a route."
                }
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LOCK requests for a route."
                }
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MERGE requests for a route."
                }
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKACTIVITY requests for a route."
                }
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MKCOL requests for a route."
                }
              },
              {
                "name": "move",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches MOVE requests for a route."
                }
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches M-SEARCH requests for a route."
                }
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches NOTIFY requests for a route."
                }
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPFIND requests for a route."
                }
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PROPPATCH requests for a route."
                }
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches PURGE requests for a route."
                }
              },
              {
                "name": "report",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches REPORT requests for a route."
                }
              },
              {
                "name": "search",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SEARCH requests for a route."
                }
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches SUBSCRIBE requests for a route."
                }
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches TRACE requests for a route."
                }
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLOCK requests for a route."
                }
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNSUBSCRIBE requests for a route."
                }
              },
              {
                "name": "link",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches LINK requests for a route."
                }
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Matches UNLINK requests for a route."
                }
              },
              {
                "name": "use",
                "type": "IRouterHandler<IRouter, string> & IRouterMatcher<IRouter, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Mounts middleware functions or matches a route."
                }
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Creates a new route with a specified prefix."
                }
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Array of middleware layers."
                }
              }
            ],
            "extends": [
              "core.IRouter"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a router. Extends core.IRouter."
            },
            "isExported": false
          },
          {
            "name": "IRouterHandler",
            "type": "IRouterHandler<T>",
            "properties": [],
            "extends": [
              "core.IRouterHandler<T>"
            ],
            "jsdoc": {
              "xaiDescription": "Middleware function for handling routes. Extends core.IRouterHandler."
            },
            "isExported": false
          },
          {
            "name": "IRouterMatcher",
            "type": "IRouterMatcher<T>",
            "properties": [],
            "extends": [
              "core.IRouterMatcher<T>"
            ],
            "jsdoc": {
              "xaiDescription": "Function for matching routes. Extends core.IRouterMatcher."
            },
            "isExported": false
          },
          {
            "name": "MediaType",
            "type": "MediaType",
            "properties": [
              {
                "name": "value",
                "type": "string",
                "optional": false
              },
              {
                "name": "quality",
                "type": "number",
                "optional": false
              },
              {
                "name": "type",
                "type": "string",
                "optional": false
              },
              {
                "name": "subtype",
                "type": "string",
                "optional": false
              }
            ],
            "extends": [
              "core.MediaType"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a media type with value, quality, type, and subtype."
            },
            "isExported": false
          },
          {
            "name": "NextFunction",
            "type": "NextFunction",
            "properties": [],
            "extends": [
              "core.NextFunction"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a function to be called to pass control to the next middleware."
            },
            "isExported": false
          },
          {
            "name": "Locals",
            "type": "Locals",
            "properties": [],
            "extends": [
              "core.Locals"
            ],
            "jsdoc": {
              "xaiDescription": "Represents local variables for a request."
            },
            "isExported": false
          },
          {
            "name": "Request",
            "type": "Request<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [
              {
                "name": "get",
                "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the value of a header. Uses string[] for 'set-cookie'."
                }
              },
              {
                "name": "header",
                "type": "{ (name: \"set-cookie\"): string[]; (name: string): string; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the value of a header. Uses string[] for 'set-cookie'."
                }
              },
              {
                "name": "accepts",
                "type": "{ (): string[]; (type: string): string | false; (type: string[]): string | false; (...type: string[]): string | false; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the client accepts the given type(s)."
                }
              },
              {
                "name": "acceptsCharsets",
                "type": "{ (): string[]; (charset: string): string | false; (charset: string[]): string | false; (...charset: string[]): string | false; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the client accepts the given charset(s)."
                }
              },
              {
                "name": "acceptsEncodings",
                "type": "{ (): string[]; (encoding: string): string | false; (encoding: string[]): string | false; (...encoding: string[]): string | false; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the client accepts the given encoding(s)."
                }
              },
              {
                "name": "acceptsLanguages",
                "type": "{ (): string[]; (lang: string): string | false; (lang: string[]): string | false; (...lang: string[]): string | false; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the client accepts the given language(s)."
                }
              },
              {
                "name": "range",
                "type": "(size: number, options?: Options) => Ranges | Result",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Parses the Range header. Uses Options, Ranges, Result."
                }
              },
              {
                "name": "accepted",
                "type": "MediaType[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "List of accepted media types. Uses MediaType[]."
                }
              },
              {
                "name": "is",
                "type": "(type: string | string[]) => string | false",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the request is of the given type(s)."
                }
              },
              {
                "name": "protocol",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request protocol (e.g., 'http', 'https')."
                }
              },
              {
                "name": "secure",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request is secure (HTTPS)."
                }
              },
              {
                "name": "ip",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The remote IP address of the request."
                }
              },
              {
                "name": "ips",
                "type": "string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "List of IP addresses from X-Forwarded-For header."
                }
              },
              {
                "name": "subdomains",
                "type": "string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "List of subdomains in the request's host."
                }
              },
              {
                "name": "path",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request path."
                }
              },
              {
                "name": "hostname",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request hostname."
                }
              },
              {
                "name": "host",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request host."
                }
              },
              {
                "name": "fresh",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request is fresh (not modified)."
                }
              },
              {
                "name": "stale",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request is stale (modified)."
                }
              },
              {
                "name": "xhr",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request is an XHR (XMLHttpRequest)."
                }
              },
              {
                "name": "body",
                "type": "ReqBody",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request body. Uses ReqBody."
                }
              },
              {
                "name": "cookies",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request cookies."
                }
              },
              {
                "name": "method",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request method (e.g., 'GET', 'POST')."
                }
              },
              {
                "name": "params",
                "type": "P",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The route parameters. Uses P."
                }
              },
              {
                "name": "query",
                "type": "ReqQuery",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The query string parameters. Uses ReqQuery."
                }
              },
              {
                "name": "route",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The route object."
                }
              },
              {
                "name": "signedCookies",
                "type": "any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The signed cookies."
                }
              },
              {
                "name": "originalUrl",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The original request URL."
                }
              },
              {
                "name": "url",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request URL."
                }
              },
              {
                "name": "baseUrl",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The base URL of the request."
                }
              },
              {
                "name": "app",
                "type": "Application<Record<string, any>>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The application instance. Uses Application<Record<string, any>>."
                }
              },
              {
                "name": "res",
                "type": "Response<ResBody, Locals, number>",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "The response object. Uses Response<ResBody, Locals, number>."
                }
              },
              {
                "name": "next",
                "type": "NextFunction",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "The next middleware function. Uses NextFunction."
                }
              },
              {
                "name": "aborted",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request was aborted."
                }
              },
              {
                "name": "httpVersion",
                "type": "string",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The HTTP version of the request."
                }
              },
              {
                "name": "httpVersionMajor",
                "type": "number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The major version of the HTTP protocol."
                }
              },
              {
                "name": "httpVersionMinor",
                "type": "number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The minor version of the HTTP protocol."
                }
              },
              {
                "name": "complete",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the request is complete."
                }
              },
              {
                "name": "connection",
                "type": "Socket",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The underlying socket. Uses Socket."
                }
              },
              {
                "name": "socket",
                "type": "Socket",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The underlying socket. Uses Socket."
                }
              },
              {
                "name": "headers",
                "type": "IncomingHttpHeaders",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request headers. Uses IncomingHttpHeaders."
                }
              },
              {
                "name": "headersDistinct",
                "type": "Dict<string[]>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The distinct headers. Uses Dict<string[]>."
                }
              },
              {
                "name": "rawHeaders",
                "type": "string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The raw request headers."
                }
              },
              {
                "name": "trailers",
                "type": "Dict<string>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The request trailers. Uses Dict<string>."
                }
              },
              {
                "name": "trailersDistinct",
                "type": "Dict<string[]>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The distinct trailers. Uses Dict<string[]>."
                }
              },
              {
                "name": "rawTrailers",
                "type": "string[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The raw request trailers."
                }
              },
              {
                "name": "setTimeout",
                "type": "(msecs: number, callback?: () => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets a timeout for the request. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "statusCode",
                "type": "number",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "The response status code."
                }
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "The response status message."
                }
              },
              {
                "name": "destroy",
                "type": "(error?: Error) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Destroys the request. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "readableAborted",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the readable stream was aborted."
                }
              },
              {
                "name": "readable",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the stream is readable."
                }
              },
              {
                "name": "readableDidRead",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the stream has been read."
                }
              },
              {
                "name": "readableEncoding",
                "type": "BufferEncoding",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The encoding of the readable stream. Uses BufferEncoding."
                }
              },
              {
                "name": "readableEnded",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the readable stream has ended."
                }
              },
              {
                "name": "readableFlowing",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the readable stream is flowing."
                }
              },
              {
                "name": "readableHighWaterMark",
                "type": "number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The high water mark of the readable stream."
                }
              },
              {
                "name": "readableLength",
                "type": "number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The length of the readable stream."
                }
              },
              {
                "name": "readableObjectMode",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the readable stream is in object mode."
                }
              },
              {
                "name": "destroyed",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the stream has been destroyed."
                }
              },
              {
                "name": "closed",
                "type": "boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "True if the stream has been closed."
                }
              },
              {
                "name": "errored",
                "type": "Error",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "The error that caused the stream to error. Uses Error."
                }
              },
              {
                "name": "_construct",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "Constructs the stream. Uses Error."
                }
              },
              {
                "name": "_read",
                "type": "(size: number) => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Reads data from the stream."
                }
              },
              {
                "name": "read",
                "type": "(size?: number) => any",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Reads data from the stream."
                }
              },
              {
                "name": "setEncoding",
                "type": "(encoding: BufferEncoding) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets the encoding of the stream. Uses BufferEncoding, Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "pause",
                "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Pauses the stream. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "resume",
                "type": "() => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Resumes the stream. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "isPaused",
                "type": "() => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if the stream is paused."
                }
              },
              {
                "name": "unpipe",
                "type": "(destination?: WritableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Unpipes the stream. Uses WritableStream, Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "unshift",
                "type": "(chunk: any, encoding?: BufferEncoding) => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Unshifts a chunk back into the stream. Uses BufferEncoding."
                }
              },
              {
                "name": "wrap",
                "type": "(stream: ReadableStream) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Wraps a readable stream. Uses ReadableStream, Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "push",
                "type": "(chunk: any, encoding?: BufferEncoding) => boolean",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Pushes a chunk into the stream. Uses BufferEncoding."
                }
              },
              {
                "name": "iterator",
                "type": "(options?: { destroyOnReturn?: boolean; }) => AsyncIterator<any, any, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Creates an async iterator for the stream. Uses AsyncIterator<any, any, any>."
                }
              },
              {
                "name": "map",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Maps over the stream. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "filter",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Filters the stream. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "forEach",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => void | Promise<void>, options?: ArrayOptions) => Promise<void>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Iterates over the stream. Uses ArrayOptions."
                }
              },
              {
                "name": "toArray",
                "type": "(options?: Pick<ArrayOptions, \"signal\">) => Promise<any[]>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Converts the stream to an array. Uses ArrayOptions."
                }
              },
              {
                "name": "some",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if any element in the stream satisfies the condition. Uses ArrayOptions."
                }
              },
              {
                "name": "find",
                "type": "{ <T>(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => data is T, options?: ArrayOptions): Promise<T>; (fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<...>, options?: ArrayOptions): Promise<...>; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Finds an element in the stream. Uses ArrayOptions."
                }
              },
              {
                "name": "every",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => boolean | Promise<boolean>, options?: ArrayOptions) => Promise<boolean>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Checks if all elements in the stream satisfy the condition. Uses ArrayOptions."
                }
              },
              {
                "name": "flatMap",
                "type": "(fn: (data: any, options?: Pick<ArrayOptions, \"signal\">) => any, options?: ArrayOptions) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Flattens and maps the stream. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "drop",
                "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Drops the first 'limit' elements from the stream. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "take",
                "type": "(limit: number, options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Takes the first 'limit' elements from the stream. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "asIndexedPairs",
                "type": "(options?: Pick<ArrayOptions, \"signal\">) => Readable",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Converts the stream to indexed pairs. Uses ArrayOptions, Readable."
                }
              },
              {
                "name": "reduce",
                "type": "{ <T = any>(fn: (previous: any, data: any, options?: Pick<ArrayOptions, \"signal\">) => T, initial?: undefined, options?: Pick<ArrayOptions, \"signal\">): Promise<...>; <T = any>(fn: (previous: T, data: any, options?: Pick<...>) => T, initial: T, options?: Pick<...>): Promise<...>; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Reduces the stream. Uses ArrayOptions."
                }
              },
              {
                "name": "_destroy",
                "type": "(error: Error, callback: (error?: Error) => void) => void",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Destroys the stream. Uses Error."
                }
              },
              {
                "name": "addListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "emit",
                "type": "{ (event: \"close\"): boolean; (event: \"data\", chunk: any): boolean; (event: \"end\"): boolean; (event: \"error\", err: Error): boolean; (event: \"pause\"): boolean; (event: \"readable\"): boolean; (event: \"resume\"): boolean; (event: string | symbol, ...args: any[]): boolean; }",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Emits an event. Uses Error."
                }
              },
              {
                "name": "on",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "once",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Adds a one-time listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "prependListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Prepends a listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "prependOnceListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Prepends a one-time listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "removeListener",
                "type": "{ (event: \"close\", listener: () => void): Request<P, ResBody, ReqBody, ReqQuery, Locals>; (event: \"data\", listener: (chunk: any) => void): Request<...>; (event: \"end\", listener: () => void): Request<...>; (event: \"error\", listener: (err: Error) => void): Request<...>; (event: \"pause\", listener: () => void): Request<...",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes a listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>, Error."
                }
              },
              {
                "name": "__@asyncIterator@70027",
                "type": "() => AsyncIterator<any, any, any>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Creates an async iterator for the stream. Uses AsyncIterator<any, any, any>."
                }
              },
              {
                "name": "__@asyncDispose@70029",
                "type": "() => Promise<void>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Disposes the stream asynchronously."
                }
              },
              {
                "name": "pipe",
                "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Pipes the stream to a writable stream. Uses NodeJS.WritableStream."
                }
              },
              {
                "name": "compose",
                "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Composes the stream with other streams. Uses NodeJS.ReadableStream, AbortSignal."
                }
              },
              {
                "name": "__@captureRejectionSymbol@69398",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true,
                "jsdoc": {
                  "xaiDescription": "Captures a rejection. Uses Error."
                }
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes a listener for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Removes all listeners for an event. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Request<P, ResBody, ReqBody, ReqQuery, Locals>",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Sets the maximum number of listeners. Uses Request<P, ResBody, ReqBody, ReqQuery, Locals>."
                }
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the maximum number of listeners."
                }
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the listeners for an event."
                }
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the raw listeners for an event."
                }
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the number of listeners for an event."
                }
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false,
                "jsdoc": {
                  "xaiDescription": "Gets the names of all events."
                }
              }
            ],
            "extends": [
              "core.Request<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": {
              "xaiDescription": "Represents an HTTP request. Uses P, ResBody, ReqBody, ReqQuery, Locals."
            },
            "isExported": false
          },
          {
            "name": "RequestHandler",
            "type": "RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>",
            "properties": [],
            "extends": [
              "core.RequestHandler<P, ResBody, ReqBody, ReqQuery, Locals>"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a request handler. Uses P, ResBody, ReqBody, ReqQuery, Locals."
            },
            "isExported": false
          },
          {
            "name": "RequestParamHandler",
            "type": "RequestParamHandler",
            "properties": [],
            "extends": [
              "core.RequestParamHandler"
            ],
            "jsdoc": {
              "xaiDescription": "Represents a request parameter handler."
            },
            "isExported": false
          },
          {
            "name": "Response",
            "type": "Response<ResBody, Locals>",
            "properties": [
              {
                "name": "status",
                "type": "(code: number) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets the HTTP status code. Returns Response object."
              },
              {
                "name": "sendStatus",
                "type": "(code: number) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sends HTTP status code as response. Returns Response object."
              },
              {
                "name": "links",
                "type": "(links: any) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets Link header field. Returns Response object."
              },
              {
                "name": "send",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false,
                "xaiDescription": "Sends response. Uses Send<ResBody, Response<ResBody, Locals>>."
              },
              {
                "name": "json",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false,
                "xaiDescription": "Sends JSON response. Uses Send<ResBody, Response<ResBody, Locals>>."
              },
              {
                "name": "jsonp",
                "type": "Send<ResBody, Response<ResBody, Locals>>",
                "optional": false,
                "xaiDescription": "Sends JSONP response. Uses Send<ResBody, Response<ResBody, Locals>>."
              },
              {
                "name": "sendFile",
                "type": "{ (path: string, fn?: Errback): void; (path: string, options: SendFileOptions, fn?: Errback): void; }",
                "optional": false,
                "xaiDescription": "Sends file as response. Uses SendFileOptions."
              },
              {
                "name": "download",
                "type": "{ (path: string, fn?: Errback): void; (path: string, filename: string, fn?: Errback): void; (path: string, filename: string, options: DownloadOptions, fn?: Errback): void; }",
                "optional": false,
                "xaiDescription": "Prompts download. Uses DownloadOptions."
              },
              {
                "name": "contentType",
                "type": "(type: string) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets Content-Type header. Returns Response object."
              },
              {
                "name": "type",
                "type": "(type: string) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets Content-Type header. Returns Response object."
              },
              {
                "name": "format",
                "type": "(obj: any) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sends response based on Accept header. Returns Response object."
              },
              {
                "name": "attachment",
                "type": "(filename?: string) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets Content-Disposition header. Returns Response object."
              },
              {
                "name": "set",
                "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
                "optional": false,
                "xaiDescription": "Sets response header. Returns Response object."
              },
              {
                "name": "header",
                "type": "{ (field: any): Response<ResBody, Locals>; (field: string, value?: string | string[]): Response<ResBody, Locals>; }",
                "optional": false,
                "xaiDescription": "Sets response header. Returns Response object."
              },
              {
                "name": "headersSent",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if headers have been sent."
              },
              {
                "name": "get",
                "type": "(field: string) => string",
                "optional": false,
                "xaiDescription": "Gets response header value."
              },
              {
                "name": "clearCookie",
                "type": "(name: string, options?: CookieOptions) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Clears cookie. Uses CookieOptions. Returns Response object."
              },
              {
                "name": "cookie",
                "type": "{ (name: string, val: string, options: CookieOptions): Response<ResBody, Locals>; (name: string, val: any, options: CookieOptions): Response<...>; (name: string, val: any): Response<...>; }",
                "optional": false,
                "xaiDescription": "Sets cookie. Uses CookieOptions. Returns Response object."
              },
              {
                "name": "location",
                "type": "(url: string) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets Location header. Returns Response object."
              },
              {
                "name": "redirect",
                "type": "{ (url: string): void; (status: number, url: string): void; }",
                "optional": false,
                "xaiDescription": "Redirects to specified URL."
              },
              {
                "name": "render",
                "type": "{ (view: string, options?: object, callback?: (err: Error, html: string) => void): void; (view: string, callback?: (err: Error, html: string) => void): void; }",
                "optional": false,
                "xaiDescription": "Renders view template."
              },
              {
                "name": "locals",
                "type": "Locals & Locals",
                "optional": false,
                "xaiDescription": "Local variables for response."
              },
              {
                "name": "charset",
                "type": "string",
                "optional": false,
                "xaiDescription": "Sets character set for response."
              },
              {
                "name": "vary",
                "type": "(field: string) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Adds Vary header. Returns Response object."
              },
              {
                "name": "app",
                "type": "Application<Record<string, any>>",
                "optional": false,
                "xaiDescription": "Reference to the application."
              },
              {
                "name": "append",
                "type": "(field: string, value?: string | string[]) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Appends to response header. Returns Response object."
              },
              {
                "name": "req",
                "type": "Request<ParamsDictionary, any, any, ParsedQs, Record<string, any>>",
                "optional": false,
                "xaiDescription": "Reference to the request object."
              },
              {
                "name": "statusCode",
                "type": "number",
                "optional": false,
                "xaiDescription": "HTTP status code of response."
              },
              {
                "name": "statusMessage",
                "type": "string",
                "optional": false,
                "xaiDescription": "HTTP status message of response."
              },
              {
                "name": "strictContentLength",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Enables strict Content-Length header."
              },
              {
                "name": "assignSocket",
                "type": "(socket: Socket) => void",
                "optional": false,
                "xaiDescription": "Assigns socket to response."
              },
              {
                "name": "detachSocket",
                "type": "(socket: Socket) => void",
                "optional": false,
                "xaiDescription": "Detaches socket from response."
              },
              {
                "name": "writeContinue",
                "type": "(callback?: () => void) => void",
                "optional": false,
                "xaiDescription": "Sends 100 Continue status."
              },
              {
                "name": "writeEarlyHints",
                "type": "(hints: Record<string, string | string[]>, callback?: () => void) => void",
                "optional": false,
                "xaiDescription": "Sends early hints."
              },
              {
                "name": "writeHead",
                "type": "{ (statusCode: number, statusMessage?: string, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<ResBody, Locals>; (statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): Response<...>; }",
                "optional": false,
                "xaiDescription": "Sends response headers. Returns Response object."
              },
              {
                "name": "writeProcessing",
                "type": "() => void",
                "optional": false,
                "xaiDescription": "Sends 102 Processing status."
              },
              {
                "name": "chunkedEncoding",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Enables chunked transfer encoding."
              },
              {
                "name": "shouldKeepAlive",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if connection should be kept alive."
              },
              {
                "name": "useChunkedEncodingByDefault",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Enables chunked encoding by default."
              },
              {
                "name": "sendDate",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Enables sending Date header."
              },
              {
                "name": "finished",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response is finished."
              },
              {
                "name": "connection",
                "type": "Socket",
                "optional": false,
                "xaiDescription": "Reference to the socket."
              },
              {
                "name": "socket",
                "type": "Socket",
                "optional": false,
                "xaiDescription": "Reference to the socket."
              },
              {
                "name": "setTimeout",
                "type": "(msecs: number, callback?: () => void) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets timeout for response. Returns Response object."
              },
              {
                "name": "setHeader",
                "type": "(name: string, value: string | number | readonly string[]) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets response header. Returns Response object."
              },
              {
                "name": "setHeaders",
                "type": "(headers: Headers | Map<string, string | number | readonly string[]>) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets multiple response headers. Returns Response object."
              },
              {
                "name": "appendHeader",
                "type": "(name: string, value: string | readonly string[]) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Appends to response header. Returns Response object."
              },
              {
                "name": "getHeader",
                "type": "(name: string) => string | number | string[]",
                "optional": false,
                "xaiDescription": "Gets response header value."
              },
              {
                "name": "getHeaders",
                "type": "() => OutgoingHttpHeaders",
                "optional": false,
                "xaiDescription": "Gets all response headers."
              },
              {
                "name": "getHeaderNames",
                "type": "() => string[]",
                "optional": false,
                "xaiDescription": "Gets names of all response headers."
              },
              {
                "name": "hasHeader",
                "type": "(name: string) => boolean",
                "optional": false,
                "xaiDescription": "Checks if response has header."
              },
              {
                "name": "removeHeader",
                "type": "(name: string) => void",
                "optional": false,
                "xaiDescription": "Removes response header."
              },
              {
                "name": "addTrailers",
                "type": "(headers: OutgoingHttpHeaders | readonly [string, string][]) => void",
                "optional": false,
                "xaiDescription": "Adds trailers to response."
              },
              {
                "name": "flushHeaders",
                "type": "() => void",
                "optional": false,
                "xaiDescription": "Flushes response headers."
              },
              {
                "name": "writable",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response is writable."
              },
              {
                "name": "writableEnded",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response has ended."
              },
              {
                "name": "writableFinished",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response is finished."
              },
              {
                "name": "writableHighWaterMark",
                "type": "number",
                "optional": false,
                "xaiDescription": "High water mark for writable stream."
              },
              {
                "name": "writableLength",
                "type": "number",
                "optional": false,
                "xaiDescription": "Length of writable stream buffer."
              },
              {
                "name": "writableObjectMode",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if writable stream is in object mode."
              },
              {
                "name": "writableCorked",
                "type": "number",
                "optional": false,
                "xaiDescription": "Number of times writable stream is corked."
              },
              {
                "name": "destroyed",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response is destroyed."
              },
              {
                "name": "closed",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if response is closed."
              },
              {
                "name": "errored",
                "type": "Error",
                "optional": false,
                "xaiDescription": "Error associated with response."
              },
              {
                "name": "writableNeedDrain",
                "type": "boolean",
                "optional": false,
                "xaiDescription": "Indicates if writable stream needs draining."
              },
              {
                "name": "_write",
                "type": "(chunk: any, encoding: BufferEncoding, callback: (error?: Error) => void) => void",
                "optional": false,
                "xaiDescription": "Writes data to response."
              },
              {
                "name": "_writev",
                "type": "(chunks: { chunk: any; encoding: BufferEncoding; }[], callback: (error?: Error) => void) => void",
                "optional": true,
                "xaiDescription": "Writes multiple chunks to response."
              },
              {
                "name": "_construct",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": true,
                "xaiDescription": "Constructs response."
              },
              {
                "name": "_destroy",
                "type": "(error: Error, callback: (error?: Error) => void) => void",
                "optional": false,
                "xaiDescription": "Destroys response."
              },
              {
                "name": "_final",
                "type": "(callback: (error?: Error) => void) => void",
                "optional": false,
                "xaiDescription": "Finalizes response."
              },
              {
                "name": "write",
                "type": "{ (chunk: any, callback?: (error: Error) => void): boolean; (chunk: any, encoding: BufferEncoding, callback?: (error: Error) => void): boolean; }",
                "optional": false,
                "xaiDescription": "Writes data to response."
              },
              {
                "name": "setDefaultEncoding",
                "type": "(encoding: BufferEncoding) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets default encoding for response. Returns Response object."
              },
              {
                "name": "end",
                "type": "{ (cb?: () => void): Response<ResBody, Locals>; (chunk: any, cb?: () => void): Response<ResBody, Locals>; (chunk: any, encoding: BufferEncoding, cb?: () => void): Response<...>; }",
                "optional": false,
                "xaiDescription": "Ends response. Returns Response object."
              },
              {
                "name": "cork",
                "type": "() => void",
                "optional": false,
                "xaiDescription": "Corks response."
              },
              {
                "name": "uncork",
                "type": "() => void",
                "optional": false,
                "xaiDescription": "Uncorks response."
              },
              {
                "name": "destroy",
                "type": "(error?: Error) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Destroys response. Returns Response object."
              },
              {
                "name": "addListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Adds event listener. Returns Response object."
              },
              {
                "name": "emit",
                "type": "{ (event: \"close\"): boolean; (event: \"drain\"): boolean; (event: \"error\", err: Error): boolean; (event: \"finish\"): boolean; (event: \"pipe\", src: Readable): boolean; (event: \"unpipe\", src: Readable): boolean; (event: string | symbol, ...args: any[]): boolean; }",
                "optional": false,
                "xaiDescription": "Emits event."
              },
              {
                "name": "on",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Adds event listener. Returns Response object."
              },
              {
                "name": "once",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Adds one-time event listener. Returns Response object."
              },
              {
                "name": "prependListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Prepends event listener. Returns Response object."
              },
              {
                "name": "prependOnceListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Prepends one-time event listener. Returns Response object."
              },
              {
                "name": "removeListener",
                "type": "{ (event: \"close\", listener: () => void): Response<ResBody, Locals>; (event: \"drain\", listener: () => void): Response<ResBody, Locals>; (event: \"error\", listener: (err: Error) => void): Response<...>; (event: \"finish\", listener: () => void): Response<...>; (event: \"pipe\", listener: (src: Readable) => void): Response...",
                "optional": false,
                "xaiDescription": "Removes event listener. Returns Response object."
              },
              {
                "name": "pipe",
                "type": "<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }) => T",
                "optional": false,
                "xaiDescription": "Pipes response to writable stream."
              },
              {
                "name": "compose",
                "type": "<T extends NodeJS.ReadableStream>(stream: ComposeFnParam | T | Iterable<T> | AsyncIterable<T>, options?: { signal: AbortSignal; }) => T",
                "optional": false,
                "xaiDescription": "Composes response with readable stream."
              },
              {
                "name": "__@captureRejectionSymbol@69398",
                "type": "<K>(error: Error, event: string | symbol, ...args: AnyRest) => void",
                "optional": true,
                "xaiDescription": "Captures rejection symbol."
              },
              {
                "name": "off",
                "type": "<K>(eventName: string | symbol, listener: (...args: any[]) => void) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Removes event listener. Returns Response object."
              },
              {
                "name": "removeAllListeners",
                "type": "(eventName?: string | symbol) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Removes all event listeners. Returns Response object."
              },
              {
                "name": "setMaxListeners",
                "type": "(n: number) => Response<ResBody, Locals>",
                "optional": false,
                "xaiDescription": "Sets maximum number of listeners. Returns Response object."
              },
              {
                "name": "getMaxListeners",
                "type": "() => number",
                "optional": false,
                "xaiDescription": "Gets maximum number of listeners."
              },
              {
                "name": "listeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "xaiDescription": "Gets listeners for event."
              },
              {
                "name": "rawListeners",
                "type": "<K>(eventName: string | symbol) => Function[]",
                "optional": false,
                "xaiDescription": "Gets raw listeners for event."
              },
              {
                "name": "listenerCount",
                "type": "<K>(eventName: string | symbol, listener?: Function) => number",
                "optional": false,
                "xaiDescription": "Gets count of listeners for event."
              },
              {
                "name": "eventNames",
                "type": "() => (string | symbol)[]",
                "optional": false,
                "xaiDescription": "Gets names of all events."
              }
            ],
            "extends": [
              "core.Response<ResBody, Locals>"
            ],
            "jsdoc": null,
            "isExported": false,
            "xaiDescription": "Represents an HTTP response. Extends core.Response<ResBody, Locals>."
          },
          {
            "name": "Router",
            "type": "Router",
            "properties": [
              {
                "name": "param",
                "type": "(name: string, handler: RequestParamHandler) => Router",
                "optional": false,
                "xaiDescription": "Adds parameter middleware. Returns Router object."
              },
              {
                "name": "all",
                "type": "IRouterMatcher<Router, \"all\">",
                "optional": false,
                "xaiDescription": "Matches all HTTP methods. Uses IRouterMatcher<Router, \"all\">."
              },
              {
                "name": "get",
                "type": "IRouterMatcher<Router, \"get\">",
                "optional": false,
                "xaiDescription": "Matches GET requests. Uses IRouterMatcher<Router, \"get\">."
              },
              {
                "name": "post",
                "type": "IRouterMatcher<Router, \"post\">",
                "optional": false,
                "xaiDescription": "Matches POST requests. Uses IRouterMatcher<Router, \"post\">."
              },
              {
                "name": "put",
                "type": "IRouterMatcher<Router, \"put\">",
                "optional": false,
                "xaiDescription": "Matches PUT requests. Uses IRouterMatcher<Router, \"put\">."
              },
              {
                "name": "delete",
                "type": "IRouterMatcher<Router, \"delete\">",
                "optional": false,
                "xaiDescription": "Matches DELETE requests. Uses IRouterMatcher<Router, \"delete\">."
              },
              {
                "name": "patch",
                "type": "IRouterMatcher<Router, \"patch\">",
                "optional": false,
                "xaiDescription": "Matches PATCH requests. Uses IRouterMatcher<Router, \"patch\">."
              },
              {
                "name": "options",
                "type": "IRouterMatcher<Router, \"options\">",
                "optional": false,
                "xaiDescription": "Matches OPTIONS requests. Uses IRouterMatcher<Router, \"options\">."
              },
              {
                "name": "head",
                "type": "IRouterMatcher<Router, \"head\">",
                "optional": false,
                "xaiDescription": "Matches HEAD requests. Uses IRouterMatcher<Router, \"head\">."
              },
              {
                "name": "checkout",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches CHECKOUT requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "connect",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches CONNECT requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "copy",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches COPY requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "lock",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches LOCK requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "merge",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches MERGE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "mkactivity",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches MKACTIVITY requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "mkcol",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches MKCOL requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "move",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches MOVE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "m-search",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches M-SEARCH requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "notify",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches NOTIFY requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "propfind",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches PROPFIND requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "proppatch",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches PROPPATCH requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "purge",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches PURGE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "report",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches REPORT requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "search",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches SEARCH requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "subscribe",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches SUBSCRIBE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "trace",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches TRACE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "unlock",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches UNLOCK requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "unsubscribe",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches UNSUBSCRIBE requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "link",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches LINK requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "unlink",
                "type": "IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Matches UNLINK requests. Uses IRouterMatcher<Router, any>."
              },
              {
                "name": "use",
                "type": "IRouterHandler<Router, string> & IRouterMatcher<Router, any>",
                "optional": false,
                "xaiDescription": "Mounts middleware. Uses IRouterHandler<Router, string> & IRouterMatcher<Router, any>."
              },
              {
                "name": "route",
                "type": "{ <T extends string>(prefix: T): IRoute<T>; (prefix: PathParams): IRoute<string>; }",
                "optional": false,
                "xaiDescription": "Creates route. Uses IRoute<T>."
              },
              {
                "name": "stack",
                "type": "ILayer[]",
                "optional": false,
                "xaiDescription": "Array of route layers. Uses ILayer[]."
              }
            ],
            "extends": [
              "core.Router"
            ],
            "jsdoc": null,
            "isExported": false,
            "xaiDescription": "Handles routing. Extends core.Router."
          },
          {
            "name": "Send",
            "type": "Send",
            "properties": [],
            "extends": [
              "core.Send"
            ],
            "jsdoc": null,
            "isExported": false,
            "xaiDescription": "Handles sending responses. Extends core.Send."
          }
        ],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": false
    }
  ],
  "version": "5.0.1"
}