{
  "functions": [
    {
      "name": "loadBuffer",
      "parameters": [
        {
          "name": "buffer",
          "type": "Buffer<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "options",
          "type": "DecodeStreamOptions",
          "optional": true
        }
      ],
      "returnType": "CheerioAPI",
      "jsdoc": {
        "description": "Sniffs the encoding of a buffer, then creates a querying function bound to a\ndocument created from the buffer.",
        "params": [
          {
            "name": "buffer",
            "description": "- The buffer to sniff the encoding of."
          },
          {
            "name": "options",
            "description": "- The options to pass to Cheerio."
          }
        ],
        "returns": "The loaded document.",
        "deprecated": false
      }
    },
    {
      "name": "stringStream",
      "parameters": [
        {
          "name": "options",
          "type": "CheerioOptions",
          "optional": false
        },
        {
          "name": "cb",
          "type": "(err: Error, $: CheerioAPI) => void",
          "optional": false
        }
      ],
      "returnType": "Writable",
      "jsdoc": {
        "description": "Creates a stream that parses a sequence of strings into a document.\n\nThe stream is a `Writable` stream that accepts strings. When the stream is\nfinished, the callback is called with the loaded document.",
        "params": [
          {
            "name": "options",
            "description": "- The options to pass to Cheerio."
          },
          {
            "name": "cb",
            "description": "- The callback to call when the stream is finished."
          }
        ],
        "returns": "The writable stream.",
        "deprecated": false
      }
    },
    {
      "name": "decodeStream",
      "parameters": [
        {
          "name": "options",
          "type": "DecodeStreamOptions",
          "optional": false
        },
        {
          "name": "cb",
          "type": "(err: Error, $: CheerioAPI) => void",
          "optional": false
        }
      ],
      "returnType": "Writable",
      "jsdoc": {
        "description": "Parses a stream of buffers into a document.\n\nThe stream is a `Writable` stream that accepts buffers. When the stream is\nfinished, the callback is called with the loaded document.",
        "params": [
          {
            "name": "options",
            "description": "- The options to pass to Cheerio."
          },
          {
            "name": "cb",
            "description": "- The callback to call when the stream is finished."
          }
        ],
        "returns": "The writable stream.",
        "deprecated": false
      }
    },
    {
      "name": "fromURL",
      "parameters": [
        {
          "name": "url",
          "type": "string | URL",
          "optional": false
        },
        {
          "name": "options",
          "type": "CheerioRequestOptions",
          "optional": true
        }
      ],
      "returnType": "Promise<CheerioAPI>",
      "jsdoc": {
        "description": "`fromURL` loads a document from a URL.\n\nBy default, redirects are allowed and non-2xx responses are rejected.",
        "params": [
          {
            "name": "url",
            "description": "- The URL to load the document from."
          },
          {
            "name": "options",
            "description": "- The options to pass to Cheerio."
          }
        ],
        "returns": "The loaded document.",
        "deprecated": false
      }
    },
    {
      "name": "contains",
      "parameters": [
        {
          "name": "container",
          "type": "AnyNode",
          "optional": false
        },
        {
          "name": "contained",
          "type": "AnyNode",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "xaiDescription": "Checks if a node contains another node.",
        "deprecated": false
      }
    },
    {
      "name": "merge",
      "parameters": [
        {
          "name": "arr1",
          "type": "Writable<ArrayLike<T>>",
          "optional": false
        },
        {
          "name": "arr2",
          "type": "ArrayLike<T>",
          "optional": false
        }
      ],
      "returnType": "ArrayLike<T>",
      "jsdoc": {
        "xaiDescription": "Merges two arrays into one.",
        "deprecated": false
      }
    },
    {
      "name": "load",
      "parameters": [
        {
          "name": "content",
          "type": "string | Buffer<ArrayBufferLike> | AnyNode | AnyNode[]",
          "optional": false
        },
        {
          "name": "options",
          "type": "CheerioOptions",
          "optional": true
        },
        {
          "name": "isDocument",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "CheerioAPI",
      "jsdoc": {
        "xaiDescription": "Loads content into a Cheerio object for manipulation.",
        "deprecated": false
      }
    },
    {
      "name": "attr",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Method for getting attributes. Gets the attribute value for only the first\nelement in the matched set.",
        "params": [
          {
            "name": "name",
            "description": "- Name of the attribute."
          }
        ],
        "returns": "The attribute's value.",
        "deprecated": false
      }
    },
    {
      "name": "prop",
      "parameters": [
        {
          "name": "name",
          "type": "\"tagName\" | \"nodeName\"",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Method for getting and setting properties. Gets the property value for only\nthe first element in the matched set.",
        "params": [
          {
            "name": "name",
            "description": "- Name of the property."
          }
        ],
        "returns": "If `value` is specified the instance itself, otherwise the prop's\nvalue.",
        "deprecated": false
      }
    },
    {
      "name": "data",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "unknown",
      "jsdoc": {
        "description": "Method for getting data attributes, for only the first element in the matched\nset.",
        "params": [
          {
            "name": "name",
            "description": "- Name of the data attribute."
          }
        ],
        "returns": "The data attribute's value, or `undefined` if the attribute does not\nexist.",
        "deprecated": false
      }
    },
    {
      "name": "val",
      "parameters": [],
      "returnType": "string | string[]",
      "jsdoc": {
        "description": "Method for getting the value of input, select, and textarea. Note: Support\nfor `map`, and `function` has not been added yet.",
        "params": [],
        "returns": "The value.",
        "deprecated": false
      }
    },
    {
      "name": "removeAttr",
      "parameters": [
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Method for removing attributes by `name`.",
        "params": [
          {
            "name": "name",
            "description": "- Name of the attribute."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "hasClass",
      "parameters": [
        {
          "name": "className",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check to see if _any_ of the matched elements have the given `className`.",
        "params": [
          {
            "name": "className",
            "description": "- Name of the class."
          }
        ],
        "returns": "Indicates if an element has the given `className`.",
        "deprecated": false
      }
    },
    {
      "name": "addClass",
      "parameters": [
        {
          "name": "value",
          "type": "string | ((this: Element, i: number, className: string) => string)",
          "optional": true
        }
      ],
      "returnType": "R",
      "jsdoc": {
        "description": "Adds class(es) to all of the matched elements. Also accepts a `function`.",
        "params": [
          {
            "name": "value",
            "description": "- Name of new class."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "removeClass",
      "parameters": [
        {
          "name": "name",
          "type": "string | ((this: Element, i: number, className: string) => string)",
          "optional": true
        }
      ],
      "returnType": "R",
      "jsdoc": {
        "description": "Removes one or more space-separated classes from the selected elements. If no\n`className` is defined, all classes will be removed. Also accepts a\n`function`.",
        "params": [
          {
            "name": "name",
            "description": "- Name of the class. If not specified, removes all elements."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "toggleClass",
      "parameters": [
        {
          "name": "value",
          "type": "string | ((this: Element, i: number, className: string, stateVal?: boolean) => string)",
          "optional": true
        },
        {
          "name": "stateVal",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "R",
      "jsdoc": {
        "description": "Add or remove class(es) from the matched elements, depending on either the\nclass's presence or the value of the switch argument. Also accepts a\n`function`.",
        "params": [
          {
            "name": "value",
            "description": "- Name of the class. Can also be a function."
          },
          {
            "name": "stateVal",
            "description": "- If specified the state of the class."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "css",
      "parameters": [
        {
          "name": "names",
          "type": "string[]",
          "optional": true
        }
      ],
      "returnType": "Record<string, string>",
      "jsdoc": {
        "description": "Get the value of a style property for the first element in the set of matched\nelements.",
        "params": [
          {
            "name": "names",
            "description": "- Optionally the names of the properties of interest."
          }
        ],
        "returns": "A map of all of the style properties.",
        "deprecated": false
      }
    },
    {
      "name": "extract",
      "parameters": [
        {
          "name": "map",
          "type": "M",
          "optional": false
        }
      ],
      "returnType": "ExtractedMap<M>",
      "jsdoc": {
        "description": "Extract multiple values from a document, and store them in an object.",
        "params": [
          {
            "name": "map",
            "description": "- An object containing key-value pairs. The keys are the names of\nthe properties to be created on the object, and the values are the\nselectors to be used to extract the values."
          }
        ],
        "returns": "An object containing the extracted values.",
        "deprecated": false
      }
    },
    {
      "name": "serialize",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Encode a set of form elements as a string for submission.",
        "params": [],
        "returns": "The serialized form.",
        "deprecated": false
      }
    },
    {
      "name": "serializeArray",
      "parameters": [],
      "returnType": "{ name: string; value: string; }[]",
      "jsdoc": {
        "description": "Encode a set of form elements as an array of names and values.",
        "params": [],
        "returns": "The serialized form.",
        "deprecated": false
      }
    },
    {
      "name": "_makeDomArray",
      "parameters": [
        {
          "name": "elem",
          "type": "BasicAcceptedElems<AnyNode> | BasicAcceptedElems<AnyNode>[]",
          "optional": true
        },
        {
          "name": "clone",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "AnyNode[]",
      "jsdoc": {
        "description": "Create an array of nodes, recursing into arrays and parsing strings if\nnecessary.",
        "params": [
          {
            "name": "elem",
            "description": "- Elements to make an array of."
          },
          {
            "name": "clone",
            "description": "- Optionally clone nodes."
          }
        ],
        "returns": "The array of nodes.",
        "deprecated": false
      }
    },
    {
      "name": "appendTo",
      "parameters": [
        {
          "name": "target",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert every element in the set of matched elements to the end of the target.",
        "params": [
          {
            "name": "target",
            "description": "- Element to append elements to."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "prependTo",
      "parameters": [
        {
          "name": "target",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert every element in the set of matched elements to the beginning of the\ntarget.",
        "params": [
          {
            "name": "target",
            "description": "- Element to prepend elements to."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "unwrap",
      "parameters": [
        {
          "name": "selector",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "The .unwrap() function, removes the parents of the set of matched elements\nfrom the DOM, leaving the matched elements in their place.",
        "params": [
          {
            "name": "selector",
            "description": "- A selector to check the parent element against. If an\nelement's parent does not match the selector, the element won't be\nunwrapped."
          }
        ],
        "returns": "The instance itself, for chaining.",
        "deprecated": false
      }
    },
    {
      "name": "wrapAll",
      "parameters": [
        {
          "name": "wrapper",
          "type": "AcceptedElems<T>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "The .wrapAll() function can take any string or object that could be passed to\nthe $() function to specify a DOM structure. This structure may be nested\nseveral levels deep, but should contain only one inmost element. The\nstructure will be wrapped around all of the elements in the set of matched\nelements, as a single group.",
        "params": [
          {
            "name": "wrapper",
            "description": "- The DOM structure to wrap around all matched elements in the\nselection."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "after",
      "parameters": [
        {
          "name": "elems",
          "type": "BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert content next to each element in the set of matched elements.",
        "params": [
          {
            "name": "elems",
            "description": "- HTML string, DOM element, array of DOM elements or Cheerio to\ninsert after each element in the set of matched elements."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "insertAfter",
      "parameters": [
        {
          "name": "target",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert every element in the set of matched elements after the target.",
        "params": [
          {
            "name": "target",
            "description": "- Element to insert elements after."
          }
        ],
        "returns": "The set of newly inserted elements.",
        "deprecated": false
      }
    },
    {
      "name": "before",
      "parameters": [
        {
          "name": "elems",
          "type": "BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert content previous to each element in the set of matched elements.",
        "params": [
          {
            "name": "elems",
            "description": "- HTML string, DOM element, array of DOM elements or Cheerio to\ninsert before each element in the set of matched elements."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "insertBefore",
      "parameters": [
        {
          "name": "target",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Insert every element in the set of matched elements before the target.",
        "params": [
          {
            "name": "target",
            "description": "- Element to insert elements before."
          }
        ],
        "returns": "The set of newly inserted elements.",
        "deprecated": false
      }
    },
    {
      "name": "remove",
      "parameters": [
        {
          "name": "selector",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Removes the set of matched elements from the DOM and all their children.\n`selector` filters the set of matched elements to be removed.",
        "params": [
          {
            "name": "selector",
            "description": "- Optional selector for elements to remove."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "replaceWith",
      "parameters": [
        {
          "name": "content",
          "type": "AcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Replaces matched elements with `content`.",
        "params": [
          {
            "name": "content",
            "description": "- Replacement for matched elements."
          }
        ],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "empty",
      "parameters": [],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Removes all children from each item in the selection. Text nodes and comment\nnodes are left as is.",
        "params": [],
        "returns": "The instance itself.",
        "deprecated": false
      }
    },
    {
      "name": "html",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Gets an HTML content string from the first selected element.",
        "params": [],
        "returns": "The HTML content string.",
        "deprecated": false
      }
    },
    {
      "name": "toString",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Turns the collection to a string. Alias for `.html()`.",
        "params": [],
        "returns": "The rendered document.",
        "deprecated": false
      }
    },
    {
      "name": "text",
      "parameters": [],
      "returnType": "string",
      "jsdoc": {
        "description": "Get the combined text contents of each element in the set of matched\nelements, including their descendants.",
        "params": [],
        "returns": "The text contents of the collection.",
        "deprecated": false
      }
    },
    {
      "name": "clone",
      "parameters": [],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Clone the cheerio object.",
        "params": [],
        "returns": "The cloned object.",
        "deprecated": false
      }
    },
    {
      "name": "append",
      "parameters": [
        {
          "name": "elems",
          "type": "BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "xaiDescription": "Appends content to the end of each element.",
        "deprecated": false
      }
    },
    {
      "name": "prepend",
      "parameters": [
        {
          "name": "elems",
          "type": "BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "xaiDescription": "Prepends content to the beginning of each element.",
        "deprecated": false
      }
    },
    {
      "name": "wrap",
      "parameters": [
        {
          "name": "wrapper",
          "type": "AcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "xaiDescription": "Wraps each element with the specified structure.",
        "deprecated": false
      }
    },
    {
      "name": "wrapInner",
      "parameters": [
        {
          "name": "wrapper",
          "type": "AcceptedElems<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "xaiDescription": "Wraps the contents of each element with the specified structure.",
        "deprecated": false
      }
    },
    {
      "name": "find",
      "parameters": [
        {
          "name": "selectorOrHaystack",
          "type": "string | Element | Cheerio<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "description": "Get the descendants of each element in the current set of matched elements,\nfiltered by a selector, jQuery object, or element.",
        "params": [
          {
            "name": "selectorOrHaystack",
            "description": "- Element to look for."
          }
        ],
        "returns": "The found elements.",
        "deprecated": false
      }
    },
    {
      "name": "_findBySelector",
      "parameters": [
        {
          "name": "selector",
          "type": "string",
          "optional": false
        },
        {
          "name": "limit",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "description": "Find elements by a specific selector.",
        "params": [
          {
            "name": "selector",
            "description": "- Selector to filter by."
          },
          {
            "name": "limit",
            "description": "- Maximum number of elements to match."
          }
        ],
        "returns": "The found elements.",
        "deprecated": false
      }
    },
    {
      "name": "closest",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<AnyNode>",
      "jsdoc": {
        "description": "For each element in the set, get the first element that matches the selector\nby testing the element itself and traversing up through its ancestors in the\nDOM tree.",
        "params": [
          {
            "name": "selector",
            "description": "- Selector for the element to find."
          }
        ],
        "returns": "The closest nodes.",
        "deprecated": false
      }
    },
    {
      "name": "contents",
      "parameters": [],
      "returnType": "Cheerio<AnyNode>",
      "jsdoc": {
        "description": "Gets the children of each element in the set of matched elements, including\ntext and comment nodes.",
        "params": [],
        "returns": "The children.",
        "deprecated": false
      }
    },
    {
      "name": "each",
      "parameters": [
        {
          "name": "fn",
          "type": "(this: T, i: number, el: T) => boolean | void",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Iterates over a cheerio object, executing a function for each matched\nelement. When the callback is fired, the function is fired in the context of\nthe DOM element, so `this` refers to the current element, which is equivalent\nto the function parameter `element`. To break out of the `each` loop early,\nreturn with `false`.",
        "params": [
          {
            "name": "fn",
            "description": "- Function to execute."
          }
        ],
        "returns": "The instance itself, useful for chaining.",
        "deprecated": false
      }
    },
    {
      "name": "map",
      "parameters": [
        {
          "name": "fn",
          "type": "(this: T, i: number, el: T) => M | M[]",
          "optional": false
        }
      ],
      "returnType": "Cheerio<M>",
      "jsdoc": {
        "description": "Pass each element in the current matched set through a function, producing a\nnew Cheerio object containing the return values. The function can return an\nindividual data item or an array of data items to be inserted into the\nresulting set. If an array is returned, the elements inside the array are\ninserted into the set. If the function returns null or undefined, no element\nwill be inserted.",
        "params": [
          {
            "name": "fn",
            "description": "- Function to execute."
          }
        ],
        "returns": "The mapped elements, wrapped in a Cheerio collection.",
        "deprecated": false
      }
    },
    {
      "name": "filter",
      "parameters": [
        {
          "name": "match",
          "type": "(this: T, index: number, value: T) => value is S",
          "optional": false
        }
      ],
      "returnType": "Cheerio<S>",
      "jsdoc": {
        "description": "Iterates over a cheerio object, reducing the set of selector elements to\nthose that match the selector or pass the function's test.\n\nThis is the definition for using type guards; have a look below for other\nways to invoke this method. The function is executed in the context of the\nselected element, so `this` refers to the current element.",
        "params": [
          {
            "name": "match",
            "description": "- Value to look for, following the rules above."
          }
        ],
        "returns": "The filtered collection.",
        "deprecated": false
      }
    },
    {
      "name": "filterArray",
      "parameters": [
        {
          "name": "nodes",
          "type": "T[]",
          "optional": false
        },
        {
          "name": "match",
          "type": "AcceptedFilters<T>",
          "optional": false
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "root",
          "type": "Document",
          "optional": true
        }
      ],
      "returnType": "T[] | Element[]",
      "jsdoc": {
        "xaiDescription": "Filters an array of nodes based on specified criteria.",
        "deprecated": false
      }
    },
    {
      "name": "is",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<T>",
          "optional": true
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks the current list of elements and returns `true` if _any_ of the\nelements match the selector. If using an element or Cheerio selection,\nreturns `true` if _any_ of the elements match. If using a predicate function,\nthe function is executed in the context of the selected element, so `this`\nrefers to the current element.",
        "params": [
          {
            "name": "selector",
            "description": "- Selector for the selection."
          }
        ],
        "returns": "Whether or not the selector matches an element of the instance.",
        "deprecated": false
      }
    },
    {
      "name": "not",
      "parameters": [
        {
          "name": "match",
          "type": "AcceptedFilters<T>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Remove elements from the set of matched elements. Given a Cheerio object that\nrepresents a set of DOM elements, the `.not()` method constructs a new\nCheerio object from a subset of the matching elements. The supplied selector\nis tested against each element; the elements that don't match the selector\nwill be included in the result.\n\nThe `.not()` method can take a function as its argument in the same way that\n`.filter()` does. Elements for which the function returns `true` are excluded\nfrom the filtered set; all other elements are included.",
        "params": [
          {
            "name": "match",
            "description": "- Value to look for, following the rules above."
          }
        ],
        "returns": "The filtered collection.",
        "deprecated": false
      }
    },
    {
      "name": "has",
      "parameters": [
        {
          "name": "selectorOrHaystack",
          "type": "string | Element | Cheerio<Element>",
          "optional": false
        }
      ],
      "returnType": "Cheerio<AnyNode>",
      "jsdoc": {
        "description": "Filters the set of matched elements to only those which have the given DOM\nelement as a descendant or which have a descendant that matches the given\nselector. Equivalent to `.filter(':has(selector)')`.",
        "params": [
          {
            "name": "selectorOrHaystack",
            "description": "- Element to look for."
          }
        ],
        "returns": "The filtered collection.",
        "deprecated": false
      }
    },
    {
      "name": "first",
      "parameters": [],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Will select the first element of a cheerio object.",
        "params": [],
        "returns": "The first element.",
        "deprecated": false
      }
    },
    {
      "name": "last",
      "parameters": [],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Will select the last element of a cheerio object.",
        "params": [],
        "returns": "The last element.",
        "deprecated": false
      }
    },
    {
      "name": "eq",
      "parameters": [
        {
          "name": "i",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Reduce the set of matched elements to the one at the specified index. Use\n`.eq(-i)` to count backwards from the last selected element.",
        "params": [
          {
            "name": "i",
            "description": "- Index of the element to select."
          }
        ],
        "returns": "The element at the `i`th position.",
        "deprecated": false
      }
    },
    {
      "name": "get",
      "parameters": [
        {
          "name": "i",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "T",
      "jsdoc": {
        "description": "Retrieve one of the elements matched by the Cheerio object, at the `i`th\nposition.",
        "params": [
          {
            "name": "i",
            "description": "- Element to retrieve."
          }
        ],
        "returns": "The element at the `i`th position.",
        "deprecated": false
      }
    },
    {
      "name": "toArray",
      "parameters": [],
      "returnType": "T[]",
      "jsdoc": {
        "description": "Retrieve all the DOM elements contained in the jQuery set as an array.",
        "params": [],
        "returns": "The contained items.",
        "deprecated": false
      }
    },
    {
      "name": "index",
      "parameters": [
        {
          "name": "selectorOrNeedle",
          "type": "string | AnyNode | Cheerio<AnyNode>",
          "optional": true
        }
      ],
      "returnType": "number",
      "jsdoc": {
        "description": "Search for a given element from among the matched elements.",
        "params": [
          {
            "name": "selectorOrNeedle",
            "description": "- Element to look for."
          }
        ],
        "returns": "The index of the element.",
        "deprecated": false
      }
    },
    {
      "name": "slice",
      "parameters": [
        {
          "name": "start",
          "type": "number",
          "optional": true
        },
        {
          "name": "end",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Gets the elements matching the specified range (0-based position).",
        "params": [
          {
            "name": "start",
            "description": "- A position at which the elements begin to be selected. If\nnegative, it indicates an offset from the end of the set."
          },
          {
            "name": "end",
            "description": "- A position at which the elements stop being selected. If\nnegative, it indicates an offset from the end of the set. If omitted, the\nrange continues until the end of the set."
          }
        ],
        "returns": "The elements matching the specified range.",
        "deprecated": false
      }
    },
    {
      "name": "end",
      "parameters": [],
      "returnType": "Cheerio<AnyNode>",
      "jsdoc": {
        "description": "End the most recent filtering operation in the current chain and return the\nset of matched elements to its previous state.",
        "params": [],
        "returns": "The previous state of the set of matched elements.",
        "deprecated": false
      }
    },
    {
      "name": "add",
      "parameters": [
        {
          "name": "other",
          "type": "string | S | Cheerio<S> | S[]",
          "optional": false
        },
        {
          "name": "context",
          "type": "string | Cheerio<S>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<S | T>",
      "jsdoc": {
        "description": "Add elements to the set of matched elements.",
        "params": [
          {
            "name": "other",
            "description": "- Elements to add."
          },
          {
            "name": "context",
            "description": "- Optionally the context of the new selection."
          }
        ],
        "returns": "The combined set.",
        "deprecated": false
      }
    },
    {
      "name": "addBack",
      "parameters": [
        {
          "name": "selector",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "Cheerio<AnyNode>",
      "jsdoc": {
        "description": "Add the previous set of elements on the stack to the current set, optionally\nfiltered by a selector.",
        "params": [
          {
            "name": "selector",
            "description": "- Selector for the elements to add."
          }
        ],
        "returns": "The combined set.",
        "deprecated": false
      }
    },
    {
      "name": "parent",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the parent of each element in the set of matched elements."
      }
    },
    {
      "name": "parents",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the ancestors of each element in the set of matched elements."
      }
    },
    {
      "name": "parentsUntil",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        },
        {
          "name": "filterSelector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the ancestors of each element up to but not including the element matched by the selector."
      }
    },
    {
      "name": "next",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the immediately following sibling of each element in the set of matched elements."
      }
    },
    {
      "name": "nextAll",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get all following siblings of each element in the set of matched elements."
      }
    },
    {
      "name": "nextUntil",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        },
        {
          "name": "filterSelector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get all following siblings of each element up to but not including the element matched by the selector."
      }
    },
    {
      "name": "prev",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the immediately preceding sibling of each element in the set of matched elements."
      }
    },
    {
      "name": "prevAll",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get all preceding siblings of each element in the set of matched elements."
      }
    },
    {
      "name": "prevUntil",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        },
        {
          "name": "filterSelector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get all preceding siblings of each element up to but not including the element matched by the selector."
      }
    },
    {
      "name": "siblings",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the siblings of each element in the set of matched elements."
      }
    },
    {
      "name": "children",
      "parameters": [
        {
          "name": "selector",
          "type": "AcceptedFilters<Element>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<Element>",
      "jsdoc": {
        "xaiDescription": "Get the children of each element in the set of matched elements."
      }
    },
    {
      "name": "Cheerio._make",
      "parameters": [
        {
          "name": "dom",
          "type": "string | T | ArrayLike<T>",
          "optional": false
        },
        {
          "name": "context",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": true
        }
      ],
      "returnType": "Cheerio<T>",
      "jsdoc": {
        "description": "Make a cheerio object.",
        "params": [
          {
            "name": "dom",
            "description": "- The contents of the new object."
          },
          {
            "name": "context",
            "description": "- The context of the new object."
          }
        ],
        "returns": "The new cheerio object.",
        "deprecated": false
      }
    },
    {
      "name": "Cheerio._parse",
      "parameters": [
        {
          "name": "content",
          "type": "string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "options",
          "type": "InternalOptions",
          "optional": false
        },
        {
          "name": "isDocument",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "context",
          "type": "ParentNode",
          "optional": false
        }
      ],
      "returnType": "Document",
      "jsdoc": {
        "description": "Parses some content.",
        "params": [
          {
            "name": "content",
            "description": "- Content to parse."
          },
          {
            "name": "options",
            "description": "- Options for parsing."
          },
          {
            "name": "isDocument",
            "description": "- Allows parser to be switched to fragment mode."
          }
        ],
        "returns": "A document containing the `content`.",
        "deprecated": false
      }
    },
    {
      "name": "Cheerio._render",
      "parameters": [
        {
          "name": "dom",
          "type": "AnyNode | ArrayLike<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Render an element or a set of elements.",
        "params": [
          {
            "name": "dom",
            "description": "- DOM to render."
          }
        ],
        "returns": "The rendered DOM.",
        "deprecated": false
      }
    },
    {
      "name": "getLoad",
      "parameters": [
        {
          "name": "parse",
          "type": "(content: string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>, options: InternalOptions, isDocument: boolean, context: ParentNode) => Document",
          "optional": false
        },
        {
          "name": "render",
          "type": "(dom: AnyNode | ArrayLike<AnyNode>, options: InternalOptions) => string",
          "optional": false
        }
      ],
      "returnType": "(content: string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>, options?: CheerioOptions, isDocument?: boolean) => CheerioAPI",
      "jsdoc": {
        "xaiDescription": "Create a Cheerio load function using custom parse and render functions."
      }
    },
    {
      "name": "flattenOptions",
      "parameters": [
        {
          "name": "options",
          "type": "CheerioOptions",
          "optional": true
        },
        {
          "name": "baseOptions",
          "type": "InternalOptions",
          "optional": true
        }
      ],
      "returnType": "InternalOptions",
      "jsdoc": {
        "description": "Flatten the options for Cheerio.\n\nThis will set `_useHtmlParser2` to true if `xml` is set to true.",
        "params": [
          {
            "name": "options",
            "description": "- The options to flatten."
          },
          {
            "name": "baseOptions",
            "description": "- The base options to use."
          }
        ],
        "returns": "The flattened options.",
        "deprecated": false
      }
    },
    {
      "name": "getParse",
      "parameters": [
        {
          "name": "parser",
          "type": "(content: string, options: InternalOptions, isDocument: boolean, context: ParentNode) => Document",
          "optional": false
        }
      ],
      "returnType": "(content: string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>, options: InternalOptions, isDocument: boolean, context: ParentNode) => Document",
      "jsdoc": {
        "description": "Get the parse function with options.",
        "params": [
          {
            "name": "parser",
            "description": "- The parser function."
          }
        ],
        "returns": "The parse function with options.",
        "deprecated": false
      }
    },
    {
      "name": "update",
      "parameters": [
        {
          "name": "newChilds",
          "type": "AnyNode | AnyNode[]",
          "optional": false
        },
        {
          "name": "parent",
          "type": "ParentNode",
          "optional": false
        }
      ],
      "returnType": "ParentNode",
      "jsdoc": {
        "description": "Update the dom structure, for one changed layer.",
        "params": [
          {
            "name": "newChilds",
            "description": "- The new children."
          },
          {
            "name": "parent",
            "description": "- The new parent."
          }
        ],
        "returns": "The parent node.",
        "deprecated": false
      }
    },
    {
      "name": "parseWithParse5",
      "parameters": [
        {
          "name": "content",
          "type": "string",
          "optional": false
        },
        {
          "name": "options",
          "type": "InternalOptions",
          "optional": false
        },
        {
          "name": "isDocument",
          "type": "boolean",
          "optional": false
        },
        {
          "name": "context",
          "type": "ParentNode",
          "optional": false
        }
      ],
      "returnType": "Document",
      "jsdoc": {
        "description": "Parse the content with `parse5` in the context of the given `ParentNode`.",
        "params": [
          {
            "name": "content",
            "description": "- The content to parse."
          },
          {
            "name": "options",
            "description": "- A set of options to use to parse."
          },
          {
            "name": "isDocument",
            "description": "- Whether to parse the content as a full HTML document."
          },
          {
            "name": "context",
            "description": "- The context in which to parse the content."
          }
        ],
        "returns": "The parsed content.",
        "deprecated": false
      }
    },
    {
      "name": "renderWithParse5",
      "parameters": [
        {
          "name": "dom",
          "type": "AnyNode | ArrayLike<AnyNode>",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Renders the given DOM tree with `parse5` and returns the result as a string.",
        "params": [
          {
            "name": "dom",
            "description": "- The DOM tree to render."
          }
        ],
        "returns": "The rendered document.",
        "deprecated": false
      }
    },
    {
      "name": "xml",
      "parameters": [
        {
          "name": "dom",
          "type": "BasicAcceptedElems<AnyNode>",
          "optional": true
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Render the document as XML.",
        "params": [
          {
            "name": "dom",
            "description": "- Element to render."
          }
        ],
        "returns": "THe rendered document.",
        "deprecated": false
      }
    },
    {
      "name": "parseHTML",
      "parameters": [
        {
          "name": "data",
          "type": "string",
          "optional": false
        },
        {
          "name": "context",
          "type": "unknown",
          "optional": true
        },
        {
          "name": "keepScripts",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "AnyNode[]",
      "jsdoc": {
        "description": "Parses a string into an array of DOM nodes. The `context` argument has no\nmeaning for Cheerio, but it is maintained for API compatibility with jQuery.",
        "params": [
          {
            "name": "data",
            "description": "- Markup that will be parsed."
          },
          {
            "name": "context",
            "description": "- Will be ignored. If it is a boolean it will be used as the\nvalue of `keepScripts`."
          },
          {
            "name": "keepScripts",
            "description": "- If false all scripts will be removed."
          }
        ],
        "returns": "The parsed DOM.",
        "deprecated": false
      }
    },
    {
      "name": "root",
      "parameters": [],
      "returnType": "Cheerio<Document>",
      "jsdoc": {
        "description": "Sometimes you need to work with the top-level root element. To query it, you\ncan use `$.root()`.",
        "params": [],
        "returns": "Cheerio instance wrapping the root node.",
        "deprecated": false
      }
    },
    {
      "name": "isCheerio",
      "parameters": [
        {
          "name": "maybeCheerio",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Checks if an object is a Cheerio instance.",
        "params": [
          {
            "name": "maybeCheerio",
            "description": "- The object to check."
          }
        ],
        "returns": "Whether the object is a Cheerio instance.",
        "deprecated": false
      }
    },
    {
      "name": "camelCase",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Convert a string to camel case notation.",
        "params": [
          {
            "name": "str",
            "description": "- The string to be converted."
          }
        ],
        "returns": "String in camel case notation.",
        "deprecated": false
      }
    },
    {
      "name": "cssCase",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "jsdoc": {
        "description": "Convert a string from camel case to \"CSS case\", where word boundaries are\ndescribed by hyphens (\"-\") and all characters are lower-case.",
        "params": [
          {
            "name": "str",
            "description": "- The string to be converted."
          }
        ],
        "returns": "String in \"CSS case\".",
        "deprecated": false
      }
    },
    {
      "name": "domEach",
      "parameters": [
        {
          "name": "array",
          "type": "Arr",
          "optional": false
        },
        {
          "name": "fn",
          "type": "(elem: T, index: number) => void",
          "optional": false
        }
      ],
      "returnType": "Arr",
      "jsdoc": {
        "description": "Iterate over each DOM element without creating intermediary Cheerio\ninstances.\n\nThis is indented for use internally to avoid otherwise unnecessary memory\npressure introduced by _make.",
        "params": [
          {
            "name": "array",
            "description": "- The array to iterate over."
          },
          {
            "name": "fn",
            "description": "- Function to call."
          }
        ],
        "returns": "The original instance.",
        "deprecated": false
      }
    },
    {
      "name": "isHtml",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "jsdoc": {
        "description": "Check if string is HTML.\n\nTests for a `<` within a string, immediate followed by a letter and\neventually followed by a `>`.",
        "params": [
          {
            "name": "str",
            "description": "- The string to check."
          }
        ],
        "returns": "Indicates if `str` is HTML.",
        "deprecated": false
      }
    }
  ],
  "enums": [],
  "types": [
    {
      "name": "DecodeStreamOptions",
      "type": "DecodeStreamOptions",
      "properties": [
        {
          "name": "encoding",
          "type": "SnifferOptions",
          "optional": true
        },
        {
          "name": "xml",
          "type": "boolean | HTMLParser2Options",
          "optional": true
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "baseURI",
          "type": "string | URL",
          "optional": true
        },
        {
          "name": "quirksMode",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "pseudos",
          "type": "Record<string, string | ((elem: Element, value?: string) => boolean)>",
          "optional": true
        },
        {
          "name": "scriptingEnabled",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "sourceCodeLocationInfo",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "treeAdapter",
          "type": "TreeAdapter<Htmlparser2TreeAdapterMap>",
          "optional": true
        },
        {
          "name": "onParseError",
          "type": "ParserErrorHandler",
          "optional": true
        }
      ],
      "extends": [
        "CheerioOptions"
      ],
      "jsdoc": {
        "xaiDescription": "Options for decoding and parsing streams."
      },
      "isExported": false
    },
    {
      "name": "UndiciStreamOptions",
      "type": "{ dispatcher?: Dispatcher; } & Omit<RequestOptions, \"origin\" | \"path\">",
      "properties": [
        {
          "name": "dispatcher",
          "type": "Dispatcher",
          "optional": true
        },
        {
          "name": "opaque",
          "type": "unknown",
          "optional": true
        },
        {
          "name": "signal",
          "type": "unknown",
          "optional": true
        },
        {
          "name": "maxRedirections",
          "type": "number",
          "optional": true
        },
        {
          "name": "redirectionLimitReached",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "onInfo",
          "type": "(info: { statusCode: number; headers: Record<string, string | string[]>; }) => void",
          "optional": true
        },
        {
          "name": "responseHeader",
          "type": "\"raw\"",
          "optional": true
        },
        {
          "name": "highWaterMark",
          "type": "number",
          "optional": true
        },
        {
          "name": "method",
          "type": "HttpMethod",
          "optional": false
        },
        {
          "name": "body",
          "type": "string | Buffer<ArrayBufferLike> | Uint8Array<ArrayBufferLike> | Readable | FormData",
          "optional": true
        },
        {
          "name": "headers",
          "type": "string[] | IncomingHttpHeaders | Iterable<[string, string | string[]]>",
          "optional": true
        },
        {
          "name": "query",
          "type": "Record<string, any>",
          "optional": true
        },
        {
          "name": "idempotent",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "blocking",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "upgrade",
          "type": "string | boolean",
          "optional": true
        },
        {
          "name": "headersTimeout",
          "type": "number",
          "optional": true
        },
        {
          "name": "bodyTimeout",
          "type": "number",
          "optional": true
        },
        {
          "name": "reset",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "throwOnError",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "expectContinue",
          "type": "boolean",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Options for handling HTTP streams with Undici."
      },
      "isExported": false
    },
    {
      "name": "CheerioRequestOptions",
      "type": "CheerioRequestOptions",
      "properties": [
        {
          "name": "requestOptions",
          "type": "{ dispatcher?: Dispatcher; } & Omit<RequestOptions, \"origin\" | \"path\">",
          "optional": true
        },
        {
          "name": "encoding",
          "type": "SnifferOptions",
          "optional": true
        },
        {
          "name": "xml",
          "type": "boolean | HTMLParser2Options",
          "optional": true
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "baseURI",
          "type": "string | URL",
          "optional": true
        },
        {
          "name": "quirksMode",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "pseudos",
          "type": "Record<string, string | ((elem: Element, value?: string) => boolean)>",
          "optional": true
        },
        {
          "name": "scriptingEnabled",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "sourceCodeLocationInfo",
          "type": "boolean",
          "optional": true
        },
        {
          "name": "treeAdapter",
          "type": "TreeAdapter<Htmlparser2TreeAdapterMap>",
          "optional": true
        },
        {
          "name": "onParseError",
          "type": "ParserErrorHandler",
          "optional": true
        }
      ],
      "extends": [
        "DecodeStreamOptions"
      ],
      "jsdoc": {
        "xaiDescription": "Options for Cheerio requests."
      },
      "isExported": false
    },
    {
      "name": "StyleProp",
      "type": "StyleProp",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Represents a style property."
      },
      "isExported": false
    },
    {
      "name": "ExtractDescriptorFn",
      "type": "ExtractDescriptorFn",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Function to extract a value."
      },
      "isExported": false
    },
    {
      "name": "ExtractDescriptor",
      "type": "ExtractDescriptor",
      "properties": [
        {
          "name": "selector",
          "type": "string",
          "optional": false
        },
        {
          "name": "value",
          "type": "string | ExtractDescriptorFn | ExtractMap",
          "optional": true
        }
      ],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Descriptor for extracting data."
      },
      "isExported": false
    },
    {
      "name": "ExtractValue",
      "type": "ExtractValue",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | (() => string) | (() => string)",
          "optional": false
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => Object)",
          "optional": false
        }
      ],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Value extracted from an element."
      },
      "isExported": false
    },
    {
      "name": "ExtractMap",
      "type": "ExtractMap",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Mapping of extracted values."
      },
      "isExported": false
    },
    {
      "name": "ExtractedValue",
      "type": "ExtractedValue<V, M>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Extracted value of type V with metadata M."
      },
      "isExported": false
    },
    {
      "name": "ExtractedMap",
      "type": "ExtractedMap<M>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "xaiDescription": "Map of extracted values with metadata M."
      },
      "isExported": false
    },
    {
      "name": "MethodsType",
      "type": "MethodsType",
      "properties": [
        {
          "name": "attr",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<T>): Record<string, string>; <T extends AnyNode>(this: Cheerio<...>, name: string, value?: string | ((this: Element, i: number, attrib: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: R...",
          "optional": false,
          "xaiDescription": "Get or set attributes. Uses Cheerio<T>."
        },
        {
          "name": "prop",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: \"tagName\" | \"nodeName\"): string; <T extends AnyNode>(this: Cheerio<T>, name: \"innerHTML\" | \"outerHTML\" | \"innerText\" | \"textContent\"): string; <T extends AnyNode>(this: Cheerio<...>, name: \"style\"): StyleProp; <T extends AnyNode>(this: Cheerio<...>, name: \"href\" | \"src\")...",
          "optional": false,
          "xaiDescription": "Get or set properties. Uses Cheerio<T>."
        },
        {
          "name": "data",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): unknown; <T extends AnyNode>(this: Cheerio<T>): Record<string, unknown>; <T extends AnyNode>(this: Cheerio<T>, name: string, value: unknown): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: Record<...>): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Get or set data attributes. Uses Cheerio<T>."
        },
        {
          "name": "val",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string | string[]; <T extends AnyNode>(this: Cheerio<T>, value: string | string[]): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Get or set the value of form elements. Uses Cheerio<T>."
        },
        {
          "name": "removeAttr",
          "type": "<T extends AnyNode>(this: Cheerio<T>, name: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Remove an attribute. Uses Cheerio<T>."
        },
        {
          "name": "hasClass",
          "type": "<T extends AnyNode>(this: Cheerio<T>, className: string) => boolean",
          "optional": false,
          "xaiDescription": "Check if elements have a class. Uses Cheerio<T>."
        },
        {
          "name": "addClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Add class(es) to elements. Uses Cheerio<T>."
        },
        {
          "name": "removeClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, name?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Remove class(es) from elements. Uses Cheerio<T>."
        },
        {
          "name": "toggleClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string, stateVal?: boolean) => string), stateVal?: boolean) => R",
          "optional": false,
          "xaiDescription": "Toggle class(es) on elements. Uses Cheerio<T>."
        },
        {
          "name": "find",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrHaystack?: string | Element | Cheerio<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Find elements within a set. Uses Cheerio<T>."
        },
        {
          "name": "_findBySelector",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector: string, limit: number) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Find elements by selector with limit. Uses Cheerio<T>."
        },
        {
          "name": "closest",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Get closest matching ancestor. Uses Cheerio<T>."
        },
        {
          "name": "contents",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Get children of each element. Uses Cheerio<T>."
        },
        {
          "name": "each",
          "type": "<T>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => boolean | void) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Iterate over elements. Uses Cheerio<T>."
        },
        {
          "name": "map",
          "type": "<T, M>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => M | M[]) => Cheerio<M>",
          "optional": false,
          "xaiDescription": "Transform elements. Uses Cheerio<T>."
        },
        {
          "name": "filter",
          "type": "{ <T, S extends T>(this: Cheerio<T>, match: (this: T, index: number, value: T) => value is S): Cheerio<S>; <T, S extends AcceptedFilters<T>>(this: Cheerio<T>, match: S): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Filter elements. Uses Cheerio<T>."
        },
        {
          "name": "filterArray",
          "type": "<T>(nodes: T[], match: AcceptedFilters<T>, xmlMode?: boolean, root?: Document) => T[] | Element[]",
          "optional": false,
          "xaiDescription": "Filter array of nodes. Uses AcceptedFilters<T>."
        },
        {
          "name": "is",
          "type": "<T>(this: Cheerio<T>, selector?: AcceptedFilters<T>) => boolean",
          "optional": false,
          "xaiDescription": "Check if elements match selector. Uses Cheerio<T>."
        },
        {
          "name": "not",
          "type": "<T extends AnyNode>(this: Cheerio<T>, match: AcceptedFilters<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Remove elements not matching selector. Uses Cheerio<T>."
        },
        {
          "name": "has",
          "type": "(this: Cheerio<AnyNode>, selectorOrHaystack: string | Element | Cheerio<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Check if elements have descendants. Uses Cheerio<T>."
        },
        {
          "name": "first",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Get first element. Uses Cheerio<T>."
        },
        {
          "name": "last",
          "type": "<T>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Get last element. Uses Cheerio<T>."
        },
        {
          "name": "eq",
          "type": "<T>(this: Cheerio<T>, i: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Get element at index. Uses Cheerio<T>."
        },
        {
          "name": "get",
          "type": "{ <T>(this: Cheerio<T>, i: number): T; <T>(this: Cheerio<T>): T[]; }",
          "optional": false,
          "xaiDescription": "Get element(s) at index or all. Uses Cheerio<T>."
        },
        {
          "name": "toArray",
          "type": "<T>(this: Cheerio<T>) => T[]",
          "optional": false,
          "xaiDescription": "Convert to array. Uses Cheerio<T>."
        },
        {
          "name": "index",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrNeedle?: string | AnyNode | Cheerio<AnyNode>) => number",
          "optional": false,
          "xaiDescription": "Get index of element. Uses Cheerio<T>."
        },
        {
          "name": "slice",
          "type": "<T>(this: Cheerio<T>, start?: number, end?: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Extract subset of elements. Uses Cheerio<T>."
        },
        {
          "name": "end",
          "type": "<T>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "End current operation. Uses Cheerio<T>."
        },
        {
          "name": "add",
          "type": "<S extends AnyNode, T extends AnyNode>(this: Cheerio<T>, other: string | S | Cheerio<S> | S[], context?: string | Cheerio<S>) => Cheerio<S | T>",
          "optional": false,
          "xaiDescription": "Add elements to set. Uses Cheerio<T>."
        },
        {
          "name": "addBack",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Add previous set of elements. Uses Cheerio<T>."
        },
        {
          "name": "parent",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get parent of each element. Uses Cheerio<T>."
        },
        {
          "name": "parents",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get ancestors of each element. Uses Cheerio<T>."
        },
        {
          "name": "parentsUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Get ancestors until matching element. Uses Cheerio<T>."
        },
        {
          "name": "next",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get next sibling of each element. Uses Cheerio<T>."
        },
        {
          "name": "nextAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get all next siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "nextUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Get next siblings until matching element. Uses Cheerio<T>."
        },
        {
          "name": "prev",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get previous sibling of each element. Uses Cheerio<T>."
        },
        {
          "name": "prevAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get all previous siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "prevUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Get previous siblings until matching element. Uses Cheerio<T>."
        },
        {
          "name": "siblings",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "children",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Get children of each element. Uses Cheerio<T>."
        },
        {
          "name": "_makeDomArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>, elem?: BasicAcceptedElems<AnyNode> | BasicAcceptedElems<AnyNode>[], clone?: boolean) => AnyNode[]",
          "optional": false,
          "xaiDescription": "Create DOM array. Uses Cheerio<T>."
        },
        {
          "name": "appendTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Append to target. Uses Cheerio<T>."
        },
        {
          "name": "prependTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Prepend to target. Uses Cheerio<T>."
        },
        {
          "name": "unwrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Remove parent of each element. Uses Cheerio<T>."
        },
        {
          "name": "wrapAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wrap all elements. Uses Cheerio<T>."
        },
        {
          "name": "after",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Insert content after each element. Uses Cheerio<T>."
        },
        {
          "name": "insertAfter",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Insert after target. Uses Cheerio<T>."
        },
        {
          "name": "before",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Insert content before each element. Uses Cheerio<T>."
        },
        {
          "name": "insertBefore",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Insert before target. Uses Cheerio<T>."
        },
        {
          "name": "remove",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Remove elements. Uses Cheerio<T>."
        },
        {
          "name": "replaceWith",
          "type": "<T extends AnyNode>(this: Cheerio<T>, content: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Replace elements with content. Uses Cheerio<T>."
        },
        {
          "name": "empty",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Remove all children. Uses Cheerio<T>."
        },
        {
          "name": "html",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | Cheerio<T>): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Get or set HTML content. Uses Cheerio<T>."
        },
        {
          "name": "toString",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Convert to string. Uses Cheerio<T>."
        },
        {
          "name": "text",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | ((this: AnyNode, i: number, text: string) => string)): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Get or set text content. Uses Cheerio<T>."
        },
        {
          "name": "clone",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Clone elements. Uses Cheerio<T>."
        },
        {
          "name": "append",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Append content to each element. Uses Cheerio<T>."
        },
        {
          "name": "prepend",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Prepend content to each element. Uses Cheerio<T>."
        },
        {
          "name": "wrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wrap each element. Uses Cheerio<T>."
        },
        {
          "name": "wrapInner",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wrap contents of each element. Uses Cheerio<T>."
        },
        {
          "name": "css",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, names?: string[]): Record<string, string>; <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<...>, prop: string, val: string | ((this: Element, i: number, style: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<....",
          "optional": false,
          "xaiDescription": "Get or set CSS properties. Uses Cheerio<T>."
        },
        {
          "name": "serialize",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Serialize form data. Uses Cheerio<T>."
        },
        {
          "name": "serializeArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => { name: string; value: string; }[]",
          "optional": false,
          "xaiDescription": "Serialize form data as array. Uses Cheerio<T>."
        },
        {
          "name": "extract",
          "type": "<M extends ExtractMap, T extends AnyNode>(this: Cheerio<T>, map: M) => ExtractedMap<M>",
          "optional": false,
          "xaiDescription": "Extract data using map. Uses Cheerio<T>."
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false
    },
    {
      "name": "Cheerio",
      "type": "Cheerio<T>",
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "Number of elements in the Cheerio object."
        },
        {
          "name": "options",
          "type": "InternalOptions",
          "optional": false,
          "xaiDescription": "Configuration options for Cheerio. Uses InternalOptions."
        },
        {
          "name": "_root",
          "type": "Cheerio<Document>",
          "optional": false,
          "xaiDescription": "Root element of the document. Uses Cheerio<Document>."
        },
        {
          "name": "prevObject",
          "type": "Cheerio<any>",
          "optional": false,
          "xaiDescription": "Previous set of elements in the Cheerio object."
        },
        {
          "name": "_make",
          "type": "<T>(dom: string | T | ArrayLike<T>, context?: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Creates a new Cheerio object from the provided DOM. Uses Cheerio<T>."
        },
        {
          "name": "_parse",
          "type": "(content: string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>, options: InternalOptions, isDocument: boolean, context: ParentNode) => Document",
          "optional": false,
          "xaiDescription": "Parses content into a document. Uses InternalOptions, Document."
        },
        {
          "name": "_render",
          "type": "(dom: AnyNode | ArrayLike<AnyNode>) => string",
          "optional": false,
          "xaiDescription": "Renders the DOM as a string."
        },
        {
          "name": "cheerio",
          "type": "\"[cheerio object]\"",
          "optional": false,
          "xaiDescription": "String representation of the Cheerio object."
        },
        {
          "name": "splice",
          "type": "{ (start: number, deleteCount?: number): any[]; (start: number, deleteCount: number, ...items: any[]): any[]; }",
          "optional": false,
          "xaiDescription": "Modifies the Cheerio object by adding/removing elements."
        },
        {
          "name": "attr",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<T>): Record<string, string>; <T extends AnyNode>(this: Cheerio<...>, name: string, value?: string | ((this: Element, i: number, attrib: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: R...",
          "optional": false,
          "xaiDescription": "Gets or sets attributes of elements. Uses Cheerio<T>."
        },
        {
          "name": "prop",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: \"tagName\" | \"nodeName\"): string; <T extends AnyNode>(this: Cheerio<T>, name: \"innerHTML\" | \"outerHTML\" | \"innerText\" | \"textContent\"): string; <T extends AnyNode>(this: Cheerio<...>, name: \"style\"): StyleProp; <T extends AnyNode>(this: Cheerio<...>, name: \"href\" | \"src\")...",
          "optional": false,
          "xaiDescription": "Gets or sets properties of elements. Uses Cheerio<T>, StyleProp."
        },
        {
          "name": "data",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): unknown; <T extends AnyNode>(this: Cheerio<T>): Record<string, unknown>; <T extends AnyNode>(this: Cheerio<T>, name: string, value: unknown): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: Record<...>): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Gets or sets data attributes of elements. Uses Cheerio<T>."
        },
        {
          "name": "val",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string | string[]; <T extends AnyNode>(this: Cheerio<T>, value: string | string[]): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the value of form elements. Uses Cheerio<T>."
        },
        {
          "name": "removeAttr",
          "type": "<T extends AnyNode>(this: Cheerio<T>, name: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes an attribute from elements. Uses Cheerio<T>."
        },
        {
          "name": "hasClass",
          "type": "<T extends AnyNode>(this: Cheerio<T>, className: string) => boolean",
          "optional": false,
          "xaiDescription": "Checks if any element has the specified class."
        },
        {
          "name": "addClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Adds one or more classes to elements."
        },
        {
          "name": "removeClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, name?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Removes one or more classes from elements."
        },
        {
          "name": "toggleClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string, stateVal?: boolean) => string), stateVal?: boolean) => R",
          "optional": false,
          "xaiDescription": "Toggles one or more classes on elements."
        },
        {
          "name": "find",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrHaystack?: string | Element | Cheerio<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Finds elements within the Cheerio object. Uses Cheerio<Element>."
        },
        {
          "name": "_findBySelector",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector: string, limit: number) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Finds elements using a selector with a limit. Uses Cheerio<Element>."
        },
        {
          "name": "closest",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Finds the closest matching ancestor element. Uses Cheerio<AnyNode>."
        },
        {
          "name": "contents",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Gets the children of each element. Uses Cheerio<AnyNode>."
        },
        {
          "name": "each",
          "type": "<T>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => boolean | void) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Iterates over each element. Uses Cheerio<T>."
        },
        {
          "name": "map",
          "type": "<T, M>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => M | M[]) => Cheerio<M>",
          "optional": false,
          "xaiDescription": "Maps each element to another value. Uses Cheerio<M>."
        },
        {
          "name": "filter",
          "type": "{ <T, S extends T>(this: Cheerio<T>, match: (this: T, index: number, value: T) => value is S): Cheerio<S>; <T, S extends AcceptedFilters<T>>(this: Cheerio<T>, match: S): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Filters elements based on a condition. Uses Cheerio<T>."
        },
        {
          "name": "filterArray",
          "type": "<T>(nodes: T[], match: AcceptedFilters<T>, xmlMode?: boolean, root?: Document) => T[] | Element[]",
          "optional": false,
          "xaiDescription": "Filters an array of nodes. Uses Document."
        },
        {
          "name": "is",
          "type": "<T>(this: Cheerio<T>, selector?: AcceptedFilters<T>) => boolean",
          "optional": false,
          "xaiDescription": "Checks if elements match the specified selector."
        },
        {
          "name": "not",
          "type": "<T extends AnyNode>(this: Cheerio<T>, match: AcceptedFilters<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes elements that match the specified selector. Uses Cheerio<T>."
        },
        {
          "name": "has",
          "type": "(this: Cheerio<AnyNode>, selectorOrHaystack: string | Element | Cheerio<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Finds elements that contain the specified content. Uses Cheerio<AnyNode>."
        },
        {
          "name": "first",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the first element in the Cheerio object. Uses Cheerio<T>."
        },
        {
          "name": "last",
          "type": "<T>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the last element in the Cheerio object. Uses Cheerio<T>."
        },
        {
          "name": "eq",
          "type": "<T>(this: Cheerio<T>, i: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the element at the specified index. Uses Cheerio<T>."
        },
        {
          "name": "get",
          "type": "{ <T>(this: Cheerio<T>, i: number): T; <T>(this: Cheerio<T>): T[]; }",
          "optional": false,
          "xaiDescription": "Gets the element at the specified index or all elements."
        },
        {
          "name": "toArray",
          "type": "<T>(this: Cheerio<T>) => T[]",
          "optional": false,
          "xaiDescription": "Converts the Cheerio object to an array."
        },
        {
          "name": "index",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrNeedle?: string | AnyNode | Cheerio<AnyNode>) => number",
          "optional": false,
          "xaiDescription": "Gets the position of the first element in the set."
        },
        {
          "name": "slice",
          "type": "<T>(this: Cheerio<T>, start?: number, end?: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Creates a new Cheerio object with a subset of elements. Uses Cheerio<T>."
        },
        {
          "name": "end",
          "type": "<T>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Ends the most recent filtering operation. Uses Cheerio<AnyNode>."
        },
        {
          "name": "add",
          "type": "<S extends AnyNode, T extends AnyNode>(this: Cheerio<T>, other: string | S | Cheerio<S> | S[], context?: string | Cheerio<S>) => Cheerio<S | T>",
          "optional": false,
          "xaiDescription": "Adds elements to the Cheerio object. Uses Cheerio<S | T>."
        },
        {
          "name": "addBack",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Adds the previous set of elements to the current set. Uses Cheerio<AnyNode>."
        },
        {
          "name": "parent",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the parent of each element. Uses Cheerio<Element>."
        },
        {
          "name": "parents",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the ancestors of each element. Uses Cheerio<Element>."
        },
        {
          "name": "parentsUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets the ancestors until the specified selector. Uses Cheerio<...>."
        },
        {
          "name": "next",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the immediately following sibling of each element. Uses Cheerio<Element>."
        },
        {
          "name": "nextAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets all following siblings of each element. Uses Cheerio<Element>."
        },
        {
          "name": "nextUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets all following siblings until the specified selector. Uses Cheerio<...>."
        },
        {
          "name": "prev",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the immediately preceding sibling of each element. Uses Cheerio<Element>."
        },
        {
          "name": "prevAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets all preceding siblings of each element. Uses Cheerio<Element>."
        },
        {
          "name": "prevUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets all preceding siblings until the specified selector. Uses Cheerio<...>."
        },
        {
          "name": "siblings",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the siblings of each element. Uses Cheerio<Element>."
        },
        {
          "name": "children",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the children of each element. Uses Cheerio<Element>."
        },
        {
          "name": "_makeDomArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>, elem?: BasicAcceptedElems<AnyNode> | BasicAcceptedElems<AnyNode>[], clone?: boolean) => AnyNode[]",
          "optional": false,
          "xaiDescription": "Creates an array of DOM nodes. Uses AnyNode."
        },
        {
          "name": "appendTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Appends elements to the target. Uses Cheerio<T>."
        },
        {
          "name": "prependTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Prepends elements to the target. Uses Cheerio<T>."
        },
        {
          "name": "unwrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes the parents of the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "wrapAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps all elements with the specified structure. Uses Cheerio<T>."
        },
        {
          "name": "after",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content after each element. Uses Cheerio<...>."
        },
        {
          "name": "insertAfter",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Inserts elements after the target. Uses Cheerio<T>."
        },
        {
          "name": "before",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content before each element. Uses Cheerio<...>."
        },
        {
          "name": "insertBefore",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Inserts elements before the target. Uses Cheerio<T>."
        },
        {
          "name": "remove",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes elements from the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "replaceWith",
          "type": "<T extends AnyNode>(this: Cheerio<T>, content: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Replaces elements with the specified content. Uses Cheerio<T>."
        },
        {
          "name": "empty",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes all child nodes from the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "html",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | Cheerio<T>): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the HTML content of elements. Uses Cheerio<T>."
        },
        {
          "name": "toString",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Returns the outer HTML of the first element."
        },
        {
          "name": "text",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | ((this: AnyNode, i: number, text: string) => string)): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the text content of elements. Uses Cheerio<T>."
        },
        {
          "name": "clone",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Creates a deep copy of the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "append",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content at the end of each element. Uses Cheerio<...>."
        },
        {
          "name": "prepend",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content at the beginning of each element. Uses Cheerio<...>."
        },
        {
          "name": "wrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps an HTML structure around each element. Uses Cheerio<T>."
        },
        {
          "name": "wrapInner",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps an HTML structure around the content of each element. Uses Cheerio<T>."
        },
        {
          "name": "css",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, names?: string[]): Record<string, string>; <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<...>, prop: string, val: string | ((this: Element, i: number, style: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<....",
          "optional": false,
          "xaiDescription": "Gets or sets the style properties of elements. Uses Cheerio<T>."
        },
        {
          "name": "serialize",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Encodes a set of form elements as a string for submission."
        },
        {
          "name": "serializeArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => { name: string; value: string; }[]",
          "optional": false,
          "xaiDescription": "Encodes a set of form elements as an array of objects."
        },
        {
          "name": "extract",
          "type": "<M extends ExtractMap, T extends AnyNode>(this: Cheerio<T>, map: M) => ExtractedMap<M>",
          "optional": false,
          "xaiDescription": "Extracts data from elements based on a map. Uses ExtractMap, ExtractedMap."
        },
        {
          "name": "__@iterator@1094",
          "type": "() => Iterator<T, any, any>",
          "optional": false,
          "xaiDescription": "Allows iteration over the elements."
        }
      ],
      "extends": [
        "MethodsType",
        "Iterable<T>"
      ],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents a collection of DOM nodes. Uses Cheerio<T>."
    },
    {
      "name": "StaticType",
      "type": "typeof import(\"/Users/Thy/TypeDefLib/node_modules/cheerio/dist/browser/static\")",
      "properties": [
        {
          "name": "html",
          "type": "{ (this: CheerioAPI, options?: CheerioOptions): string; (this: CheerioAPI, dom?: BasicAcceptedElems<AnyNode>, options?: CheerioOptions): string; }",
          "optional": false,
          "xaiDescription": "Gets or sets the HTML content of the document. Uses CheerioAPI, CheerioOptions."
        },
        {
          "name": "xml",
          "type": "(this: CheerioAPI, dom?: BasicAcceptedElems<AnyNode>) => string",
          "optional": false,
          "xaiDescription": "Gets the XML representation of the document. Uses CheerioAPI."
        },
        {
          "name": "text",
          "type": "(this: void | CheerioAPI, elements?: ArrayLike<AnyNode>) => string",
          "optional": false,
          "xaiDescription": "Gets the combined text contents of elements. Uses CheerioAPI."
        },
        {
          "name": "parseHTML",
          "type": "{ (this: CheerioAPI, data: string, context?: unknown, keepScripts?: boolean): AnyNode[]; (this: CheerioAPI, data?: \"\"): null; }",
          "optional": false,
          "xaiDescription": "Parses a string into an array of DOM nodes. Uses CheerioAPI, AnyNode."
        },
        {
          "name": "root",
          "type": "(this: CheerioAPI) => Cheerio<Document>",
          "optional": false,
          "xaiDescription": "Gets the root element of the document. Uses CheerioAPI, Cheerio<Document>."
        },
        {
          "name": "contains",
          "type": "(container: AnyNode, contained: AnyNode) => boolean",
          "optional": false,
          "xaiDescription": "Checks if one DOM node is a descendant of another. Uses AnyNode."
        },
        {
          "name": "extract",
          "type": "<M extends ExtractMap>(this: CheerioAPI, map: M) => ExtractedMap<M>",
          "optional": false,
          "xaiDescription": "Extracts data from the document based on a map. Uses CheerioAPI, ExtractMap, ExtractedMap."
        },
        {
          "name": "merge",
          "type": "<T>(arr1: Writable<ArrayLike<T>>, arr2: ArrayLike<T>) => ArrayLike<T>",
          "optional": false,
          "xaiDescription": "Merges two arrays. Uses Writable, ArrayLike."
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Static methods for Cheerio operations. Uses CheerioAPI."
    },
    {
      "name": "CheerioAPI",
      "type": "CheerioAPI",
      "properties": [
        {
          "name": "_root",
          "type": "Document",
          "optional": false,
          "xaiDescription": "Root document of the Cheerio instance. Uses Document."
        },
        {
          "name": "_options",
          "type": "InternalOptions",
          "optional": false,
          "xaiDescription": "Configuration options for the Cheerio instance. Uses InternalOptions."
        },
        {
          "name": "fn",
          "type": "Cheerio<any>",
          "optional": false,
          "xaiDescription": "Functionality of the Cheerio instance. Uses Cheerio<any>."
        },
        {
          "name": "load",
          "type": "(content: string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>, options?: CheerioOptions, isDocument?: boolean) => CheerioAPI",
          "optional": false,
          "xaiDescription": "Loads a document into the Cheerio instance. Uses CheerioAPI, CheerioOptions."
        },
        {
          "name": "html",
          "type": "{ (this: CheerioAPI, options?: CheerioOptions): string; (this: CheerioAPI, dom?: BasicAcceptedElems<AnyNode>, options?: CheerioOptions): string; }",
          "optional": false,
          "xaiDescription": "Gets or sets the HTML content of the document. Uses CheerioAPI, CheerioOptions."
        },
        {
          "name": "xml",
          "type": "(this: CheerioAPI, dom?: BasicAcceptedElems<AnyNode>) => string",
          "optional": false,
          "xaiDescription": "Gets the XML representation of the document. Uses CheerioAPI."
        },
        {
          "name": "text",
          "type": "(this: void | CheerioAPI, elements?: ArrayLike<AnyNode>) => string",
          "optional": false,
          "xaiDescription": "Gets the combined text contents of elements. Uses CheerioAPI."
        },
        {
          "name": "parseHTML",
          "type": "{ (this: CheerioAPI, data: string, context?: unknown, keepScripts?: boolean): AnyNode[]; (this: CheerioAPI, data?: \"\"): null; }",
          "optional": false,
          "xaiDescription": "Parses a string into an array of DOM nodes. Uses CheerioAPI, AnyNode."
        },
        {
          "name": "root",
          "type": "(this: CheerioAPI) => Cheerio<Document>",
          "optional": false,
          "xaiDescription": "Gets the root element of the document. Uses CheerioAPI, Cheerio<Document>."
        },
        {
          "name": "contains",
          "type": "(container: AnyNode, contained: AnyNode) => boolean",
          "optional": false,
          "xaiDescription": "Checks if one DOM node is a descendant of another. Uses AnyNode."
        },
        {
          "name": "extract",
          "type": "<M extends ExtractMap>(this: CheerioAPI, map: M) => ExtractedMap<M>",
          "optional": false,
          "xaiDescription": "Extracts data from the document based on a map. Uses CheerioAPI, ExtractMap, ExtractedMap."
        },
        {
          "name": "merge",
          "type": "<T>(arr1: Writable<ArrayLike<T>>, arr2: ArrayLike<T>) => ArrayLike<T>",
          "optional": false,
          "xaiDescription": "Merges two arrays. Uses Writable, ArrayLike."
        }
      ],
      "extends": [
        "StaticType"
      ],
      "jsdoc": {
        "description": "A querying function, bound to a document created from the provided markup.\n\nAlso provides several helper methods for dealing with the document as a\nwhole.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "API for querying and manipulating a document. Uses CheerioAPI."
    },
    {
      "name": "HTMLParser2Options",
      "type": "HTMLParser2Options",
      "properties": [
        {
          "name": "withStartIndices",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include start indices of tags."
        },
        {
          "name": "withEndIndices",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include end indices of tags."
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to parse in XML mode."
        },
        {
          "name": "decodeEntities",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to decode HTML entities."
        },
        {
          "name": "lowerCaseTags",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to convert tag names to lowercase."
        },
        {
          "name": "lowerCaseAttributeNames",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to convert attribute names to lowercase."
        },
        {
          "name": "recognizeCDATA",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to recognize CDATA sections."
        },
        {
          "name": "recognizeSelfClosing",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to recognize self-closing tags."
        },
        {
          "name": "Tokenizer",
          "type": "typeof Tokenizer",
          "optional": true,
          "xaiDescription": "Custom tokenizer to use. Uses Tokenizer."
        }
      ],
      "extends": [
        "DomHandlerOptions",
        "HTMLParser2ParserOptions"
      ],
      "jsdoc": {
        "description": "Options accepted by htmlparser2, the default parser for XML.",
        "params": [],
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Options for HTMLParser2. Uses HTMLParser2Options."
    },
    {
      "name": "CheerioOptions",
      "type": "CheerioOptions",
      "properties": [
        {
          "name": "xml",
          "type": "boolean | HTMLParser2Options",
          "optional": true,
          "xaiDescription": "Whether to parse in XML mode. Uses HTMLParser2Options."
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to parse in XML mode."
        },
        {
          "name": "baseURI",
          "type": "string | URL",
          "optional": true,
          "xaiDescription": "Base URI for resolving relative URLs."
        },
        {
          "name": "quirksMode",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to enable quirks mode."
        },
        {
          "name": "pseudos",
          "type": "Record<string, string | ((elem: Element, value?: string) => boolean)>",
          "optional": true,
          "xaiDescription": "Custom pseudo-selectors for querying."
        },
        {
          "name": "scriptingEnabled",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to enable scripting."
        },
        {
          "name": "sourceCodeLocationInfo",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include source code location info."
        },
        {
          "name": "treeAdapter",
          "type": "TreeAdapter<Htmlparser2TreeAdapterMap>",
          "optional": true,
          "xaiDescription": "Custom tree adapter for parsing. Uses TreeAdapter."
        },
        {
          "name": "onParseError",
          "type": "ParserErrorHandler",
          "optional": true,
          "xaiDescription": "Callback for parsing errors. Uses ParserErrorHandler."
        }
      ],
      "extends": [
        "Parse5ParserOptions<Htmlparser2TreeAdapterMap>"
      ],
      "jsdoc": {
        "description": "Options accepted by Cheerio.\n\nPlease note that parser-specific options are _only recognized_ if the\nrelevant parser is used.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Options for configuring Cheerio. Uses CheerioOptions."
    },
    {
      "name": "InternalOptions",
      "type": "InternalOptions",
      "properties": [
        {
          "name": "_useHtmlParser2",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to use HTMLParser2 for parsing."
        },
        {
          "name": "withStartIndices",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include start indices of tags."
        },
        {
          "name": "withEndIndices",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include end indices of tags."
        },
        {
          "name": "xmlMode",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to parse in XML mode."
        },
        {
          "name": "decodeEntities",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to decode HTML entities."
        },
        {
          "name": "lowerCaseTags",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to convert tag names to lowercase."
        },
        {
          "name": "lowerCaseAttributeNames",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to convert attribute names to lowercase."
        },
        {
          "name": "recognizeCDATA",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to recognize CDATA sections."
        },
        {
          "name": "recognizeSelfClosing",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to recognize self-closing tags."
        },
        {
          "name": "Tokenizer",
          "type": "typeof Tokenizer",
          "optional": true,
          "xaiDescription": "Custom tokenizer to use. Uses Tokenizer."
        },
        {
          "name": "quirksMode",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to enable quirks mode."
        },
        {
          "name": "pseudos",
          "type": "Record<string, string | ((elem: Element, value?: string) => boolean)>",
          "optional": true,
          "xaiDescription": "Custom pseudo-selectors for querying."
        },
        {
          "name": "baseURI",
          "type": "string | URL",
          "optional": true,
          "xaiDescription": "Base URI for resolving relative URLs."
        },
        {
          "name": "scriptingEnabled",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to enable scripting."
        },
        {
          "name": "sourceCodeLocationInfo",
          "type": "boolean",
          "optional": true,
          "xaiDescription": "Whether to include source code location info."
        },
        {
          "name": "treeAdapter",
          "type": "TreeAdapter<Htmlparser2TreeAdapterMap>",
          "optional": true,
          "xaiDescription": "Custom tree adapter for parsing. Uses TreeAdapter."
        },
        {
          "name": "onParseError",
          "type": "ParserErrorHandler",
          "optional": true,
          "xaiDescription": "Callback for parsing errors. Uses ParserErrorHandler."
        }
      ],
      "extends": [
        "HTMLParser2Options",
        "Omit<CheerioOptions, 'xml'>"
      ],
      "jsdoc": {
        "description": "Internal options for Cheerio.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Internal configuration options for Cheerio. Uses InternalOptions."
    },
    {
      "name": "Writable",
      "type": "Writable<T>",
      "properties": [],
      "extends": [],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "A writable stream. Uses Writable<T>."
    },
    {
      "name": "LowercaseLetters",
      "type": "LowercaseLetters",
      "properties": [
        {
          "name": "toString",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "charAt",
          "type": "(pos: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified position."
        },
        {
          "name": "charCodeAt",
          "type": "(index: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode value of the character at the specified index."
        },
        {
          "name": "concat",
          "type": "(...strings: string[]) => string",
          "optional": false,
          "xaiDescription": "Concatenates the given strings and returns a new string."
        },
        {
          "name": "indexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the first occurrence of the specified search string."
        },
        {
          "name": "lastIndexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the last occurrence of the specified search string."
        },
        {
          "name": "localeCompare",
          "type": "{ (that: string): number; (that: string, locales?: string | string[], options?: CollatorOptions): number; (that: string, locales?: LocalesArgument, options?: CollatorOptions): number; }",
          "optional": false,
          "xaiDescription": "Compares the string with another string, considering locale and options."
        },
        {
          "name": "match",
          "type": "{ (regexp: string | RegExp): RegExpMatchArray; (matcher: { [Symbol.match](string: string): RegExpMatchArray; }): RegExpMatchArray; }",
          "optional": false,
          "xaiDescription": "Matches the string against a regular expression and returns an array of matches."
        },
        {
          "name": "replace",
          "type": "{ (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: { ...; }, replaceValue: string): string; (searchValue: { ...; }, replacer: (substring: string, ...args: any[]) => string): string; }",
          "optional": false,
          "xaiDescription": "Replaces occurrences of a pattern in the string with a replacement string or function."
        },
        {
          "name": "search",
          "type": "{ (regexp: string | RegExp): number; (searcher: { [Symbol.search](string: string): number; }): number; }",
          "optional": false,
          "xaiDescription": "Searches for a match between a regular expression and the string, returning the index of the match."
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Extracts a section of the string and returns a new string."
        },
        {
          "name": "split",
          "type": "{ (separator: string | RegExp, limit?: number): string[]; (splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[]; }",
          "optional": false,
          "xaiDescription": "Splits the string into an array of substrings based on a separator and optional limit."
        },
        {
          "name": "substring",
          "type": "(start: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string between the specified start and end indices."
        },
        {
          "name": "toLowerCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase."
        },
        {
          "name": "toLocaleLowerCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase, considering locale and options."
        },
        {
          "name": "toUpperCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase."
        },
        {
          "name": "toLocaleUpperCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase, considering locale and options."
        },
        {
          "name": "trim",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from both ends of the string."
        },
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "The length of the string."
        },
        {
          "name": "substr",
          "type": "(from: number, length?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string, starting at the specified position and of the specified length."
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the string."
        },
        {
          "name": "codePointAt",
          "type": "(pos: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode code point value of the character at the specified position."
        },
        {
          "name": "includes",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string contains the specified search string."
        },
        {
          "name": "endsWith",
          "type": "(searchString: string, endPosition?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string ends with the specified search string."
        },
        {
          "name": "normalize",
          "type": "{ (form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string; (form?: string): string; }",
          "optional": false,
          "xaiDescription": "Returns the Unicode normalized form of the string."
        },
        {
          "name": "repeat",
          "type": "(count: number) => string",
          "optional": false,
          "xaiDescription": "Returns a new string containing the specified number of copies of the string."
        },
        {
          "name": "startsWith",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string starts with the specified search string."
        },
        {
          "name": "anchor",
          "type": "(name: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML anchor element with the specified name."
        },
        {
          "name": "big",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML big element."
        },
        {
          "name": "blink",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML blink element."
        },
        {
          "name": "bold",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML bold element."
        },
        {
          "name": "fixed",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML fixed element."
        },
        {
          "name": "fontcolor",
          "type": "(color: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified color."
        },
        {
          "name": "fontsize",
          "type": "{ (size: number): string; (size: string): string; }",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified size."
        },
        {
          "name": "italics",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML italics element."
        },
        {
          "name": "link",
          "type": "(url: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML hyperlink element with the specified URL."
        },
        {
          "name": "small",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML small element."
        },
        {
          "name": "strike",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML strike element."
        },
        {
          "name": "sub",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML subscript element."
        },
        {
          "name": "sup",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML superscript element."
        },
        {
          "name": "padStart",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the start of the string with the specified fill string."
        },
        {
          "name": "padEnd",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the end of the string with the specified fill string."
        },
        {
          "name": "trimEnd",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "trimStart",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimLeft",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimRight",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "matchAll",
          "type": "(regexp: RegExp) => RegExpStringIterator<RegExpExecArray>",
          "optional": false,
          "xaiDescription": "Returns an iterator of all matches of a regular expression against the string."
        },
        {
          "name": "__@iterator@2537",
          "type": "() => StringIterator<string>",
          "optional": false,
          "xaiDescription": "Returns an iterator for iterating over the string."
        },
        {
          "name": "at",
          "type": "(index: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified index."
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "",
        "params": [],
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Represents a set of lowercase letters."
    },
    {
      "name": "AlphaNumeric",
      "type": "AlphaNumeric",
      "properties": [
        {
          "name": "toString",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "charAt",
          "type": "(pos: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified position."
        },
        {
          "name": "charCodeAt",
          "type": "(index: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode value of the character at the specified index."
        },
        {
          "name": "concat",
          "type": "(...strings: string[]) => string",
          "optional": false,
          "xaiDescription": "Concatenates the given strings and returns a new string."
        },
        {
          "name": "indexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the first occurrence of the specified search string."
        },
        {
          "name": "lastIndexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the last occurrence of the specified search string."
        },
        {
          "name": "localeCompare",
          "type": "{ (that: string): number; (that: string, locales?: string | string[], options?: CollatorOptions): number; (that: string, locales?: LocalesArgument, options?: CollatorOptions): number; }",
          "optional": false,
          "xaiDescription": "Compares the string with another string, considering locale and options."
        },
        {
          "name": "match",
          "type": "{ (regexp: string | RegExp): RegExpMatchArray; (matcher: { [Symbol.match](string: string): RegExpMatchArray; }): RegExpMatchArray; }",
          "optional": false,
          "xaiDescription": "Matches the string against a regular expression and returns an array of matches."
        },
        {
          "name": "replace",
          "type": "{ (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: { ...; }, replaceValue: string): string; (searchValue: { ...; }, replacer: (substring: string, ...args: any[]) => string): string; }",
          "optional": false,
          "xaiDescription": "Replaces occurrences of a pattern in the string with a replacement string or function."
        },
        {
          "name": "search",
          "type": "{ (regexp: string | RegExp): number; (searcher: { [Symbol.search](string: string): number; }): number; }",
          "optional": false,
          "xaiDescription": "Searches for a match between a regular expression and the string, returning the index of the match."
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Extracts a section of the string and returns a new string."
        },
        {
          "name": "split",
          "type": "{ (separator: string | RegExp, limit?: number): string[]; (splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[]; }",
          "optional": false,
          "xaiDescription": "Splits the string into an array of substrings based on a separator and optional limit."
        },
        {
          "name": "substring",
          "type": "(start: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string between the specified start and end indices."
        },
        {
          "name": "toLowerCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase."
        },
        {
          "name": "toLocaleLowerCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase, considering locale and options."
        },
        {
          "name": "toUpperCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase."
        },
        {
          "name": "toLocaleUpperCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase, considering locale and options."
        },
        {
          "name": "trim",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from both ends of the string."
        },
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "The length of the string."
        },
        {
          "name": "substr",
          "type": "(from: number, length?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string, starting at the specified position and of the specified length."
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the string."
        },
        {
          "name": "codePointAt",
          "type": "(pos: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode code point value of the character at the specified position."
        },
        {
          "name": "includes",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string contains the specified search string."
        },
        {
          "name": "endsWith",
          "type": "(searchString: string, endPosition?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string ends with the specified search string."
        },
        {
          "name": "normalize",
          "type": "{ (form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string; (form?: string): string; }",
          "optional": false,
          "xaiDescription": "Returns the Unicode normalized form of the string."
        },
        {
          "name": "repeat",
          "type": "(count: number) => string",
          "optional": false,
          "xaiDescription": "Returns a new string containing the specified number of copies of the string."
        },
        {
          "name": "startsWith",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string starts with the specified search string."
        },
        {
          "name": "anchor",
          "type": "(name: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML anchor element with the specified name."
        },
        {
          "name": "big",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML big element."
        },
        {
          "name": "blink",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML blink element."
        },
        {
          "name": "bold",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML bold element."
        },
        {
          "name": "fixed",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML fixed element."
        },
        {
          "name": "fontcolor",
          "type": "(color: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified color."
        },
        {
          "name": "fontsize",
          "type": "{ (size: number): string; (size: string): string; }",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified size."
        },
        {
          "name": "italics",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML italics element."
        },
        {
          "name": "link",
          "type": "(url: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML hyperlink element with the specified URL."
        },
        {
          "name": "small",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML small element."
        },
        {
          "name": "strike",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML strike element."
        },
        {
          "name": "sub",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML subscript element."
        },
        {
          "name": "sup",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML superscript element."
        },
        {
          "name": "padStart",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the start of the string with the specified fill string."
        },
        {
          "name": "padEnd",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the end of the string with the specified fill string."
        },
        {
          "name": "trimEnd",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "trimStart",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimLeft",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimRight",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "matchAll",
          "type": "(regexp: RegExp) => RegExpStringIterator<RegExpExecArray>",
          "optional": false,
          "xaiDescription": "Returns an iterator of all matches of a regular expression against the string."
        },
        {
          "name": "__@iterator@2537",
          "type": "() => StringIterator<string>",
          "optional": false,
          "xaiDescription": "Returns an iterator for iterating over the string."
        },
        {
          "name": "at",
          "type": "(index: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified index."
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents a set of alphanumeric characters."
    },
    {
      "name": "SelectorSpecial",
      "type": "SelectorSpecial",
      "properties": [
        {
          "name": "toString",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "charAt",
          "type": "(pos: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified position."
        },
        {
          "name": "charCodeAt",
          "type": "(index: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode value of the character at the specified index."
        },
        {
          "name": "concat",
          "type": "(...strings: string[]) => string",
          "optional": false,
          "xaiDescription": "Concatenates the given strings and returns a new string."
        },
        {
          "name": "indexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the first occurrence of the specified search string."
        },
        {
          "name": "lastIndexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the last occurrence of the specified search string."
        },
        {
          "name": "localeCompare",
          "type": "{ (that: string): number; (that: string, locales?: string | string[], options?: CollatorOptions): number; (that: string, locales?: LocalesArgument, options?: CollatorOptions): number; }",
          "optional": false,
          "xaiDescription": "Compares the string with another string, considering locale and options."
        },
        {
          "name": "match",
          "type": "{ (regexp: string | RegExp): RegExpMatchArray; (matcher: { [Symbol.match](string: string): RegExpMatchArray; }): RegExpMatchArray; }",
          "optional": false,
          "xaiDescription": "Matches the string against a regular expression and returns an array of matches."
        },
        {
          "name": "replace",
          "type": "{ (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: { ...; }, replaceValue: string): string; (searchValue: { ...; }, replacer: (substring: string, ...args: any[]) => string): string; }",
          "optional": false,
          "xaiDescription": "Replaces occurrences of a pattern in the string with a replacement string or function."
        },
        {
          "name": "search",
          "type": "{ (regexp: string | RegExp): number; (searcher: { [Symbol.search](string: string): number; }): number; }",
          "optional": false,
          "xaiDescription": "Searches for a match between a regular expression and the string, returning the index of the match."
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Extracts a section of the string and returns a new string."
        },
        {
          "name": "split",
          "type": "{ (separator: string | RegExp, limit?: number): string[]; (splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[]; }",
          "optional": false,
          "xaiDescription": "Splits the string into an array of substrings based on a separator and optional limit."
        },
        {
          "name": "substring",
          "type": "(start: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string between the specified start and end indices."
        },
        {
          "name": "toLowerCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase."
        },
        {
          "name": "toLocaleLowerCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase, considering locale and options."
        },
        {
          "name": "toUpperCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase."
        },
        {
          "name": "toLocaleUpperCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase, considering locale and options."
        },
        {
          "name": "trim",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from both ends of the string."
        },
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "The length of the string."
        },
        {
          "name": "substr",
          "type": "(from: number, length?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string, starting at the specified position and of the specified length."
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the string."
        },
        {
          "name": "codePointAt",
          "type": "(pos: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode code point value of the character at the specified position."
        },
        {
          "name": "includes",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string contains the specified search string."
        },
        {
          "name": "endsWith",
          "type": "(searchString: string, endPosition?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string ends with the specified search string."
        },
        {
          "name": "normalize",
          "type": "{ (form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string; (form?: string): string; }",
          "optional": false,
          "xaiDescription": "Returns the Unicode normalized form of the string."
        },
        {
          "name": "repeat",
          "type": "(count: number) => string",
          "optional": false,
          "xaiDescription": "Returns a new string containing the specified number of copies of the string."
        },
        {
          "name": "startsWith",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string starts with the specified search string."
        },
        {
          "name": "anchor",
          "type": "(name: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML anchor element with the specified name."
        },
        {
          "name": "big",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML big element."
        },
        {
          "name": "blink",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML blink element."
        },
        {
          "name": "bold",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML bold element."
        },
        {
          "name": "fixed",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML fixed element."
        },
        {
          "name": "fontcolor",
          "type": "(color: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified color."
        },
        {
          "name": "fontsize",
          "type": "{ (size: number): string; (size: string): string; }",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified size."
        },
        {
          "name": "italics",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML italics element."
        },
        {
          "name": "link",
          "type": "(url: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML hyperlink element with the specified URL."
        },
        {
          "name": "small",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML small element."
        },
        {
          "name": "strike",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML strike element."
        },
        {
          "name": "sub",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML subscript element."
        },
        {
          "name": "sup",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML superscript element."
        },
        {
          "name": "padStart",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the start of the string with the specified fill string."
        },
        {
          "name": "padEnd",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the end of the string with the specified fill string."
        },
        {
          "name": "trimEnd",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "trimStart",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimLeft",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimRight",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "matchAll",
          "type": "(regexp: RegExp) => RegExpStringIterator<RegExpExecArray>",
          "optional": false,
          "xaiDescription": "Returns an iterator of all matches of a regular expression against the string."
        },
        {
          "name": "__@iterator@2537",
          "type": "() => StringIterator<string>",
          "optional": false,
          "xaiDescription": "Returns an iterator for iterating over the string."
        },
        {
          "name": "at",
          "type": "(index: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified index."
        }
      ],
      "extends": [],
      "jsdoc": null,
      "isExported": false,
      "xaiDescription": "Represents special characters used in selectors."
    },
    {
      "name": "SelectorType",
      "type": "SelectorType",
      "properties": [
        {
          "name": "toString",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "charAt",
          "type": "(pos: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified position."
        },
        {
          "name": "charCodeAt",
          "type": "(index: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode value of the character at the specified index."
        },
        {
          "name": "concat",
          "type": "(...strings: string[]) => string",
          "optional": false,
          "xaiDescription": "Concatenates the given strings and returns a new string."
        },
        {
          "name": "indexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the first occurrence of the specified search string."
        },
        {
          "name": "lastIndexOf",
          "type": "(searchString: string, position?: number) => number",
          "optional": false,
          "xaiDescription": "Returns the index of the last occurrence of the specified search string."
        },
        {
          "name": "localeCompare",
          "type": "{ (that: string): number; (that: string, locales?: string | string[], options?: CollatorOptions): number; (that: string, locales?: LocalesArgument, options?: CollatorOptions): number; }",
          "optional": false,
          "xaiDescription": "Compares the string with another string, considering locale and options."
        },
        {
          "name": "match",
          "type": "{ (regexp: string | RegExp): RegExpMatchArray; (matcher: { [Symbol.match](string: string): RegExpMatchArray; }): RegExpMatchArray; }",
          "optional": false,
          "xaiDescription": "Matches the string against a regular expression and returns an array of matches."
        },
        {
          "name": "replace",
          "type": "{ (searchValue: string | RegExp, replaceValue: string): string; (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string; (searchValue: { ...; }, replaceValue: string): string; (searchValue: { ...; }, replacer: (substring: string, ...args: any[]) => string): string; }",
          "optional": false,
          "xaiDescription": "Replaces occurrences of a pattern in the string with a replacement string or function."
        },
        {
          "name": "search",
          "type": "{ (regexp: string | RegExp): number; (searcher: { [Symbol.search](string: string): number; }): number; }",
          "optional": false,
          "xaiDescription": "Searches for a match between a regular expression and the string, returning the index of the match."
        },
        {
          "name": "slice",
          "type": "(start?: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Extracts a section of the string and returns a new string."
        },
        {
          "name": "split",
          "type": "{ (separator: string | RegExp, limit?: number): string[]; (splitter: { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number): string[]; }",
          "optional": false,
          "xaiDescription": "Splits the string into an array of substrings based on a separator and optional limit."
        },
        {
          "name": "substring",
          "type": "(start: number, end?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string between the specified start and end indices."
        },
        {
          "name": "toLowerCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase."
        },
        {
          "name": "toLocaleLowerCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to lowercase, considering locale and options."
        },
        {
          "name": "toUpperCase",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase."
        },
        {
          "name": "toLocaleUpperCase",
          "type": "{ (locales?: string | string[]): string; (locales?: LocalesArgument): string; }",
          "optional": false,
          "xaiDescription": "Returns the string converted to uppercase, considering locale and options."
        },
        {
          "name": "trim",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from both ends of the string."
        },
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "The length of the string."
        },
        {
          "name": "substr",
          "type": "(from: number, length?: number) => string",
          "optional": false,
          "xaiDescription": "Returns a substring of the string, starting at the specified position and of the specified length."
        },
        {
          "name": "valueOf",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the string."
        },
        {
          "name": "codePointAt",
          "type": "(pos: number) => number",
          "optional": false,
          "xaiDescription": "Returns the Unicode code point value of the character at the specified position."
        },
        {
          "name": "includes",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string contains the specified search string."
        },
        {
          "name": "endsWith",
          "type": "(searchString: string, endPosition?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string ends with the specified search string."
        },
        {
          "name": "normalize",
          "type": "{ (form: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\"): string; (form?: string): string; }",
          "optional": false,
          "xaiDescription": "Returns the Unicode normalized form of the string."
        },
        {
          "name": "repeat",
          "type": "(count: number) => string",
          "optional": false,
          "xaiDescription": "Returns a new string containing the specified number of copies of the string."
        },
        {
          "name": "startsWith",
          "type": "(searchString: string, position?: number) => boolean",
          "optional": false,
          "xaiDescription": "Determines whether the string starts with the specified search string."
        },
        {
          "name": "anchor",
          "type": "(name: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML anchor element with the specified name."
        },
        {
          "name": "big",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML big element."
        },
        {
          "name": "blink",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML blink element."
        },
        {
          "name": "bold",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML bold element."
        },
        {
          "name": "fixed",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML fixed element."
        },
        {
          "name": "fontcolor",
          "type": "(color: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified color."
        },
        {
          "name": "fontsize",
          "type": "{ (size: number): string; (size: string): string; }",
          "optional": false,
          "xaiDescription": "Creates an HTML font element with the specified size."
        },
        {
          "name": "italics",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML italics element."
        },
        {
          "name": "link",
          "type": "(url: string) => string",
          "optional": false,
          "xaiDescription": "Creates an HTML hyperlink element with the specified URL."
        },
        {
          "name": "small",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML small element."
        },
        {
          "name": "strike",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML strike element."
        },
        {
          "name": "sub",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML subscript element."
        },
        {
          "name": "sup",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Creates an HTML superscript element."
        },
        {
          "name": "padStart",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the start of the string with the specified fill string."
        },
        {
          "name": "padEnd",
          "type": "(maxLength: number, fillString?: string) => string",
          "optional": false,
          "xaiDescription": "Pads the end of the string with the specified fill string."
        },
        {
          "name": "trimEnd",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "trimStart",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimLeft",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the start of the string."
        },
        {
          "name": "trimRight",
          "type": "() => string",
          "optional": false,
          "xaiDescription": "Removes whitespace from the end of the string."
        },
        {
          "name": "matchAll",
          "type": "(regexp: RegExp) => RegExpStringIterator<RegExpExecArray>",
          "optional": false,
          "xaiDescription": "Returns an iterator of all matches of a regular expression against the string."
        },
        {
          "name": "__@iterator@2537",
          "type": "() => StringIterator<string>",
          "optional": false,
          "xaiDescription": "Returns an iterator for iterating over the string."
        },
        {
          "name": "at",
          "type": "(index: number) => string",
          "optional": false,
          "xaiDescription": "Returns the character at the specified index."
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Type for identifying selectors. Allows us to \"upgrade\" queries using\nselectors to return `Element`s.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Type for identifying selectors, used to upgrade queries to return `Element`s."
    },
    {
      "name": "BasicAcceptedElems",
      "type": "BasicAcceptedElems<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | (() => string)",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => Object)",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the object."
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Elements that can be passed to manipulation methods.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Elements that can be passed to manipulation methods."
    },
    {
      "name": "AcceptedElems",
      "type": "AcceptedElems<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | (() => string) | (() => string)",
          "optional": false,
          "xaiDescription": "Returns a string representation of the object."
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => Object)",
          "optional": false,
          "xaiDescription": "Returns the primitive value of the object."
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Elements that can be passed to manipulation methods, including functions.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Elements that can be passed to manipulation methods, including functions."
    },
    {
      "name": "FilterFunction",
      "type": "FilterFunction<T>",
      "properties": [],
      "extends": [],
      "jsdoc": {
        "description": "Function signature, for traversal methods.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Function signature used in traversal methods."
    },
    {
      "name": "AcceptedFilters",
      "type": "AcceptedFilters<T>",
      "properties": [
        {
          "name": "toString",
          "type": "(() => string) | (() => string) | (() => string) | (<T extends AnyNode>(this: Cheerio<T>) => string)",
          "optional": false,
          "xaiDescription": "Converts filter to string. Uses Cheerio<T>."
        },
        {
          "name": "valueOf",
          "type": "(() => string) | (() => Object)",
          "optional": false,
          "xaiDescription": "Returns value of filter as string or object."
        }
      ],
      "extends": [],
      "jsdoc": {
        "description": "Supported filter types, for traversal methods.",
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Defines types of filters used in traversal."
    }
  ],
  "classes": [
    {
      "name": "Cheerio",
      "constructors": [
        {
          "parameters": [
            {
              "name": "elements",
              "type": "ArrayLike<T>",
              "optional": false
            },
            {
              "name": "root",
              "type": "Cheerio<Document>",
              "optional": false
            },
            {
              "name": "options",
              "type": "InternalOptions",
              "optional": false
            }
          ],
          "returnType": "Cheerio<T>",
          "xaiDescription": "Initializes Cheerio with elements, root, and options."
        }
      ],
      "methods": [
        {
          "name": "Cheerio._make",
          "parameters": [
            {
              "name": "dom",
              "type": "string | T | ArrayLike<T>",
              "optional": false
            },
            {
              "name": "context",
              "type": "BasicAcceptedElems<AnyNode>",
              "optional": true
            }
          ],
          "returnType": "Cheerio<T>",
          "jsdoc": {
            "description": "Make a cheerio object.",
            "params": [
              {
                "name": "dom",
                "description": "- The contents of the new object."
              },
              {
                "name": "context",
                "description": "- The context of the new object."
              }
            ],
            "returns": "The new cheerio object.",
            "deprecated": false
          }
        },
        {
          "name": "Cheerio._parse",
          "parameters": [
            {
              "name": "content",
              "type": "string | AnyNode | AnyNode[] | Buffer<ArrayBufferLike>",
              "optional": false
            },
            {
              "name": "options",
              "type": "InternalOptions",
              "optional": false
            },
            {
              "name": "isDocument",
              "type": "boolean",
              "optional": false
            },
            {
              "name": "context",
              "type": "ParentNode",
              "optional": false
            }
          ],
          "returnType": "Document",
          "jsdoc": {
            "description": "Parses some content.",
            "params": [
              {
                "name": "content",
                "description": "- Content to parse."
              },
              {
                "name": "options",
                "description": "- Options for parsing."
              },
              {
                "name": "isDocument",
                "description": "- Allows parser to be switched to fragment mode."
              }
            ],
            "returns": "A document containing the `content`.",
            "deprecated": false
          }
        },
        {
          "name": "Cheerio._render",
          "parameters": [
            {
              "name": "dom",
              "type": "AnyNode | ArrayLike<AnyNode>",
              "optional": false
            }
          ],
          "returnType": "string",
          "jsdoc": {
            "description": "Render an element or a set of elements.",
            "params": [
              {
                "name": "dom",
                "description": "- DOM to render."
              }
            ],
            "returns": "The rendered DOM.",
            "deprecated": false
          }
        }
      ],
      "properties": [
        {
          "name": "length",
          "type": "number",
          "optional": false,
          "xaiDescription": "Number of elements in the Cheerio set."
        },
        {
          "name": "options",
          "type": "InternalOptions",
          "optional": false,
          "xaiDescription": "Options used to initialize Cheerio."
        },
        {
          "name": "_root",
          "type": "Cheerio<Document>",
          "optional": false,
          "xaiDescription": "Root element of the Cheerio set."
        },
        {
          "name": "prevObject",
          "type": "Cheerio<any>",
          "optional": false,
          "xaiDescription": "Previous Cheerio set in the chain."
        },
        {
          "name": "cheerio",
          "type": "\"[cheerio object]\"",
          "optional": false,
          "xaiDescription": "String identifier for Cheerio object."
        },
        {
          "name": "splice",
          "type": "{ (start: number, deleteCount?: number): any[]; (start: number, deleteCount: number, ...items: any[]): any[]; }",
          "optional": false,
          "xaiDescription": "Modifies the Cheerio set by adding/removing elements."
        },
        {
          "name": "attr",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<T>): Record<string, string>; <T extends AnyNode>(this: Cheerio<...>, name: string, value?: string | ((this: Element, i: number, attrib: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: R...",
          "optional": false,
          "xaiDescription": "Gets or sets attributes of elements. Uses Cheerio<T>."
        },
        {
          "name": "prop",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: \"tagName\" | \"nodeName\"): string; <T extends AnyNode>(this: Cheerio<T>, name: \"innerHTML\" | \"outerHTML\" | \"innerText\" | \"textContent\"): string; <T extends AnyNode>(this: Cheerio<...>, name: \"style\"): StyleProp; <T extends AnyNode>(this: Cheerio<...>, name: \"href\" | \"src\")...",
          "optional": false,
          "xaiDescription": "Gets or sets properties of elements. Uses Cheerio<T>."
        },
        {
          "name": "data",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, name: string): unknown; <T extends AnyNode>(this: Cheerio<T>): Record<string, unknown>; <T extends AnyNode>(this: Cheerio<T>, name: string, value: unknown): Cheerio<...>; <T extends AnyNode>(this: Cheerio<...>, values: Record<...>): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Gets or sets data attributes. Uses Cheerio<T>."
        },
        {
          "name": "val",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string | string[]; <T extends AnyNode>(this: Cheerio<T>, value: string | string[]): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the value of form elements. Uses Cheerio<T>."
        },
        {
          "name": "removeAttr",
          "type": "<T extends AnyNode>(this: Cheerio<T>, name: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes an attribute from elements. Uses Cheerio<T>."
        },
        {
          "name": "hasClass",
          "type": "<T extends AnyNode>(this: Cheerio<T>, className: string) => boolean",
          "optional": false,
          "xaiDescription": "Checks if elements have a class. Uses Cheerio<T>."
        },
        {
          "name": "addClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Adds a class to elements. Uses Cheerio<T>."
        },
        {
          "name": "removeClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, name?: string | ((this: Element, i: number, className: string) => string)) => R",
          "optional": false,
          "xaiDescription": "Removes a class from elements. Uses Cheerio<T>."
        },
        {
          "name": "toggleClass",
          "type": "<T extends AnyNode, R extends ArrayLike<T>>(this: R, value?: string | ((this: Element, i: number, className: string, stateVal?: boolean) => string), stateVal?: boolean) => R",
          "optional": false,
          "xaiDescription": "Toggles a class on elements. Uses Cheerio<T>."
        },
        {
          "name": "find",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrHaystack?: string | Element | Cheerio<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Finds elements within the Cheerio set. Uses Cheerio<T>."
        },
        {
          "name": "_findBySelector",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector: string, limit: number) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Finds elements by selector with a limit. Uses Cheerio<T>."
        },
        {
          "name": "closest",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Finds the closest ancestor matching the selector. Uses Cheerio<T>."
        },
        {
          "name": "contents",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Gets the children of each element. Uses Cheerio<T>."
        },
        {
          "name": "each",
          "type": "<T>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => boolean | void) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Iterates over elements. Uses Cheerio<T>."
        },
        {
          "name": "map",
          "type": "<T, M>(this: Cheerio<T>, fn: (this: T, i: number, el: T) => M | M[]) => Cheerio<M>",
          "optional": false,
          "xaiDescription": "Maps elements to a new Cheerio set. Uses Cheerio<T>."
        },
        {
          "name": "filter",
          "type": "{ <T, S extends T>(this: Cheerio<T>, match: (this: T, index: number, value: T) => value is S): Cheerio<S>; <T, S extends AcceptedFilters<T>>(this: Cheerio<T>, match: S): Cheerio<...>; }",
          "optional": false,
          "xaiDescription": "Filters elements based on a condition. Uses Cheerio<T>."
        },
        {
          "name": "filterArray",
          "type": "<T>(nodes: T[], match: AcceptedFilters<T>, xmlMode?: boolean, root?: Document) => T[] | Element[]",
          "optional": false,
          "xaiDescription": "Filters an array of nodes. Uses AcceptedFilters<T>."
        },
        {
          "name": "is",
          "type": "<T>(this: Cheerio<T>, selector?: AcceptedFilters<T>) => boolean",
          "optional": false,
          "xaiDescription": "Checks if elements match a selector. Uses Cheerio<T>."
        },
        {
          "name": "not",
          "type": "<T extends AnyNode>(this: Cheerio<T>, match: AcceptedFilters<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes elements that match a selector. Uses Cheerio<T>."
        },
        {
          "name": "has",
          "type": "(this: Cheerio<AnyNode>, selectorOrHaystack: string | Element | Cheerio<Element>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Finds elements that have descendants matching the selector."
        },
        {
          "name": "first",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the first element in the set. Uses Cheerio<T>."
        },
        {
          "name": "last",
          "type": "<T>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the last element in the set. Uses Cheerio<T>."
        },
        {
          "name": "eq",
          "type": "<T>(this: Cheerio<T>, i: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Gets the element at the specified index. Uses Cheerio<T>."
        },
        {
          "name": "get",
          "type": "{ <T>(this: Cheerio<T>, i: number): T; <T>(this: Cheerio<T>): T[]; }",
          "optional": false,
          "xaiDescription": "Gets elements by index or all elements. Uses Cheerio<T>."
        },
        {
          "name": "toArray",
          "type": "<T>(this: Cheerio<T>) => T[]",
          "optional": false,
          "xaiDescription": "Converts the Cheerio set to an array. Uses Cheerio<T>."
        },
        {
          "name": "index",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selectorOrNeedle?: string | AnyNode | Cheerio<AnyNode>) => number",
          "optional": false,
          "xaiDescription": "Gets the position of an element. Uses Cheerio<T>."
        },
        {
          "name": "slice",
          "type": "<T>(this: Cheerio<T>, start?: number, end?: number) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Extracts a subset of elements. Uses Cheerio<T>."
        },
        {
          "name": "end",
          "type": "<T>(this: Cheerio<T>) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Ends the most recent filtering operation. Uses Cheerio<T>."
        },
        {
          "name": "add",
          "type": "<S extends AnyNode, T extends AnyNode>(this: Cheerio<T>, other: string | S | Cheerio<S> | S[], context?: string | Cheerio<S>) => Cheerio<S | T>",
          "optional": false,
          "xaiDescription": "Adds elements to the set. Uses Cheerio<T>."
        },
        {
          "name": "addBack",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<AnyNode>",
          "optional": false,
          "xaiDescription": "Adds the previous set of elements to the current set. Uses Cheerio<T>."
        },
        {
          "name": "parent",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the parent of each element. Uses Cheerio<T>."
        },
        {
          "name": "parents",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the ancestors of each element. Uses Cheerio<T>."
        },
        {
          "name": "parentsUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets ancestors until a selector is reached. Uses Cheerio<T>."
        },
        {
          "name": "next",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the immediately following sibling of each element. Uses Cheerio<T>."
        },
        {
          "name": "nextAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets all following siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "nextUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets following siblings until a selector is reached. Uses Cheerio<T>."
        },
        {
          "name": "prev",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the immediately preceding sibling of each element. Uses Cheerio<T>."
        },
        {
          "name": "prevAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets all preceding siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "prevUntil",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>, filterSelector?: AcceptedFilters<Element>) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Gets preceding siblings until a selector is reached. Uses Cheerio<T>."
        },
        {
          "name": "siblings",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the siblings of each element. Uses Cheerio<T>."
        },
        {
          "name": "children",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: AcceptedFilters<Element>) => Cheerio<Element>",
          "optional": false,
          "xaiDescription": "Gets the children of each element. Uses Cheerio<T>."
        },
        {
          "name": "_makeDomArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>, elem?: BasicAcceptedElems<AnyNode> | BasicAcceptedElems<AnyNode>[], clone?: boolean) => AnyNode[]",
          "optional": false,
          "xaiDescription": "Creates an array of DOM nodes. Uses Cheerio<T>."
        },
        {
          "name": "appendTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Appends elements to the target. Uses Cheerio<T>."
        },
        {
          "name": "prependTo",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Prepends elements to the target. Uses Cheerio<T>."
        },
        {
          "name": "unwrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes the parents of the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "wrapAll",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps all elements with a structure. Uses Cheerio<T>."
        },
        {
          "name": "after",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content after each element. Uses Cheerio<T>."
        },
        {
          "name": "insertAfter",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Inserts elements after the target. Uses Cheerio<T>."
        },
        {
          "name": "before",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Inserts content before each element. Uses Cheerio<T>."
        },
        {
          "name": "insertBefore",
          "type": "<T extends AnyNode>(this: Cheerio<T>, target: BasicAcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Inserts elements before the target. Uses Cheerio<T>."
        },
        {
          "name": "remove",
          "type": "<T extends AnyNode>(this: Cheerio<T>, selector?: string) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes elements from the set. Uses Cheerio<T>."
        },
        {
          "name": "replaceWith",
          "type": "<T extends AnyNode>(this: Cheerio<T>, content: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Replaces elements with new content. Uses Cheerio<T>."
        },
        {
          "name": "empty",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Removes all children of the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "html",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | Cheerio<T>): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the HTML contents of elements. Uses Cheerio<T>."
        },
        {
          "name": "toString",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Converts the Cheerio set to a string. Uses Cheerio<T>."
        },
        {
          "name": "text",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>): string; <T extends AnyNode>(this: Cheerio<T>, str: string | ((this: AnyNode, i: number, text: string) => string)): Cheerio<T>; }",
          "optional": false,
          "xaiDescription": "Gets or sets the text contents of elements. Uses Cheerio<T>."
        },
        {
          "name": "clone",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Creates a deep copy of the set of matched elements. Uses Cheerio<T>."
        },
        {
          "name": "append",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Appends content to the end of each element. Uses Cheerio<T>."
        },
        {
          "name": "prepend",
          "type": "<T extends AnyNode>(this: Cheerio<...>, ...elems: BasicAcceptedElems<AnyNode>[] | [(this: AnyNode, i: number, html: string) => BasicAcceptedElems<AnyNode>]) => Cheerio<...>",
          "optional": false,
          "xaiDescription": "Prepends content to the beginning of each element. Uses Cheerio<T>."
        },
        {
          "name": "wrap",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps an HTML structure around each element. Uses Cheerio<T>."
        },
        {
          "name": "wrapInner",
          "type": "<T extends AnyNode>(this: Cheerio<T>, wrapper: AcceptedElems<AnyNode>) => Cheerio<T>",
          "optional": false,
          "xaiDescription": "Wraps an HTML structure around the content of each element. Uses Cheerio<T>."
        },
        {
          "name": "css",
          "type": "{ <T extends AnyNode>(this: Cheerio<T>, names?: string[]): Record<string, string>; <T extends AnyNode>(this: Cheerio<T>, name: string): string; <T extends AnyNode>(this: Cheerio<...>, prop: string, val: string | ((this: Element, i: number, style: string) => string)): Cheerio<...>; <T extends AnyNode>(this: Cheerio<....",
          "optional": false,
          "xaiDescription": "Gets or sets styles of elements. Uses Cheerio<T>."
        },
        {
          "name": "serialize",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => string",
          "optional": false,
          "xaiDescription": "Encodes a set of form elements as a string for submission. Uses Cheerio<T>."
        },
        {
          "name": "serializeArray",
          "type": "<T extends AnyNode>(this: Cheerio<T>) => { name: string; value: string; }[]",
          "optional": false,
          "xaiDescription": "Encodes a set of form elements as an array of names and values. Uses Cheerio<T>."
        },
        {
          "name": "extract",
          "type": "<M extends ExtractMap, T extends AnyNode>(this: Cheerio<T>, map: M) => ExtractedMap<M>",
          "optional": false,
          "xaiDescription": "Extracts data from elements based on a map. Uses Cheerio<T>."
        },
        {
          "name": "__@iterator@1094",
          "type": "() => Iterator<T, any, any>",
          "optional": false,
          "xaiDescription": "Provides an iterator for the Cheerio set."
        }
      ],
      "implements": [
        "ArrayLike<T>"
      ],
      "jsdoc": {
        "description": "The cheerio class is the central class of the library. It wraps a set of\nelements and provides an API for traversing, modifying, and interacting with\nthe set.\n\nLoading a document will return the Cheerio class bound to the root element of\nthe document. The class will be instantiated when querying the document (when\ncalling `$('selector')`).",
        "params": [],
        "deprecated": false
      },
      "isExported": false,
      "xaiDescription": "Central class for DOM manipulation and traversal."
    }
  ],
  "constants": [],
  "namespaces": [
    {
      "name": "cheerio",
      "contents": {
        "functions": [
          {
            "name": "loadBuffer",
            "parameters": [
              {
                "name": "buffer",
                "type": "Buffer<ArrayBufferLike>",
                "optional": false
              },
              {
                "name": "options",
                "type": "DecodeStreamOptions",
                "optional": true
              }
            ],
            "returnType": "CheerioAPI",
            "jsdoc": {
              "description": "Sniffs the encoding of a buffer, then creates a querying function bound to a\ndocument created from the buffer.",
              "params": [
                {
                  "name": "buffer",
                  "description": "- The buffer to sniff the encoding of."
                },
                {
                  "name": "options",
                  "description": "- The options to pass to Cheerio."
                }
              ],
              "returns": "The loaded document.",
              "deprecated": false
            }
          },
          {
            "name": "stringStream",
            "parameters": [
              {
                "name": "options",
                "type": "CheerioOptions",
                "optional": false
              },
              {
                "name": "cb",
                "type": "(err: Error, $: CheerioAPI) => void",
                "optional": false
              }
            ],
            "returnType": "Writable",
            "jsdoc": {
              "description": "Creates a stream that parses a sequence of strings into a document.\n\nThe stream is a `Writable` stream that accepts strings. When the stream is\nfinished, the callback is called with the loaded document.",
              "params": [
                {
                  "name": "options",
                  "description": "- The options to pass to Cheerio."
                },
                {
                  "name": "cb",
                  "description": "- The callback to call when the stream is finished."
                }
              ],
              "returns": "The writable stream.",
              "deprecated": false
            }
          },
          {
            "name": "decodeStream",
            "parameters": [
              {
                "name": "options",
                "type": "DecodeStreamOptions",
                "optional": false
              },
              {
                "name": "cb",
                "type": "(err: Error, $: CheerioAPI) => void",
                "optional": false
              }
            ],
            "returnType": "Writable",
            "jsdoc": {
              "description": "Parses a stream of buffers into a document.\n\nThe stream is a `Writable` stream that accepts buffers. When the stream is\nfinished, the callback is called with the loaded document.",
              "params": [
                {
                  "name": "options",
                  "description": "- The options to pass to Cheerio."
                },
                {
                  "name": "cb",
                  "description": "- The callback to call when the stream is finished."
                }
              ],
              "returns": "The writable stream.",
              "deprecated": false
            }
          },
          {
            "name": "fromURL",
            "parameters": [
              {
                "name": "url",
                "type": "string | URL",
                "optional": false
              },
              {
                "name": "options",
                "type": "CheerioRequestOptions",
                "optional": true
              }
            ],
            "returnType": "Promise<CheerioAPI>",
            "jsdoc": {
              "description": "`fromURL` loads a document from a URL.\n\nBy default, redirects are allowed and non-2xx responses are rejected.",
              "params": [
                {
                  "name": "url",
                  "description": "- The URL to load the document from."
                },
                {
                  "name": "options",
                  "description": "- The options to pass to Cheerio."
                }
              ],
              "returns": "The loaded document.",
              "deprecated": false
            }
          },
          {
            "name": "contains",
            "parameters": [
              {
                "name": "container",
                "type": "AnyNode",
                "optional": false
              },
              {
                "name": "contained",
                "type": "AnyNode",
                "optional": false
              }
            ],
            "returnType": "boolean",
            "jsdoc": null,
            "xaiDescription": "Checks if one node contains another."
          },
          {
            "name": "merge",
            "parameters": [
              {
                "name": "arr1",
                "type": "Writable<ArrayLike<T>>",
                "optional": false
              },
              {
                "name": "arr2",
                "type": "ArrayLike<T>",
                "optional": false
              }
            ],
            "returnType": "ArrayLike<T>",
            "jsdoc": null,
            "xaiDescription": "Merges two arrays into one."
          },
          {
            "name": "load",
            "parameters": [
              {
                "name": "content",
                "type": "string | Buffer<ArrayBufferLike> | AnyNode | AnyNode[]",
                "optional": false
              },
              {
                "name": "options",
                "type": "CheerioOptions",
                "optional": true
              },
              {
                "name": "isDocument",
                "type": "boolean",
                "optional": true
              }
            ],
            "returnType": "CheerioAPI",
            "jsdoc": null,
            "xaiDescription": "Loads content into a Cheerio instance."
          }
        ],
        "enums": [],
        "types": [],
        "classes": [],
        "constants": []
      },
      "jsdoc": null,
      "isExported": true,
      "xaiDescription": "Namespace for Cheerio utility functions."
    }
  ],
  "version": "1.0.0"
}